<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python学习：Python基础（中）]]></title>
    <url>%2F2019%2F07%2F24%2FPython%E5%AD%A6%E4%B9%A0%EF%BC%9APython%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构（下）:Python容器列表：list list是由任意类型元素组成的序列。列表非常适合利用顺序和位置定位某一元素，尤其是当元素的顺序或内容经常发生改变时。与字符串不同，列表是可变的。你可以直接对原始列表进行修改：添加新元素、删除 或覆盖已有元素。在列表中，具有相同值的元素允许出现多次。 *Python中的三种序列结构：字符串，列表，元组。它们都可以包含零个或多个元素。与字符串不同的是，元组和列表并不要求所含元素的种类相同，每个元素都可以是任何Python类型的对象。而对于列表和元组来说，元组是不可变的，当你给元组赋值时，这些值便被固定在了元组里，再也无法修改。然而，列表却是可变的，这意味着可以随意地插入或删除其中的元素。 list =&gt; [&lt;exp&gt;,&lt;exp&gt;] 创建列表:使用[]或list()&gt;&gt;&gt; empty_list = [] &gt;&gt;&gt; weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'] &gt;&gt;&gt; big_birds = ['emu', 'ostrich', 'cassowary'] &gt;&gt;&gt; first_names = ['Graham', 'John', 'Terry', 'Terry', 'Michael'] 也可以使用list()函数来创建一个空列表： &gt;&gt;&gt; another_empty_list = list() &gt;&gt;&gt; another_empty_list [] 转换成列表:使用list()Python的list()函数可以将其他数据类型转换成列表类型。 # 将字符串-》列表&gt;&gt;&gt; list('cat') ['c', 'a', 't']# 使用 split() 可以依据分隔符将字符串切割成由若干子串组成的列表：&gt;&gt;&gt; birthday = '1/6/1952' &gt;&gt;&gt; birthday.split('/') ['1', '6', '1952']# 如果待分割的字符串中包含连续的分隔符，那么在返回的列表中会出现空串元素：&gt;&gt;&gt; splitme = 'a/b//c/d///e' &gt;&gt;&gt; splitme.split('/') ['a', 'b', '', 'c', 'd', '', '', 'e']# 将元组-》列表&gt;&gt;&gt; a_tuple = ('ready', 'fire', 'aim') &gt;&gt;&gt; list(a_tuple) ['ready', 'fire', 'aim'] 获取列表元素：使用[offset]和字符串一样，通过偏移量可以从列表中提取对应位置的元素： &gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes[0] 'Groucho' &gt;&gt;&gt; marxes[1] 'Chico' &gt;&gt;&gt; marxes[2] 'Harpo'#负偏移量代表从尾部开始计数：&gt;&gt;&gt; marxes[-1] 'Harpo' &gt;&gt;&gt; marxes[-2] 'Chico' &gt;&gt;&gt; marxes[-3] 'Groucho' &gt;&gt;&gt; *指定的偏移量对于待访问列表必须有效——该位置的元素在访问前已正确赋值。当指定的偏移量小于起始位置或者大于末尾位置时，会产生异常（错误）。 包含列表的列表列表可以包含各种类型的元素，包括其他列表，如下所示： &gt;&gt;&gt; small_birds = ['hummingbird', 'finch'] &gt;&gt;&gt; extinct_birds = ['dodo', 'passenger pigeon', 'Norwegian Blue'] &gt;&gt;&gt; carol_birds = [3, 'French hens', 2, 'turtledoves'] &gt;&gt;&gt; all_birds = [small_birds, extinct_birds, 'macaw', carol_birds]# all_birds结构&gt;&gt;&gt; all_birds [['hummingbird', 'finch'], ['dodo', 'passenger pigeon', 'Norwegian Blue'], 'macaw', [3, 'French hens', 2, 'turtledoves']]# all_birds第一个元素&gt;&gt;&gt; all_birds[0] ['hummingbird', 'finch'] 使用[offset]修改元素就像可以通过偏移量访问某元素一样，你也可以通过赋值对它进行修改： &gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes[2] = 'Wanda' &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Wanda'] *与之前一样，列表的偏移量必须是合法有效的。 指定范围并使用切片提取元素列表的切片仍然是一个列表。可以使用切片提取列表的一个子序列,与字符串一样，列表的切片也可以设定除1以外的步长。 &gt;&gt;&gt; marxes = ['Groucho', 'Chico,' 'Harpo'] &gt;&gt;&gt; marxes[0:2] ['Groucho', 'Chico']#从列表的开头开始每2个提取一个元素&gt;&gt;&gt; marxes[::2] ['Groucho', 'Harpo']# 可以巧妙地实现列表逆序：&gt;&gt;&gt; marxes[::-1] ['Harpo', 'Chico', 'Groucho'] 添加元素至尾部:使用append()利用append()函数将元素一个个添加到尾部。 &gt;&gt;&gt; marxes.append('Zeppo') &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo'] 合并列表：使用extend()或+=使用extend()可以将一个列表合并到另一个列表中。 &gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl'] &gt;&gt;&gt; marxes.extend(others) &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo', 'Gummo', 'Karl'] 也可以使用+=： &gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl'] &gt;&gt;&gt; marxes += others &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo', 'Gummo', 'Karl'] 如果使用了append()，那么others会被当成一个单独的元素进行添加,而不是将其中的内容进行合并： &gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl'] &gt;&gt;&gt; marxes.append(others) &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo', ['Gummo', 'Karl']] 在指定位置插入元素 :使用insert()append()函数只能将新元素插入到列表尾，而使用insert()可以将元素插入到列表的任 意位置。指定偏移量为0可以插入列表头部。如果指定的偏移量超过了尾部，则会插入到 列表最后，就如同append() 一样，这一操作不会产生 Python 异常。 &gt;&gt;&gt; marxes.insert(3, 'Gummo')&gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo'] &gt;&gt;&gt; marxes.insert(10, 'Karl') &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo', 'Karl'] 删除指定位置的元素:使用del当列表中一个元素被删除后,位于它后面的元素会自动往前移动填补空出的位置，且列表 长度减 1。再试试从更新后的marxes列表中删除&#39;Harpo&#39;： &gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo'] &gt;&gt;&gt; marxes[2] 'Harpo' &gt;&gt;&gt; del marxes[2] &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Gummo', 'Zeppo'] &gt;&gt;&gt; marxes[2] 'Gummo' 在列表首删除/插入一个元素与在列表尾插入一个元素所用的时间是谁大？或者一样？# 计算时间函数&gt;&gt;&gt; from time import clock&gt;&gt;&gt; def timer(f):&gt;&gt;&gt; def _f(*args):&gt;&gt;&gt; t0 = clock()&gt;&gt;&gt; f(*args)&gt;&gt;&gt; return clock() - t0&gt;&gt;&gt; return _f # 删除 &gt;&gt;&gt; def delete_elem(x, index):&gt;&gt;&gt; del x[index]&gt;&gt;&gt; x = [5] * 100000000&gt;&gt;&gt; print(x[0])5&gt;&gt;&gt; print(x[999999])5&gt;&gt;&gt; print(len(x))100000000&gt;&gt;&gt; end_del = timer(delete_elem)(x, -1)&gt;&gt;&gt; print('现在list长度:',len(x))现在list长度: 99999999&gt;&gt;&gt; start_del = timer(delete_elem)(x, 0)&gt;&gt;&gt; print('现在list长度:',len(x))现在list长度: 99999998&gt;&gt;&gt; print('删首时间/删尾时间',start_del/end_del)删首时间/删尾时间 5339.656807434651# 插入&gt;&gt;&gt; def insert_elem(x, index, v):&gt;&gt;&gt; x.insert(index, v) &gt;&gt;&gt; x = [5] * 100000000&gt;&gt;&gt; print(x[0])5&gt;&gt;&gt; print(x[999999])5&gt;&gt;&gt; print(len(x))100000000&gt;&gt;&gt; start_del = timer(insert_elem)(x, 0, 9)&gt;&gt;&gt; print(len(x))100000001&gt;&gt;&gt; end_del = timer(insert_elem)(x, -1, 9)&gt;&gt;&gt; print(len(x))100000002&gt;&gt;&gt; print('删首时间/删尾时间',start_del/end_del)删首时间/删尾时间 200615.78078284615 由上面可知在列表首删除/插入一个元素远远大于在列表尾插入一个元素所用的时间。原因在于列表在存储时，是存在于一片连续的储存单元中。删除最后一个元素时候，只要根据index找到该元素，然后删除。而删除第一个元素时候，需要找到第一个元素删除的同时，需要把其后面的元素移前一个位置。插入同理。 删除具有指定值的元素:使用remove()&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo'] &gt;&gt;&gt; marxes.remove('Gummo') &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo'] 获取并删除指定位置的元素:使用pop()使用pop()同样可以获取列表中指定位置的元素，但在获取完成后，该元素会被自动删除。如果你为pop()指定了偏移量，它会返回偏移量对应位置的元素；如果不指定，则默认使用-1。因此，pop(0)将返回列表的头元素，而pop()或pop(-1)则会返回列表的尾元素 &gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; marxes.pop() 'Zeppo' &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes.pop(1) 'Chico' &gt;&gt;&gt; marxes ['Groucho', 'Harpo'] 查询具有特定值的元素位置:使用index()如果该查询的元素在列表中不存在，使用index时会报异常。 &gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; marxes.index('Chico') 1 判断值是否存在：使用in同一个值可能出现在列表的多个位置，但只要至少出现一次，in就会返回True： &gt;&gt;&gt; words = ['a', 'deer', 'a' 'female', 'deer'] &gt;&gt;&gt; 'deer' in words True 记录特定值出现的次数:使用count()&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes.count('Harpo') 1 &gt;&gt;&gt; marxes.count('Bob')0 &gt;&gt;&gt; snl_skit = ['cheeseburger', 'cheeseburger', 'cheeseburger']&gt;&gt;&gt; snl_skit.count('cheeseburger') 3 转换为字符串:使用join()join()实际上是一个字符串方法，而不是列表方法。不能通过marxes.join(&#39;,&#39;)进行调用，尽管这可能看起来更直观。join() 函数的参数是字符串或者其他可迭代的包含字符串的序列，它的输出是一个字符串。。试着这样来记忆 join() 的调用顺序： join()是split()的逆过程 &gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; ', '.join(marxes) 'Groucho, Chico, Harpo'&gt;&gt;&gt; friends = ['Harry', 'Hermione', 'Ron'] &gt;&gt;&gt; separator = ' * ' &gt;&gt;&gt; joined = separator.join(friends) &gt;&gt;&gt; joined 'Harry * Hermione * Ron' &gt;&gt;&gt; separated = joined.split(separator) &gt;&gt;&gt; separated ['Harry', 'Hermione', 'Ron'] &gt;&gt;&gt; separated == friends True 获取长度:使用len()&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; len(marxes) 3 使用sort()重新排列元素将列表中的元素按值排序,Python 为此 提供了两个函数： 列表方法sort()会对原列表进行排序，改变原列表内容； 通用函数sorted()则会返回排好序的列表副本，原列表内容不变。 如果列表中的元素都是数字，它们会默认地被排列成从小到大的升序。如果元素都是字符 串，则会按照字母表顺序排列 # sorted_marxes是一个副本，它的创建并不会改变原始列表的内容&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; sorted_marxes = sorted(marxes) &gt;&gt;&gt; sorted_marxes ['Chico', 'Groucho', 'Harpo']&gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo']# 但对 marxes 列表调用列表函数 sort() 则会改变它的内容&gt;&gt;&gt; marxes.sort() &gt;&gt;&gt; marxes ['Chico', 'Groucho', 'Harpo'] 当列表中的所有元素都是同一种类型时（例如marxes中都是字符串），sort()会正常工作。有些时候甚至多种类型也可——例如整型和浮点型——只要它们之间能够自动地互相转换 &gt;&gt;&gt; numbers = [2, 1, 4.0, 3] &gt;&gt;&gt; numbers.sort() &gt;&gt;&gt; numbers [1, 2, 3, 4.0] 默认的排序是升序的，通过添加参数reverse=True可以改变为降序排列 &gt;&gt;&gt; numbers = [2, 1, 4.0, 3] &gt;&gt;&gt; numbers.sort(reverse=True) &gt;&gt;&gt; numbers[4.0, 3, 2, 1] 使用=赋值，使用copy()复制如果将一个列表赋值给了多个变量，改变其中的任何一处会造成其他变量对应的值也被修改。 &gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; a [1, 2, 3] &gt;&gt;&gt; b = a &gt;&gt;&gt; b [1, 2, 3] &gt;&gt;&gt; a[0] = 'surprise' &gt;&gt;&gt; a ['surprise', 2, 3]&gt;&gt;&gt; b ['surprise', 2, 3] b与a实际上指向的是同一个对象，因此，无论我们是通过a还是通过b来修改列表的内容，其结果都会作用于双方。通过下面任意一种方法，都可以将一个列表的值复制到另一个新的列表中： 列表copy()函数 list()转换函数 列表分片[:]&gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; b = a.copy() &gt;&gt;&gt; c = list(a) &gt;&gt;&gt; d = a[:]&gt;&gt;&gt; a[0] = 'integer lists are boring' &gt;&gt;&gt; a ['integer lists are boring', 2, 3] &gt;&gt;&gt; b [1, 2, 3] &gt;&gt;&gt; c [1, 2, 3] &gt;&gt;&gt; d [1, 2, 3] 元组：Tuple元组也是由任意类型元素组成的序列。与列表不同的是，元组是不可变的，这意味着一旦元组被定义，将无法再进行增加、删除或修改元素等操作。因此，元组就像是一个常量列表。 创建元组：使用()可以用 () 创建一个空元组： &gt;&gt;&gt; empty_tuple = () &gt;&gt;&gt; empty_tuple () 创建包含一个或多个元素的元组时，每一个元素后面都需要跟着一个逗号，即使只包含一个元素也不能省略： &gt;&gt;&gt; one_marx = 'Groucho', &gt;&gt;&gt; one_marx ('Groucho',) 如果创建的元组所包含的元素数量超过1，最后一个元素后面的逗号可以省略： &gt;&gt;&gt; marx_tuple = 'Groucho', 'Chico', 'Harpo' &gt;&gt;&gt; marx_tuple ('Groucho', 'Chico', 'Harpo') Python的交互式解释器输出元组时会自动添加一对圆括号。你并不需要这么做——定义元组真正靠的是每个元素的后缀逗号——但如果你习惯添加一对括号也无可厚非。可以用括号将所有元素包裹起来，这会使得程序更加清晰： &gt;&gt;&gt; marx_tuple = ('Groucho', 'Chico', 'Harpo') &gt;&gt;&gt; marx_tuple ('Groucho', 'Chico', 'Harpo') 可以一口气将元组赋值给多个变量：(有时这个过程被称为元组解包。) &gt;&gt;&gt; marx_tuple = ('Groucho', 'Chico', 'Harpo') &gt;&gt;&gt; a, b, c = marx_tuple &gt;&gt;&gt; a 'Groucho' &gt;&gt;&gt; b 'Chico' &gt;&gt;&gt; c 'Harpo' 可以利用元组在一条语句中对多个变量的值进行交换，而不需要借助临时变量： &gt;&gt;&gt; password = 'swordfish' &gt;&gt;&gt; icecream = 'tuttifrutti' &gt;&gt;&gt; password, icecream = icecream, password &gt;&gt;&gt; password 'tuttifrutti' &gt;&gt;&gt; icecream 'swordfish' tuple() 函数可以用其他类型的数据来创建元组： &gt;&gt;&gt; marx_list = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; tuple(marx_list) ('Groucho', 'Chico', 'Harpo') 元组与列表在许多地方都可以用元组代替列表，但元组的方法函数与列表相比要少一些——元组没有append()、insert()，等等——因为一旦创建元组便无法修改。既然列表更加灵活，那为什么不在所有地方都使用列表呢？原因如下所示： 元组占用的空间较小 你不会意外修改元组的值 可以将元组用作字典的键 - 命名元组可以作为对象的替代 函数的参数是以元组形式传递的 字典: dict字典（dictionary）与列表类似，但其中元素的顺序无关紧要，因为它们不是通过像0或1的偏移量访问的。取而代之，每个元素拥有与之对应的互不相同的键（key），需要通过键来访问元素。键通常是字符串，但它还可以是Python中其他任意的不可变类型：布尔型、 整型、浮点型、元组、字符串，以及其他一些在后面的内容中会见到的类型。字典是可变的，因此你可以增加、删除或修改其中的键值对。 创建字典:使用{}用大括号（{}）将一系列以逗号隔开的键值对（key:value）包裹起来即可进行字典的创建。最简单的字典是空字典，它不包含任何键值对： &gt;&gt;&gt; empty_dict = &#123;&#125; &gt;&gt;&gt; empty_dict &#123;&#125;&gt;&gt;&gt; pizza = &#123; "size":"medium", "type":"pepperoni", "crust":"Thick", "qty": 1, "deliver":True,&#125;&#123;'size': 'medium', 'type': 'pepperoni', 'crust': 'Thick', 'qty': 1, 'deliver': True&#125; Python 允许在列表、元组或字典的最后一个元素后面添加逗号，这不会产生任何问题。此外，在括号之间输入键值对来创建字典时并不强制缩进。 转换为字典：使用dict()可以用 dict() 将包含双值子序列的序列转换成字典。每个子序列 的第一个元素作为键，第二个元素作为值。 &gt;&gt;&gt; lot = [ ('a', 'b'), ('c', 'd'), ('e', 'f') ] &gt;&gt;&gt; dict(lot) &#123;'c': 'd', 'a': 'b', 'e': 'f'&#125;&gt;&gt;&gt; los = [ 'ab', 'cd', 'ef' ] &gt;&gt;&gt; dict(los) &#123;'c': 'd', 'a': 'b', 'e': 'f'&#125; 添加或修改元素:使用[key]向字典中添加元素非常简单，只需指定该元素的键并赋予相应的值即可。如果该元素的键已经存在于字典中，那么该键对应的旧值会被新值取代。如果该元素的键并未在字典中出现，则会被加入字典。与列表不同，你不需要担心赋值过程中Python 会抛出越界异常。 &gt;&gt;&gt; pythons = &#123; 'Chapman': 'Graham', 'Cleese': 'John', 'Idle': 'Eric', 'Jones': 'Terry', 'Palin': 'Michael', &#125; &gt;&gt;&gt; pythons &#123;'Cleese': 'John','Jones': 'Terry', 'Palin': 'Michael','Chapman': 'Graham', 'Idle': 'Eric'&#125;# 新增 pythons['Gilliam'] = 'Gerry'&gt;&gt;&gt; pythons['Gilliam'] = 'Gerry' &gt;&gt;&gt; pythons &#123;'Cleese': 'John', 'Gilliam': 'Gerry', 'Palin': 'Michael', 'Chapman': 'Graham', 'Idle': 'Eric', 'Jones': 'Terry'&#125;# 修改pythons['Gilliam'] = 'Terry'&gt;&gt;&gt; pythons['Gilliam'] = 'Terry' &gt;&gt;&gt; pythons &#123;'Cleese': 'John', 'Gilliam': 'Terry', 'Palin': 'Michael', 'Chapman': 'Graham', 'Idle': 'Eric', 'Jones': 'Terry'&#125; 合并字典：使用update()如果待添加的字典与待扩充的字典包含同样的键，那么新归入字典的值会取代原有的值 &gt;&gt;&gt; first = &#123;'a': 1, 'b': 2&#125; &gt;&gt;&gt; second = &#123;'b': 'platypus'&#125; &gt;&gt;&gt; first.update(second) &gt;&gt;&gt; first &#123;'b': 'platypus', 'a': 1&#125; 删除具有指定键的元素:使用del&gt;&gt;&gt; first = &#123;'a': 1, 'b': 2&#125; &gt;&gt;&gt; del first['a']&gt;&gt;&gt; first&#123;'b': 2&#125; 删除所有元素:使用clear()使用clear()，或者给字典变量重新赋值一个空字典（{}）可以将字典中所有元素删除： &gt;&gt;&gt; pythons.clear() &gt;&gt;&gt; pythons &#123;&#125; &gt;&gt;&gt; pythons = &#123;&#125; &gt;&gt;&gt; pythons&#123;&#125; 使用in判断是否存在如果你希望判断某一个键是否存在于一个字典中，可以使用in。 &gt;&gt;&gt; pythons = &#123;'Chapman': 'Graham', 'Cleese': 'John', 'Jones': 'Terry', 'Palin': 'Michael'&#125;&gt;&gt;&gt; 'Chapman' in pythons True &gt;&gt;&gt; 'Palin' in pythons True 使用[key]获取元素这是对字典最常进行的操作，只需指定字典名和键即可获得对应的值： &gt;&gt;&gt; pythons['Cleese'] 'John' 如果字典中不包含指定的键，会产生一个异常。有两种方法可以避免这种情况的发生。第一种是在访问前通过in测试键是否存在，另一种方法是使用字典函数get()。你需要指定字典名，键以及一个可选值。如果键存在，会得到与之对应的值反之，若键不存在，如果你指定了可选值，那么get()函数将返回这个可选值,否则，会得到None（在交互式解释器中什么也不会显示）： &gt;&gt;&gt; pythons.get('Cleese') 'John'&gt;&gt;&gt; pythons.get('Marx', 'Not a Python') 'Not a Python'&gt;&gt;&gt; pythons.get('Marx') &gt;&gt;&gt; 获取所有键:使用keys()使用keys()可以获得字典中的所有键。在接下来的几个例子中，我们将换一个示例： &gt;&gt;&gt; signals = &#123;'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'&#125; &gt;&gt;&gt; signals.keys() dict_keys(['green', 'red', 'yellow']) 在Python 2里，keys()会返回一个列表，而在Python 3中则会返回dict_keys()，它是键的迭代形式。这种返回形式对于大型的字典非常有用，因为它不需要时间和空间来创建返回的列表。有时你需要的可能就是一个完整的列表，但在Python 3中，你只能自己调用list()将dict_keys转换为列表类型。 获取所有值:使用values()使用 values()可以获取字典中的所有值： &gt;&gt;&gt; list( signals.values() ) ['go', 'smile for the camera', 'go faster'] 获取所有键值对:使用items()使用items()函数可以获取字典中所有的键值对： &gt;&gt;&gt; list( signals.items() ) [('green', 'go'), ('red', 'smile for the camera'), ('yellow', 'go faster')] 每一个键值对以元组的形式返回，例如(&#39;green&#39;,&#39;go&#39;)。 使用=赋值，使用copy()复制与列表一样，对字典内容进行的修改会反映到所有与之相关联的变量名上： &gt;&gt;&gt; signals = &#123;'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'&#125; &gt;&gt;&gt; save_signals = signals &gt;&gt;&gt; signals['blue'] = 'confuse everyone' &gt;&gt;&gt; save_signals&#123;'blue': 'confuse everyone', 'green': 'go', 'red': 'smile for the camera', 'yellow': 'go faster'&#125; 若想避免这种情况，可以使用copy(),将字典复制到一个新的字典中： &gt;&gt;&gt; signals = &#123;'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'&#125; &gt;&gt;&gt; original_signals = signals.copy() &gt;&gt;&gt; signals['blue'] = 'confuse everyone' &gt;&gt;&gt; signals &#123;'blue': 'confuse everyone', 'green': 'go', 'red': 'smile for the camera', 'yellow': 'go faster'&#125; &gt;&gt;&gt; original_signals &#123;'green': 'go', 'red': 'smile for the camera', 'yellow': 'go faster'&#125; 集合：set集合就像舍弃了值，仅剩下键的字典一样。键与键之间也不允许重复。如果你仅仅想知道某一个元素是否存在而不关心其他的，使用集合是个非常好的选择。 创建集合:使用set()与字典的键一样，集合是无序的。 &gt;&gt;&gt; empty_set = set() &gt;&gt;&gt; empty_set set() &gt;&gt;&gt; even_numbers = &#123;0, 2, 4, 6, 8&#125; &gt;&gt;&gt; even_numbers &#123;0, 8, 2, 4, 6&#125; &gt;&gt;&gt; odd_numbers = &#123;1, 3, 5, 7, 9&#125; &gt;&gt;&gt; odd_numbers &#123;9, 3, 1, 5, 7&#125; 将其他类型转换为集合:使用set()利用已有列表、字符串、元组或字典的内容来创建集合，其中重复的值会被丢弃。 &gt;&gt;&gt; set( 'letters' )&#123;'l', 'e', 't', 'r', 's'&#125;&gt;&gt;&gt; set( ('Ummagumma', 'Echoes', 'Atom Heart Mother') ) &#123;'Ummagumma', 'Atom Heart Mother', 'Echoes'&#125; 测试值是否存在:使用in&gt;&gt;&gt; martini = &#123;'vodka', 'vermouth'&#125;&gt;&gt;&gt; 'vodka' in martiniTrue 合并及运算符交集：通过使用特殊标点符号&amp;或者集合函数intersection() 获取集合的交集（两集合共有元素） &gt;&gt;&gt; a = &#123;1, 2&#125; &gt;&gt;&gt; b = &#123;2, 3&#125;&gt;&gt;&gt; a &amp; b &#123;2&#125; &gt;&gt;&gt; a.intersection(b) &#123;2&#125; 并集：使用 |或者union()函数来获取集合的并集（至少出现在一个集合中的元素）： &gt;&gt;&gt; a = &#123;1, 2&#125; &gt;&gt;&gt; b = &#123;2, 3&#125;&gt;&gt;&gt; a | b &#123;1, 2, 3&#125; &gt;&gt;&gt; a.union(b) &#123;1, 2, 3&#125; 差集：使用字符-或者difference()可以获得两个集合的差集（出现在第一个集合但不出现在第二个集合）： &gt;&gt;&gt; a - b &#123;1&#125; &gt;&gt;&gt; a.difference(b) &#123;1&#125; 异或集:使用^或者symmetric_difference()可以获得两个集合的异或集（仅在两个集合中出现一次）： &gt;&gt;&gt; a ^ b &#123;1, 3&#125; &gt;&gt;&gt; a.symmetric_difference(b) &#123;1, 3&#125; 子集：使用&lt;=或者issubset()可以判断一个集合是否是另一个集合的子集（第一个集合的所有元素都出现在第二个集合中）： &gt;&gt;&gt; a &lt;= b False &gt;&gt;&gt; a.issubset(b) False 真子集:当第二个集合包含所有第一个集合的元素，且仍包含其他元素时，我们称第一个集合为第二个集合的真子集。使用&lt;可以进行判断： &gt;&gt;&gt; a &lt; b False &gt;&gt;&gt; a &lt; a False 超集：超集与子集正好相反（第二个集合的所有元素都出现在第一个集合中），使用 &gt;=或者 issuperset() 可以进行判断： &gt;&gt;&gt; a &gt;= b False &gt;&gt;&gt; a.issuperset(b) False 一个集合是它本身的超集： &gt;&gt;&gt; a &gt;= a True &gt;&gt;&gt; a.issuperset(a) True 真超集:使用&gt;可以找到一个集合的真超集（第一个集合包含第二个集合的所有元素且还包含其他元素）： &gt;&gt;&gt; a &gt; b False]]></content>
      <categories>
        <category>计算机</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机：语言</tag>
      </tags>
  </entry>
</search>
