<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python学习：Python基础（下）]]></title>
    <url>%2F2019%2F08%2F06%2FPython%E5%AD%A6%E4%B9%A0%EF%BC%9APython%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本章将介绍如何组织代码和数据。Python语言是通过代码缩进来区分代码块结构。 #注释与\链接注释是程序中会被Python解释器忽略的一段文本。通过使用注释，可以解释和明确Python代码的功能，记录将来要修改的地方，甚至写下你想写的任何东西。在Python中使用#字符标记注释，从#开始到当前行结束的部分都是注释。 注释#12345&gt;&gt;&gt; # 尽管Python不会喜欢，但是我可以在这里讲任何东西 ... # 因为我被“保护”... # 令人敬畏的#号 ... &gt;&gt;&gt; 程序在合理的长度下是易读的。一行程序的（非强制性）最大长度建议为80个字符。如果你在该长度下写不完你的代码，可以使用连接符\（反斜线）。把它放在一行的结束位置，Python仍然将其解释为同一行。 链接\ 1&gt;&gt;&gt; alphabet = 'abcdefg' + \ ... 'hijklmnop' + \ ... 'qrstuv' + \ ... 'wxyz' Python的条件语句Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。Python程序语言指定任何非0和非空值为true，0或者 其他空值为false。Python编程中if语句用于控制程序的执行，基本形式为： if使用1234if 判断条件： 执行语句……else： 执行语句…… 其中”判断条件”成立时，则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。else为可选语句，当需要在条件不成立时执行内容则可以执行相关语句。 if 基本用法12345678 flag = Falsename = 'luren'if name == 'python': # 判断变量是否为 python flag = True # 条件成立时设置标志为真 print 'welcome boss' # 并输出欢迎信息else: print name # 条件不成立时输出变量名称 输出结果为： 1luren # 输出结果 当判断条件为多个值时，可以使用if、elif（即 else if）和 else: if`、`elif`（即 `else if`）和 `else`12345678if 判断条件1: 执行语句1……elif 判断条件2: 执行语句2……elif 判断条件3: 执行语句3……else: 执行语句4…… 实例： elif用法123456789101112 num = 5 if num == 3: # 判断num的值 print 'boss' elif num == 2: print 'user'elif num == 1: print 'worker'elif num &lt; 0: # 值小于零时输出 print 'error'else: print 'roadman' # 条件均不成立时输出 输出结果： 1roadman # 输出结果 Python 循环语句使用if、elif和else条件判断的例子是自顶向下执行的，但是有时候我们需要重复一些操作——循环 Python中循环类型循环类型 | 循环描述—|—while循环| 在给定的判断条件为 true 时执行循环体，否则退出循环体。for循环 |重复执行语句嵌套循环|可以在while循环、for循环中相互嵌套 循环控制语句循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句：控制语句 | 描述—|—break语句 | 在语句块执行过程中终止循环，并且跳出整个循环continue语句 | 在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。pass语句 |pass是空语句，是为了保持程序结构的完整性。 while循环Python编程中while语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为： while循环12while 判断条件： 执行语句…… 执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空的值均为true。当判断条件假false时，循环结束。 while实例123456count = 0while (count &lt; 9): print 'The count is:', count count = count + 1 print "Good bye!" 输出结果： 12345678910The count is: 0The count is: 1The count is: 2The count is: 3The count is: 4The count is: 5The count is: 6The count is: 7The count is: 8Good bye! 跳出循环while语句时还有另外两个重要的命令continue，break 来跳过循环，continue用于跳过该次循环，break则是用于退出循环。 continue 和 break 用法12345678910111213i = 1while 1: # 循环条件为1必定成立 print(i) # 输出1~10 i += 1 if i &gt; 10: # 当i大于10时跳出循环 break i = 1while i &lt; 10: i += 1 if i%2 &gt; 0: # 非双数时跳过输出 continue print(i) # 输出双数2、4、6、8、10 循环使用 else 语句如果while循环正常结束（没有使用break跳出），程序将进入到可选的else段。当你使用循环来遍历检查某一数据结构时，找到满足条件的解使用break跳出；循环结束，即没 有找到可行解时，将执行else部分代码段： while的else语句123456count = 0while count &lt; 5: print count, " is less than 5" count = count + 1else: print count, " is not less than 5" 输出结果： 1234560 is less than 51 is less than 52 is less than 53 is less than 54 is less than 55 is not less than 5 for迭代 Python频繁地使用迭代器。它允许在数据结构长度未知和具体实现未知的情况下遍历整个数据结构，并且支持迭代快速读写中的数据，以及允许不能一次读入计算机内存的数据流 的处理。 Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。 for迭代实例12345678for letter in 'Python': # 第一个实例 print '当前字母 :', letter fruits = ['banana', 'apple', 'mango']for fruit in fruits: # 第二个实例 print '当前水果 :', fruit print "Good bye!" 输出结果： 12345678910当前字母 : P当前字母 : y当前字母 : t当前字母 : h当前字母 : o当前字母 : n当前水果 : banana当前水果 : apple当前水果 : mangoGood bye! 跳出循环break和continue在for循环中跳出的用法和在while 循环中是一样的。continue用于跳过该次循环，break则是用于退出循环。 循环使用 else 语句类似于while，for循环也可以使用可选的else代码段，用来判断for循环是否正常结束（没有调用break跳出），否则会执行else段。 12345678&gt;&gt;&gt; cheeses = [] &gt;&gt;&gt; for cheese in cheeses: ... print('This shop has some lovely', cheese) ... break ... else: # 没有break表示没有找到奶酪 ... print('This is not much of a cheese shop, is it?') ...This is not much of a cheese shop, is it? 使用zip()并行迭代zip()函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。 语法：1zip([iterable, ...]) 参数说明： iterabl – 一个或多个迭代器; 返回值 返回一个对象。 实例 1234567891011121314151617&gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b) # 返回一个对象&gt;&gt;&gt; zipped&lt;zip object at 0x103abc288&gt;&gt;&gt;&gt; list(zipped) # list() 转换为列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; list(zip(a,c)) # 元素个数与最短的列表一致[(1, 4), (2, 5), (3, 6)] &gt;&gt;&gt; a1, a2 = zip(*zip(a,b)) #与zip相反，zip(*) 可理解为解压，返回二维矩阵式&gt;&gt;&gt; list(a1)[1, 2, 3]&gt;&gt;&gt; list(a2)[4, 5, 6]&gt;&gt;&gt; 使用range()生成自然数序列range()函数返回在特定区间的自然数序列，不需要创建和存储复杂的数据结构，例如列表或者元组。这允许在不使用计算机全部内存的情况下创建较大的区间，也不会使你的程序崩溃。 函数语法 12range(stop)range(start, stop[, step]) 参数说明： start:计数从start开始。默认是从0开始。例如range（5）等价于range（0， 5）; stop: 计数到stop结束，但不包括stop。例如：range（0， 5）是[0, 1, 2, 3, 4]没有5 step：步长，默认为1。例如：range（0， 5） 等价于range(0, 5, 1) 实例 12345678910&gt;&gt;&gt;list(range(0, 30, 5))[0, 5, 10, 15, 20, 25]&gt;&gt;&gt; list(range(0, 10, 2))[0, 2, 4, 6, 8]&gt;&gt;&gt; list(range(0, -10, -1))[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]&gt;&gt;&gt; list(range(1, 0))[]&gt;&gt;&gt;&gt;&gt;&gt; 推导式 推导式是从一个或者多个迭代器快速简洁地创建数据结构的一种方法。它可以将循环和条件判断结合，从而避免语法冗长的代码。 列表推导式最简单的形式如下所示：[ expression for item in iterable ]实例： 12&gt;&gt;&gt; number_list = [number for number in range(1,6)] &gt;&gt;&gt; number_list [1, 2, 3, 4, 5] 在第一行中，第一个number变量为列表生成值，也就是说，把循环的结果放在列表number_list中。第二个number为循环变量。其中第一个number可以为表达式: 12&gt;&gt;&gt; number_list = [number-1 for number in range(1,6)] &gt;&gt;&gt; number_list [0, 1, 2, 3, 4] 列表推导也可以像下面的例子加上条件表达式：[expression for item in iterable if condition] 123&gt;&gt;&gt; a_list = [number for number in range(1,6) if number % 2 == 1] &gt;&gt;&gt; a_list [1, 3, 5] 正如存在很多嵌套循环一样，在对应的推导中会有多个for语句,推导式也可以嵌套循环。 123456789101112&gt;&gt;&gt; rows = range(1,4) &gt;&gt;&gt; cols = range(1,3) &gt;&gt;&gt; cells = [(row, col) for row in rows for col in cols] &gt;&gt;&gt; for cell in cells: ... print(cell) ... (1, 1) (1, 2) (2, 1)(2, 2) (3, 1)(3, 2) 字典推导式与列表的推导式类似，其中最简单的例子就像：{ key_expression : value_expression for expression in iterable } 1234&gt;&gt;&gt; word = 'letters' &gt;&gt;&gt; letter_counts = &#123;letter: word.count(letter) for letter in set(word)&#125; &gt;&gt;&gt; letter_counts &#123;'t': 2, 'l': 1, 'e': 2, 'r': 1, 's': 1&#125; 集合推导式集合也不例外，同样有推导式。最简单的版本和之前的列表、字典推导类似：{expression for expression in iterable }最长的版本（if tests, multiple for clauses）对于集合而言也是可行的： 123&gt;&gt;&gt; a_set = &#123;number for number in range(1,6) if number % 3 == 1&#125; &gt;&gt;&gt; a_set &#123;1, 4&#125; 生成器推导式1&gt;&gt;&gt; number_thing = (number for number in range(1, 6)) 其实，圆括号之间的是生成器推导式，它返回的是一个生成器对象： 12&gt;&gt;&gt; type(number_thing) &lt;class 'generotor'&gt; 。一个生成器只能运行一次。列表、集合、字符串和字典都存储在内存中，但是生成器仅在运行中产生值，不会被存下来，所以不能重新使用或者备份一个生成器。如果想再一次迭代此生成器，会发现它被擦除了。生成器既可以通过生成器推导式创建生成器，也可以使用生成器的函数 123&gt;&gt;&gt; try_again = list(number_thing) &gt;&gt;&gt; try_again [] 函数 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。Python提供了许多内建函数，比如print()。但也可以自己创建函数，这被叫做用户自定义函数 定义一个函数可以定义一个由自己想要功能的函数，以下是简单的规则： 函数代码块以def关键词开头，后接函数标识符名称和圆括号 ()。 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式]结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 语法Python定义函数使用def关键字，一般格式如下： 12def 函数名（参数列表）: 函数体 默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。实例： 1234567891011# 计算面积函数def area(width, height): return width * height def print_welcome(name): print("Welcome", name) print_welcome("Runoob")w = 4h = 5print("width =", w, " height =", h, " area =", area(w, h)) 运行结果： 12Welcome Runoobwidth = 4 height = 5 area = 20 参数传递在python中，类型属于对象，变量是没有类型的： 123a=[1,2,3]a="Runoob" 以上代码中，[1,2,3] 是List类型，&quot;Runoob&quot;是String类型，而变量a是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。 可更改(mutable)与不可更改(immutable)对象在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。可变类型：变量赋值la=[1,2,3,4]后再赋值la[2]=5则是将list la的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python函数的参数传递：不可变类型：类似c++的值传递，如整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在fun（a）内部修改a的值，只是修改另一个复制的对象，不会影响a本身。 可变类型：类似c++的引用传递，如列表，字典。如fun（la），则是将la真正的传过去，修改后fun外部的la也会受影响。 python中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 python 传不可变对象实例 1234567 def ChangeInt( a ): a = 10 b = 2ChangeInt(b)print( b ) # 结果是 2 实例中有int对象2，指向它的变量是b，在传递给ChangeInt函数时，按传值的方式复制了变量b，a和b都指向了同一个Int对象，在a=10时，则新生成一个int值对象10，并让a指向它。 传可变对象实例可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如： 123456789101112 # 可写函数说明def changeme( mylist ): "修改传入的列表" mylist.append([1,2,3,4]) print ("函数内取值: ", mylist) return # 调用changeme函数mylist = [10,20,30]changeme( mylist )print ("函数外取值: ", mylist) 传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下： 12函数内取值: [10, 20, 30, [1, 2, 3, 4]]函数外取值: [10, 20, 30, [1, 2, 3, 4]] 参数以下是调用函数时可使用的正式参数类型： 必需参数 关键字参数 默认参数 不定长参数 必需参数必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 调用printme()函数，你必须传入一个参数，不然会出现语法错误： 123456789 #可写函数说明def printme( str ): "打印任何传入的字符串" print (str) return # 调用 printme 函数，不加参数会报错printme() 以上实例输出结果： 1234Traceback (most recent call last): File "test.py", line 10, in &lt;module&gt; printme()TypeError: printme() missing 1 required positional argument: 'str' 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为Python解释器能够用参数名匹配参数值。 以下实例在函数printme()调用时使用参数名： 123456789 #可写函数说明def printme( str ): "打印任何传入的字符串" print (str) return #调用printme函数printme( str = "cyy") 以上实例输出结果： 1cyy 以下实例中演示了函数参数的使用不需要使用指定顺序： 123456789#可写函数说明def printinfo( name, age ): "打印任何传入的字符串" print ("名字: ", name) print ("年龄: ", age) return #调用printinfo函数printinfo( age=50, name="runoob" ) 以上实例输出结果： 12名字: runoob年龄: 50 默认参数调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入age参数，则使用默认值： 123456789101112 #可写函数说明def printinfo( name, age = 35 ): "打印任何传入的字符串" print ("名字: ", name) print ("年龄: ", age) return #调用printinfo函数printinfo( age=50, name="runoob" )print ("------------------------")printinfo( name="runoob" ) 以上实例输出结果： 12345名字: runoob年龄: 50------------------------名字: runoob年龄: 35 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下： 1234def functionname([formal_args,] *var_args_tuple ): "函数_文档字符串" function_suite return [expression] 加了星号*的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。 12345678910 # 可写函数说明def printinfo( arg1, *vartuple ): "打印任何传入的参数" print ("输出: ") print (arg1) print (vartuple) # 调用printinfo 函数printinfo( 70, 60, 50 ) 以上实例输出结果： 123输出: 70(60, 50) 如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例： 123456789101112# 可写函数说明def printinfo( arg1, *vartuple ): "打印任何传入的参数" print ("输出: ") print (arg1) for var in vartuple: print (var) return # 调用printinfo 函数printinfo( 10 )printinfo( 70, 60, 50 ) 以上实例输出结果： 123456输出:10输出:706050 还有一种就是参数带两个星号**基本语法如下： 1234def functionname([formal_args,] **var_args_dict ): "函数_文档字符串" function_suite return [expression] 加了两个星号 **的参数会以字典的形式导入。 12345678910 # 可写函数说明def printinfo( arg1, **vardict ): "打印任何传入的参数" print ("输出: ") print (arg1) print (vardict) # 调用printinfo 函数printinfo(1, a=2,b=3) 以上实例输出结果： 123输出: 1&#123;'a': 2, 'b': 3&#125; 声明函数时，参数中星号* 可以单独出现，例如: 12def f(a,b,*,c): return a+b+c 如果单独出现星号*后的参数必须用关键字传入。 12345678910&gt;&gt;&gt; def f(a,b,*,c):... return a+b+c... &gt;&gt;&gt; f(1,2,3) # 报错Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: f() takes 2 positional arguments but 3 were given&gt;&gt;&gt; f(1,2,c=3) # 正常6&gt;&gt;&gt; 文档字符串程序的可读性很重要。建议在函数体开始的部分附上函数定义说明的文档，这就是函数的文档字符串： 123&gt;&gt;&gt; def echo(anything): ... 'echo returns its input argument' ... return anything 可以定义非常长的文档字符串，加上详细的规范说明，如下所示： 123456789def print_if_true(thing, check): ''' Prints the first argument if a second argument is true. The operation is: 1. Check whether the *second* argument is true. 2. If it is, print the *first* argument. ''' if check: print(thing) 调用Python函数help()可以打印输出一个函数的文档字符串。把函数名传入函数help()就会得到参数列表和规范的文档： 1234&gt;&gt;&gt; help(echo) Help on function echo in module __main__: echo(anything) echo returns its input argument 如果仅仅想得到文档字符串： 12&gt;&gt;&gt; print(echo.__doc__) echo returns its input argument 内部函数在Python中，可以在函数中定义另外一个函数： 12345678&gt;&gt;&gt; def outer(a, b): ... def inner(c, d): ... return c + d ... return inner(a, b) ... &gt;&gt;&gt; &gt;&gt;&gt; outer(4, 7) 11 当需要在函数内部多次执行复杂的任务时，内部函数是非常有用的，从而避免了循环和代码的堆叠重复。 闭包内部函数可以看作一个闭包。闭包是一个可以由另一个函数动态生成的函数，并且可以改变和存储函数外创建的变量的值。以下面的例子knights()为基础。现在，调用新的函数knight2()，把inner()函数变成一个叫inner2()的闭包。可以看出有以下不同点。 inner2()直接使用外部的saying参数，而不是通过另外一个参数获取。 knights2()返回值为inner2函数，而不是调用它。12345678910111213&gt;&gt;&gt; def knights(saying): ... def inner(quote): ... return "We are the knights who say: '%s'" % quote ... return inner(saying) ... &gt;&gt;&gt; knights('Ni!') "We are the knights who say: 'Ni!'"&gt;&gt;&gt; def knights2(saying): ... def inner2(): ... return "We are the knights who say: '%s'" % saying ... return inner2 ... inner2()函数可以得到saying参数的值并且记录下来。return inner2这一行返回的是inner2函数的复制（没有直接调用）。所以它就是一个闭包：一个被动态创建的可以记录 外部变量的函数。用不同的参数调用knights2()两次： 12&gt;&gt;&gt; a = knights2('Duck') &gt;&gt;&gt; b = knights2('Hasenpfeffer') 那么a和b会是什么类型？ 1234&gt;&gt;&gt; type(a) &lt;class 'function'&gt; &gt;&gt;&gt; type(b) &lt;class 'function'&gt; 它们是函数，同时也是闭包： 1234&gt;&gt;&gt; a &lt;function knights2.&lt;locals&gt;.inner2 at 0x10193e158&gt; &gt;&gt;&gt; b &lt;function knights2.&lt;locals&gt;.inner2 at 0x10193e1e0&gt; 如果调用它们，它们会记录被knights2函数创建时的外部变量saying： 1234&gt;&gt;&gt; a() "We are the knights who say: 'Duck'" &gt;&gt;&gt; b() "We are the knights who say: 'Hasenpfeffer'" 匿名函数：lambda()函数Python中，lambda函数是用一个语句表达的匿名函数。可以用它来代替小的函数。首先，举一个使用普通函数的例子。定义函数edit_story()，参数列表如下所示： words——单词列表 func——遍历列表中单词的函数123&gt;&gt;&gt; def edit_story(words, func): ... for word in words: ... print(func(word)) 现在，需要一个单词列表和一个遍历单词的函数。对于单词，可以选择我的猫从某一台阶上掉下时发出的声音： 1&gt;&gt;&gt; stairs = ['thud', 'meow', 'thud', 'hiss'] 对于函数，它要将每个单词的首字母变为大写，然后在末尾加上感叹号 , 用作猫画报的标题非常完美： 123&gt;&gt;&gt; def enliven(word): # 让这些单词更有情感 ... return word.capitalize() + '!' 混合这些“配料”： 12345&gt;&gt;&gt; edit_story(stairs, enliven) Thud! Meow! Thud! Hiss! 最后，到了lambda。enliven() 函数可以简洁地用下面的一个lambda代替： 1234567&gt;&gt;&gt; &gt;&gt;&gt; edit_story(stairs, lambda word: word.capitalize() + '!') Thud! Meow! Thud! Hiss! &gt;&gt;&gt; lambda函数接收一个参数word。在冒号和末尾圆括号之间的部分为函数的定义。通常，使用实际的函数（例如enliven()）会比使用lambda更清晰明了。但是，当需要定义很多小的函数以及记住它们的名字时，lambda会非常有用。尤其是在图形用户界面中，可以使用lambda来定义回调函数。 生成器生成器是用来创建Python序列的一个对象。使用它可以迭代庞大的序列，且不需要在内存中创建和存储整个序列。通常，生成器是为迭代器产生数据的。回想起来，我们已经在之前的例子中使用过其中一个，即range()，来产生一系列整数。range()在 Python 2中返回一个列表，这也限制了它要进入内存空间。Python 2中同样存在的生成器xrange()在 Python 3中成为标准的range()生成器。这个例子累加从 1 到 100 的整数： 12&gt;&gt;&gt; sum(range(1, 101)) 5050 每次迭代生成器时，它会记录上一次调用的位置，并且返回下一个值。这一点和普通的函数是不一样的，一般函数都不记录前一次调用，而且都会在函数的第一行开始执行。如果你想创建一个比较大的序列，使用生成器推导的代码会很长，这时可以尝试写一个生成器函数。生成器函数和普通函数类似，但是它的返回值使用 yield语句声明而不是return。下面编写我们自己的range()函数版本： 12345&gt;&gt;&gt; def my_range(first=0, last=10, step=1): ... number = first ... while number &lt; last: ... yield number ... number += step ... 这是一个普通的函数： 12&gt;&gt;&gt; my_range &lt;function my_range at 0x10193e268&gt; 并且它返回的是一个生成器对象： 123&gt;&gt;&gt; ranger = my_range(1, 5) &gt;&gt;&gt; ranger &lt;generator object my_range at 0x101a0a168&gt; 可以对这个生成器对象进行迭代： 1234567&gt;&gt;&gt; for x in ranger:... print(x) ... 1 2 34 装饰器有时你需要在不改变源代码的情况下修改已经存在的函数。常见的例子是增加一句调试声明，以查看传入的参数。装饰器实质上是一个函数。它把一个函数作为输入并且返回另外一个函数。在装饰器中，通常使用下面这些Python技巧： args 和 *kwargs 闭包 作为参数的函数 函数document_it()定义了一个装饰器，会实现如下功能： 打印输出函数的名字和参数的值 执行含有参数的函数 打印输出结果 返回修改后的函数 看下面的代码： 123456789&gt;&gt;&gt; def document_it(func): ... def new_function(*args, **kwargs): ... print('Running function:', func.__name__) ... print('Positional arguments:', args) ... print('Keyword arguments:', kwargs) ... result = func(*args, **kwargs) ... print('Result:', result) ... return result ... return new_function 无论传入document_it()的函数func是什么，装饰器都会返回一个新的函数，其中包含函数document_it() 增加的额外语句。实际上，装饰器并不需要执行函数func中的代码，只是在结束前函数document_it()调用函数func以便得到func的返回结果和附加代码的结果。 那么，如何使用装饰器？当然，可以通过人工赋值： 123456789101112&gt;&gt;&gt; def add_ints(a, b): ... return a + b ... &gt;&gt;&gt; add_ints(3, 5) 8 &gt;&gt;&gt; cooler_add_ints = document_it(add_ints) # 人工对装饰器赋值 &gt;&gt;&gt; cooler_add_ints(3, 5) Running function: add_ints Postitional arguments: （3， 5）Keyword arguments: &#123;&#125; Result: 8 8 作为对前面人工装饰器赋值的替代，可以直接在要装饰的函数前添加装饰器名字@decorator_name： 123456789&gt;&gt;&gt; @document_it ... def add_ints(a, b): ... return a + b ... &gt;&gt;&gt; add_ints(3, 5) Start function add_ints Positional arguments: (3, 5) Keyword arguments: &#123;&#125; Result: 8 8 同样一个函数可以有多个装饰器。下面，我们写一个对结果求平方的装饰器square_it()： 123456&gt;&gt;&gt; def square_it(func): ... def new_function(*args, **kwargs): ... result = func(*args, **kwargs) ... return result * result ... return new_function ... 靠近函数定义（def上面）的装饰器最先执行，然后依次执行上面的。任何顺序都会得到相同的最终结果。下面的例子中会看到中间步骤的变化： 1234567891011&gt;&gt;&gt; @document_it ... @square_it ... def add_ints(a, b): ... return a + b ... &gt;&gt;&gt; add_ints(3, 5) Running function: new_function Positional arguments: (3, 5) Keyword arguments: &#123;&#125; Result: 64 64 交换两个装饰器的顺序： 1234567891011&gt;&gt;&gt; @square_it ... @document_it ... def add_ints(a, b): ... return a + b ... &gt;&gt;&gt; add_ints(3, 5) Running function: add_ints Positional arguments: (3, 5) Keyword arguments: &#123;&#125; Result: 8 64 命名空间和作用域一个名称在不同的使用情况下可能指代不同的事物。Python程序有各种各样的命名空间，它指的是在该程序段内一个特定的名称是独一无二的，它和其他同名的命名空间是无关的。 每一个函数定义自己的命名空间。如果在主程序（main）中定义一个变量x，在另外一个函数中也定义 x 变量，两者指代的是不同的变量。但是，天下也没有完全绝对的事情，需要的话，可以通过多种方式获取其他命名空间的名称。 每个程序的主要部分定义了全局命名空间。因此，在这个命名空间的变量是全局变量。 你可以在一个函数内得到某个全局变量的值： 1234567&gt;&gt;&gt; animal = 'fruitbat' &gt;&gt;&gt; def print_global(): ... print('inside print_global:', animal) ... &gt;&gt;&gt; print('at the top level:', animal) at the top level: fruitbat &gt;&gt;&gt; print_global() inside print_global: fruitbat 但是，如果想在函数中得到一个全局变量的值并且改变它，会报错： 1234567&gt;&gt;&gt; def change_and_print_global(): ... print('inside change_and_print_global:', animal) ... animal = 'wombat' ... print('after the change:', animal) ... &gt;&gt;&gt; change_and_print_global() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in change_and_report_it UnboundLocalError: local variable 'animal' referenced before assignment 实际上，你改变的另外一个同样被命名为animal 的变量，只不过这个变量在函数内部： 12345678910&gt;&gt;&gt; def change_local(): ... animal = 'wombat' ... print('inside change_local:', animal, id(animal)) ... &gt;&gt;&gt; change_local() inside change_local: wombat 4330406160 &gt;&gt;&gt; animal 'fruitbat' &gt;&gt;&gt; id(animal) 4330390832 这里发生了什么？在函数第一行将字符串fruitbat 赋值给全局变量animal。函数change_ local() 也有一个叫作animal的变量。不同的是，它在自己的局部命名空间。 我们使用Python内嵌函数id()打印输出每个对象的唯一的 ID 值，证明在函数change_ local() 中的变量animal和主程序中的animal不是同一个。 为了读取全局变量而不是函数中的局部变量，需要在变量前面显式地加关键字global）： 123456789101112&gt;&gt;&gt; animal = 'fruitbat' &gt;&gt;&gt; def change_and_print_global(): ... global animal ... animal = 'wombat' ... print('inside change_and_print_global:', animal) ... &gt;&gt;&gt; animal 'fruitbat' &gt;&gt;&gt; change_and_print_global() inside change_and_print_global: wombat &gt;&gt;&gt; animal 'wombat' 如果在函数中不声明关键字global，Python会使用局部命名空间，同时变量也是局部的。函数执行后回到原来的命名空间。Python提供了两个获取命名空间内容的函数： locals()返回一个局部命名空间内容的字典； globals()返回一个全局命名空间内容的字典。下面是它们的实例：12345678910111213141516&gt;&gt;&gt; animal = 'fruitbat' &gt;&gt;&gt; def change_local(): ... animal = 'wombat' #局部变量 ... print('locals:',locals()) ... &gt;&gt;&gt; animal 'fruitbat' &gt;&gt;&gt; change_local() locals: &#123;'animal':'wombat'&#125; &gt;&gt;&gt; print('globals:', globals()) #表示时格式稍微发生变化 globals:&#123;'animal': 'fruitbat', '__doc__': None, 'change_local': &lt;function change_it at 0x1006c0170&gt;, '__package__': None, '__name__': '__main__', '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__builtins__': &lt;module 'builtins'&gt;&#125; &gt;&gt;&gt; animal 'fruitbat' 函数change_local()的局部命名空间只含有局部变量animal。全局命名空间含有全局变量animal 以及其他一些东西。 名称中_和__的用法以两个下划线__开头和结束的名称都是Python的保留用法。因此，在自定义的变量中不能使用它们。选择这种命名模式是考虑到开发者一般是不会选择它们作为自己的变量的。 例如，一个函数的名称是系统变量function.__name__，它的文档字符串是function.__ doc__： 12345678&gt;&gt;&gt; def amazing(): ... '''This is the amazing function. ... Want to see it again?''' ... print('This function is named:', amazing.__name__) ... print('And its docstring is:', amazing.__doc__) ... &gt;&gt;&gt; amazing() This function is named: amazing And its docstring is: This is the amazing function. Want to see it again? 如同之前globals的输出结果所示，主程序被赋值特殊的名字__main__。 使用try和except处理错误在一些编程语言中，错误是通过特殊的函数返回值指出的，而Python使用异常，它是一段只有错误发生时执行的代码。 之前已经接触到一些有关错误的例子，例如读取列表或者元组的越界位置或者字典中不存在的键。所以，当你执行可能出错的代码时，需要适当的异常处理程序用于阻止潜在的错误发生。 在异常可能发生的地方添加异常处理程序，对于用户明确错误是一种好方法。即使不会及时解决问题，至少会记录运行环境并且停止程序执行。如果发生在某些函数中的异常不能被立刻捕捉，它会持续，直到被某个调用函数的异常处理程序所捕捉。在你不能提供自己的异常捕获代码时，Python会输出错误消息和关于错误发生处的信息，然后终止程序，例如下面的代码段： 12345&gt;&gt;&gt; short_list = [1, 2, 3] &gt;&gt;&gt; position = 5 &gt;&gt;&gt; short_list[position] Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt; IndexError: list index out of range 与其让错误随机产生，不如使用try和except提供错误处理程序： 123456789&gt;&gt;&gt; short_list = [1, 2, 3] &gt;&gt;&gt; position = 5 &gt;&gt;&gt; try: ... short_list[position] ... except: ... print('Need a position between 0 and', len(short_list)-1, ' but got', ... position) ... Need a position between 0 and 2 but got 5 在try中的代码块会被执行。如果存在错误，就会抛出异常，然后执行except中的代码；否则，跳过except块代码。像前面那样指定一个无参数的 except适用于任何异常类型。如果可能发生多种类型的异常，最好是分开进行异常处理。当然，没人强迫你这么做，你可以使一个except去捕捉所 有的异常，但是这样的处理方式会比较泛化（类似于直接输出发生了一个错误）。当然也可以使用任意数量的异常处理程序。 有时需要除了异常类型以外其他的异常细节，可以使用下面的格式获取整个异常对象：except exceptiontype as name 下面的例子首先会寻找是否有IndexError，因为它是由索引一个序列的非法位置抛出的异常类型。将一个IndexError异常赋给变量err，把其他的异常赋给变量other。示例中会输出所有存储在other中的该对象的异常。 12345678910111213141516171819202122232425&gt;&gt;&gt; short_list = [1, 2, 3] &gt;&gt;&gt; while True: ... value = input('Position [q to quit]? ') ... if value == 'q': ... break ... try: ... position = int(value) ... print(short_list[position]) ... except IndexError as err: ... print('Bad index:', position) ... except Exception as other: ... print('Something else broke:', other) ... Position [q to quit]? 1 2 Position [q to quit]? 0 1 Position [q to quit]? 2 3 Position [q to quit]? 3 Bad index: 3 Position [q to quit]? 2 3 Position [q to quit]? twoSomething else broke: invalid literal for int() with base 10: 'two' Position [q to quit]? q 输入 3 会抛出异常IndexError；输入two会使函数int()抛出异常，被第二个except所捕获。 编写自己的异常前面一节讨论了异常处理，但是其中讲到的所有异常（例如IndexError）都是在Python或者它的标准库中提前定义好的。根据自己的目的可以使用任意的异常类型，同时也可以自己定义异常类型,用来处理程序中可能会出现的特殊情况。 这里需要定义一个类的新对象。一个异常是一个类，即类Exception的一个子类。现在编写异常UppercaseException，在一个字符串中碰到大写字母会被抛出。 123456789&gt;&gt;&gt; class UppercaseException(Exception): ... pass ... &gt;&gt;&gt; words = ['eeenie', 'meenie', 'miny', 'MO'] &gt;&gt;&gt; for word in words: ... if word.isupper(): ... raise UppercaseException(word) ... Traceback (most recent call last): File "&lt;stdin&gt;", line 3, in &lt;module&gt; __main__.UppercaseException: MO 即使没有定义UppercaseException的行为（注意到只使用pass），也可以通过继承其父类Exception在抛出异常时输出错误提示。 你当然能够访问异常对象本身，并且输出它： 123456&gt;&gt;&gt; try: ... raise OopsException('panic') ... except OopsException as exc: ... print(exc) ... panic]]></content>
      <categories>
        <category>计算机</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机：语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作：天目云网站采集点增删改操作后的数据复查]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%B7%A5%E4%BD%9C%EF%BC%9A%E5%A4%A9%E7%9B%AE%E4%BA%91%E7%BD%91%E7%AB%99%E9%87%87%E9%9B%86%E7%82%B9%E5%A2%9E%E5%88%A0%E6%94%B9%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%8D%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[请输入密码以阅读这篇私密文章。 Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mermaid]]></title>
    <url>%2F2019%2F08%2F05%2FMermaid%2F</url>
    <content type="text"><![CDATA[Mermaid Mermaid是一款开源的画流程图、甘特图、时序图工具，她提供了一种类似markdown的语法来创建各种图。 官网：Mermaid 基本用法：Mermaid基本语法 在线编辑器：在线编辑器 NexT-Mermaid设置next/_config.yml123456789# Mermaid tagmermaid: enable: true # Available themes: default | dark | forest | neutral theme: forest # Use 8.0.0 as default, jsdelivr as default CDN, works everywhere even in China cdn: //cdn.jsdelivr.net/npm/mermaid@8.0.0/dist/mermaid.min.js # CDNJS, provided by cloudflare, maybe the best CDN, but not works in China #cdn: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js 使用mermaid.js1234&#123;% mermaid type %&#125;&#123;% endmermaid %&#125;type : mermaid chart的类型 实例流程图 书写 123456&#123;% mermaid graph TD %&#125;A--&gt;B;A--&gt;C;B--&gt;D;C--&gt;D;&#123;% endmermaid %&#125; 显示： graph TD A-->B; A-->C; B-->D; C-->D; 时序图 书写 1234567891011121314151617181920212223&#123;% mermaid sequenceDiagram %&#125;participant Aliceparticipant Bobparticipant John as John&lt;br/&gt;Second LineAlice -&gt;&gt; Bob: Hello Bob, how are you?Bob--&gt;&gt;John: How about you John?Bob--x Alice: I am good thanks!Bob-x John: I am good thanks!Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row.Bob--&gt;Alice: Checking with John...alt either thisAlice-&gt;&gt;John: Yeselse or thisAlice-&gt;&gt;John: Noelse or this will happenAlice-&gt;John: Maybeendpar this happens in parallelAlice --&gt;&gt; Bob: Parallel message 1andAlice --&gt;&gt; John: Parallel message 2end&#123;% endmermaid %&#125; 显示 sequenceDiagram participant Alice participant Bob participant John as JohnSecond Line Alice ->> Bob: Hello Bob, how are you? Bob-->>John: How about you John? Bob--x Alice: I am good thanks! Bob-x John: I am good thanks! Note right of John: Bob thinks a longlong time, so longthat the text doesnot fit on a row. Bob-->Alice: Checking with John... alt either this Alice->>John: Yes else or this Alice->>John: No else or this will happen Alice->John: Maybe end par this happens in parallel Alice -->> Bob: Parallel message 1 and Alice -->> John: Parallel message 2 end 甘特图 书写 1234567891011121314151617181920212223242526272829&#123;% mermaid gantt %&#125;dateFormat YYYY-MM-DDaxisFormat %d/%mtitle Adding GANTT diagram to mermaidsection A sectionCompleted task :done, des1, 2014-01-06,2014-01-08Active task :active, des2, 2014-01-09, 3dFuture task : des3, after des2, 5dFuture task2 : des4, after des3, 5dsection Critical tasksCompleted task in the critical line :crit, done, 2014-01-06,24hImplement parser and jison :crit, done, after des1, 2dCreate tests for parser :crit, active, 3dFuture task in critical line :crit, 5dCreate tests for renderer :2dAdd to mermaid :1dsection DocumentationDescribe gantt syntax :active, a1, after des1, 3dAdd gantt diagram to demo page :after a1 , 20hAdd another diagram to demo page :doc1, after a1 , 48hsection Last sectionDescribe gantt syntax :after doc1, 3dAdd gantt diagram to demo page : 20hAdd another diagram to demo page : 48h&#123;% endmermaid %&#125; 显示 gantt dateFormat YYYY-MM-DD axisFormat %d/%m title Adding GANTT diagram to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h git分支图 书写 1234567891011121314151617&#123;% mermaid gitGraph: %&#125;options&#123; "nodeSpacing": 150, "nodeRadius": 10&#125;endcommitbranch newbranchcheckout newbranchcommitcommitcheckout mastercommitcommitmerge newbranch&#123;% endmermaid %&#125; 显示 gitGraph: options { "nodeSpacing": 150, "nodeRadius": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch 参考链接Mermaid]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
        <category>NexT</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年7月-12月学习计划]]></title>
    <url>%2F2019%2F08%2F02%2F2019%E5%B9%B47%E6%9C%88-12%E6%9C%88%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[gantt dateFormat YYYY-MM-DD title 2019年7月-12月学习计划 section 7/19-8/22 Python和MySQL:2019-07-19, 34d section 8/23-9/28 数据结构与算法基础: 2019-08-23, 36d section 9/28-11/17 数据分析: 2019-09-28, 50d section 11/18-12/31 web开发: 2019-11-18, 43d]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel函数]]></title>
    <url>%2F2019%2F08%2F01%2FExcel%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Left()与LeftB():含截取到倒数指定字符如果要从左边开始截取字符，在Excel中，可以用Left()和；其中Left()是按字符个数截取，LeftB()是按字节个数截取；它们的区别在于，Left()把每个汉字算一个字符，而 LeftB()把每个汉字算两个字节；每个数字和字母，它们都算一个。 语法 Left() 表达式：LEFT(text, [Num_Chars]) 中文表达式：LEFT(文本, [截取字符个数]) LeftB() 表达式：LEFTB(text, [Num_Bytes]) 中文表达式：LEFTB(文本, [截取字节个数]) 说明： Num_Chars为可选项，若省略，则默认截取一个字符。Num_Bytes也为可选项，若省略，则默认截取一个字节。 Num_Chars必须大于等于0，如果Num_Chars大于文本长度，则返回所有文本。Num_Bytes也必须大于等于0；若文本全是中文，Num_Bytes大于等于文本长度的两倍，则返回把有文本；若文本由字母或数字组成，Num_Bytes大于等于文本长度，则返回所有文本。 使用方法及实例 Left() 假如要截取3个汉字。选中E2单元格，输入公式=LEFT(B2,3)，按回车，返回“蝴蝶结”三个字，操作过程步骤，如下图所示： LeftB() 把公式=LEFTB(A1,5)复制到B2单元格，按回车，则返回Excel；双击B2，把公式改为=LEFTB(A1,10)，按回车，则返回“Excel 2016”；操作过程步骤，如下图所示： 从两次返回结果可以看出，LeftB函数把字母、数字和空格都当成一个字节。 Find()与FindB():返回指定字符位置在Excel中，查找指定字符在源字符串中的位置，既可以用Find()，也可以用FindB()，它们都有三个参数，所不同的是，前者把汉字、字母和数字都算一个字符，后者把汉字算两个字节，数字和字母算一个字节。 语法 Find() 表达式：FIND(Find_Text, Within_Text, [Start_Num]) 中文表达式：FIND(查找文本, 源文本, [查找开始位置]) FindB() 表达式：FINDB(Find_Text, Within_Text, [Start_Num]) 中文表达式：FINDB(查找文本, 源文本, [查找开始位置]) 说明： FIND和FINDB区分大小写，并且不允许使用通配符。如果希望执行区分大小写的搜索或使用通配符，则可以使用 SEARCH和SEARCHB函数。 如果find_text为空文本 (“”)，则FIND会匹配搜索字符串中的首字符（即编号为start_num或1的字符）。 Find_text不能包含任何通配符。 如果find_text未显示在within_text中, 则FIND和FINDB返回#VALUE!。 如果start_num不大于零, 则FIND和FINDB返回#VALUE!。 如果start_num大于within_text的长度, 则FIND和FINDB返回#VALUE!。 可以使用start_num来跳过指定数目的字符。以FIND为例，假设要处理文本字符串“AYF0093.YoungMensApparel”。若要在文本字符串的说明部分中查找第一个“Y”的编号，请将start_num设置为8，这样就不会搜索文本的序列号部分。FIND从第8个字符开始查找，在下一个字符处找到find_text，然后返回其编号9。FIND始终返回从within_text 的起始位置计算的字符编号，如果start_num大于1，则会对跳过的字符计数。 使用方法及实例 数据 A 2 Miriam McGovern 公式 说明 结果 =FIND(“M”,A2) 单元格 A2 中第一个“M”的位置 1 =FIND(“m”,A2) 单元格 A2 中第一个“M”的位置 6 =FIND(“M”,A2,3) 从单元格 A2 的第三个字符开始查找第一个“M”的位置 8 参考文章 微软支持-Excel-公式和函数 Excel Left函数与LeftB函数使用方法，含截取到倒数指定字符实例]]></content>
      <categories>
        <category>工具</category>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作：天目云租户转成品库采集点增删改自动化查询]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%B7%A5%E4%BD%9C%EF%BC%9A%E5%A4%A9%E7%9B%AE%E4%BA%91%E7%A7%9F%E6%88%B7%E8%BD%AC%E6%88%90%E5%93%81%E5%BA%93%E9%87%87%E9%9B%86%E7%82%B9%E5%A2%9E%E5%88%A0%E6%94%B9%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[请输入密码以阅读这篇私密文章。 Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python：遍历列表时删除元素]]></title>
    <url>%2F2019%2F07%2F31%2FPython%EF%BC%9A%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8%E6%97%B6%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[Python的for循环可以遍历一个列表，但若需要同时将符合条件的元素删除时，则会出错。 示例 代码1123456s = [1, 2, 3, 4, 1, 1]s1 = sfor i in s1: if i == 1: s1.remove(i)print(s1) 输出1 1[2, 3, 4, 1] 代码2 12345s2 = sfor idx in range(len(s2)): if s2[idx] == 1: del s2[idx]print(s2) 输出2 1234Traceback (most recent call last): File "temp.py", line 11, in &lt;module&gt; if s2[idx] == 1:IndexError: list index out of range 出错原因Python中用for发起任何形式的遍历时，它的遍历顺序都是从最初就确定的，而在遍历中删除了元素会导致当前索引的变化，所以遍历中间取到的索引的那个值已经变了，会漏掉一些元素。另一种错误是删除元素后列表长度缩小了，所以会超出索引范围。 正确删除法使用filter()函数过滤掉符合指定条件的元素。12s3 = sprint(list(filter(lambda x: x != 1, s3))) 输出结果： 1[2, 3, 4] 此处lambda为Python中函数的简化定义形式。 使用列表解析式。12s4 = [i for i in s if i != 1]print(s4) 输出结果： 1[2, 3, 4] 拷贝一个新列表把原始列表拷贝给一个新列表，遍历新列表，修改原始列表（或相反）。 12345s6 = sfor i in s6[:]: if i == 1: s6.remove(i)print(s6) 输出结果： 1[2, 3, 4] 但是，下面的赋值操作给新列表是不行的，因为新变量和原变量的物理地址是相同的，可通过id()函数查看。 12345s5 = sfor i in s: if i == 1: s5.remove(i)print(s5) 输出结果： 1[2, 3, 4, 1] 通过深拷贝解决 1234567import copys5 = copy.deepcopy(s)for i in s: if i == 1: s5.remove(i)print(s5) 输出结果： 1[2, 3, 4] 用while循环来做判断条件。1234s7 = swhile 1 in s7: s7.remove(1)print(s7) 输出结果： 1[2, 3, 4]]]></content>
      <categories>
        <category>计算机</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机：语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习：Python基础（中）]]></title>
    <url>%2F2019%2F07%2F24%2FPython%E5%AD%A6%E4%B9%A0%EF%BC%9APython%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构（下）:Python容器列表：list list是由任意类型元素组成的序列。列表非常适合利用顺序和位置定位某一元素，尤其是当元素的顺序或内容经常发生改变时。与字符串不同，列表是可变的。你可以直接对原始列表进行修改：添加新元素、删除 或覆盖已有元素。在列表中，具有相同值的元素允许出现多次。 *Python中的三种序列结构：字符串，列表，元组。它们都可以包含零个或多个元素。与字符串不同的是，元组和列表并不要求所含元素的种类相同，每个元素都可以是任何Python类型的对象。而对于列表和元组来说，元组是不可变的，当你给元组赋值时，这些值便被固定在了元组里，再也无法修改。然而，列表却是可变的，这意味着可以随意地插入或删除其中的元素。 list =&gt; [&lt;exp&gt;,&lt;exp&gt;] 创建列表:使用[]或list()1234&gt;&gt;&gt; empty_list = [] &gt;&gt;&gt; weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'] &gt;&gt;&gt; big_birds = ['emu', 'ostrich', 'cassowary'] &gt;&gt;&gt; first_names = ['Graham', 'John', 'Terry', 'Terry', 'Michael'] 也可以使用list()函数来创建一个空列表： 123&gt;&gt;&gt; another_empty_list = list() &gt;&gt;&gt; another_empty_list [] 转换成列表:使用list()Python的list()函数可以将其他数据类型转换成列表类型。 123456789101112131415161718# 将字符串-》列表&gt;&gt;&gt; list('cat') ['c', 'a', 't']# 使用 split() 可以依据分隔符将字符串切割成由若干子串组成的列表：&gt;&gt;&gt; birthday = '1/6/1952' &gt;&gt;&gt; birthday.split('/') ['1', '6', '1952']# 如果待分割的字符串中包含连续的分隔符，那么在返回的列表中会出现空串元素：&gt;&gt;&gt; splitme = 'a/b//c/d///e' &gt;&gt;&gt; splitme.split('/') ['a', 'b', '', 'c', 'd', '', '', 'e']# 将元组-》列表&gt;&gt;&gt; a_tuple = ('ready', 'fire', 'aim') &gt;&gt;&gt; list(a_tuple) ['ready', 'fire', 'aim'] 获取列表元素：使用[offset]和字符串一样，通过偏移量可以从列表中提取对应位置的元素： 12345678910111213141516&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes[0] 'Groucho' &gt;&gt;&gt; marxes[1] 'Chico' &gt;&gt;&gt; marxes[2] 'Harpo'#负偏移量代表从尾部开始计数：&gt;&gt;&gt; marxes[-1] 'Harpo' &gt;&gt;&gt; marxes[-2] 'Chico' &gt;&gt;&gt; marxes[-3] 'Groucho' &gt;&gt;&gt; *指定的偏移量对于待访问列表必须有效——该位置的元素在访问前已正确赋值。当指定的偏移量小于起始位置或者大于末尾位置时，会产生异常（错误）。 包含列表的列表列表可以包含各种类型的元素，包括其他列表，如下所示： 123456789101112&gt;&gt;&gt; small_birds = ['hummingbird', 'finch'] &gt;&gt;&gt; extinct_birds = ['dodo', 'passenger pigeon', 'Norwegian Blue'] &gt;&gt;&gt; carol_birds = [3, 'French hens', 2, 'turtledoves'] &gt;&gt;&gt; all_birds = [small_birds, extinct_birds, 'macaw', carol_birds]# all_birds结构&gt;&gt;&gt; all_birds [['hummingbird', 'finch'], ['dodo', 'passenger pigeon', 'Norwegian Blue'], 'macaw', [3, 'French hens', 2, 'turtledoves']]# all_birds第一个元素&gt;&gt;&gt; all_birds[0] ['hummingbird', 'finch'] 使用[offset]修改元素就像可以通过偏移量访问某元素一样，你也可以通过赋值对它进行修改： 1234&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes[2] = 'Wanda' &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Wanda'] *与之前一样，列表的偏移量必须是合法有效的。 指定范围并使用切片提取元素列表的切片仍然是一个列表。可以使用切片提取列表的一个子序列,与字符串一样，列表的切片也可以设定除1以外的步长。 1234567891011&gt;&gt;&gt; marxes = ['Groucho', 'Chico,' 'Harpo'] &gt;&gt;&gt; marxes[0:2] ['Groucho', 'Chico']#从列表的开头开始每2个提取一个元素&gt;&gt;&gt; marxes[::2] ['Groucho', 'Harpo']# 可以巧妙地实现列表逆序：&gt;&gt;&gt; marxes[::-1] ['Harpo', 'Chico', 'Groucho'] 添加元素至尾部:使用append()利用append()函数将元素一个个添加到尾部。 123&gt;&gt;&gt; marxes.append('Zeppo') &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo'] 合并列表：使用extend()或+=使用extend()可以将一个列表合并到另一个列表中。 12345&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl'] &gt;&gt;&gt; marxes.extend(others) &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo', 'Gummo', 'Karl'] 也可以使用+=： 12345&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl'] &gt;&gt;&gt; marxes += others &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo', 'Gummo', 'Karl'] 如果使用了append()，那么others会被当成一个单独的元素进行添加,而不是将其中的内容进行合并： 12345&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl'] &gt;&gt;&gt; marxes.append(others) &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo', ['Gummo', 'Karl']] 在指定位置插入元素 :使用insert()append()函数只能将新元素插入到列表尾，而使用insert()可以将元素插入到列表的任 意位置。指定偏移量为0可以插入列表头部。如果指定的偏移量超过了尾部，则会插入到 列表最后，就如同append() 一样，这一操作不会产生 Python 异常。 12345&gt;&gt;&gt; marxes.insert(3, 'Gummo')&gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo'] &gt;&gt;&gt; marxes.insert(10, 'Karl') &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo', 'Karl'] 删除指定位置的元素:使用del当列表中一个元素被删除后,位于它后面的元素会自动往前移动填补空出的位置，且列表 长度减 1。再试试从更新后的marxes列表中删除&#39;Harpo&#39;： 1234567&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo'] &gt;&gt;&gt; marxes[2] 'Harpo' &gt;&gt;&gt; del marxes[2] &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Gummo', 'Zeppo'] &gt;&gt;&gt; marxes[2] 'Gummo' 在列表首删除/插入一个元素与在列表尾插入一个元素所用的时间是谁大？或者一样？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 计算时间函数&gt;&gt;&gt; from time import clock&gt;&gt;&gt; def timer(f):&gt;&gt;&gt; def _f(*args):&gt;&gt;&gt; t0 = clock()&gt;&gt;&gt; f(*args)&gt;&gt;&gt; return clock() - t0&gt;&gt;&gt; return _f # 删除 &gt;&gt;&gt; def delete_elem(x, index):&gt;&gt;&gt; del x[index]&gt;&gt;&gt; x = [5] * 100000000&gt;&gt;&gt; print(x[0])5&gt;&gt;&gt; print(x[999999])5&gt;&gt;&gt; print(len(x))100000000&gt;&gt;&gt; end_del = timer(delete_elem)(x, -1)&gt;&gt;&gt; print('现在list长度:',len(x))现在list长度: 99999999&gt;&gt;&gt; start_del = timer(delete_elem)(x, 0)&gt;&gt;&gt; print('现在list长度:',len(x))现在list长度: 99999998&gt;&gt;&gt; print('删首时间/删尾时间',start_del/end_del)删首时间/删尾时间 5339.656807434651# 插入&gt;&gt;&gt; def insert_elem(x, index, v):&gt;&gt;&gt; x.insert(index, v) &gt;&gt;&gt; x = [5] * 100000000&gt;&gt;&gt; print(x[0])5&gt;&gt;&gt; print(x[999999])5&gt;&gt;&gt; print(len(x))100000000&gt;&gt;&gt; start_del = timer(insert_elem)(x, 0, 9)&gt;&gt;&gt; print(len(x))100000001&gt;&gt;&gt; end_del = timer(insert_elem)(x, -1, 9)&gt;&gt;&gt; print(len(x))100000002&gt;&gt;&gt; print('删首时间/删尾时间',start_del/end_del)删首时间/删尾时间 200615.78078284615 由上面可知在列表首删除/插入一个元素远远大于在列表尾插入一个元素所用的时间。原因在于列表在存储时，是存在于一片连续的储存单元中。删除最后一个元素时候，只要根据index找到该元素，然后删除。而删除第一个元素时候，需要找到第一个元素删除的同时，需要把其后面的元素移前一个位置。插入同理。 删除具有指定值的元素:使用remove()1234&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo'] &gt;&gt;&gt; marxes.remove('Gummo') &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo'] 获取并删除指定位置的元素:使用pop()使用pop()同样可以获取列表中指定位置的元素，但在获取完成后，该元素会被自动删除。如果你为pop()指定了偏移量，它会返回偏移量对应位置的元素；如果不指定，则默认使用-1。因此，pop(0)将返回列表的头元素，而pop()或pop(-1)则会返回列表的尾元素 123456789&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; marxes.pop() 'Zeppo' &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes.pop(1) 'Chico' &gt;&gt;&gt; marxes ['Groucho', 'Harpo'] 查询具有特定值的元素位置:使用index()如果该查询的元素在列表中不存在，使用index时会报异常。 123&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; marxes.index('Chico') 1 判断值是否存在：使用in同一个值可能出现在列表的多个位置，但只要至少出现一次，in就会返回True： 12&gt;&gt;&gt; words = ['a', 'deer', 'a' 'female', 'deer'] &gt;&gt;&gt; 'deer' in words True 记录特定值出现的次数:使用count()123456789&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes.count('Harpo') 1 &gt;&gt;&gt; marxes.count('Bob')0 &gt;&gt;&gt; snl_skit = ['cheeseburger', 'cheeseburger', 'cheeseburger']&gt;&gt;&gt; snl_skit.count('cheeseburger') 3 转换为字符串:使用join()join()实际上是一个字符串方法，而不是列表方法。不能通过marxes.join(&#39;,&#39;)进行调用，尽管这可能看起来更直观。join() 函数的参数是字符串或者其他可迭代的包含字符串的序列，它的输出是一个字符串。。试着这样来记忆 join() 的调用顺序： join()是split()的逆过程 12345678910111213&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; ', '.join(marxes) 'Groucho, Chico, Harpo'&gt;&gt;&gt; friends = ['Harry', 'Hermione', 'Ron'] &gt;&gt;&gt; separator = ' * ' &gt;&gt;&gt; joined = separator.join(friends) &gt;&gt;&gt; joined 'Harry * Hermione * Ron' &gt;&gt;&gt; separated = joined.split(separator) &gt;&gt;&gt; separated ['Harry', 'Hermione', 'Ron'] &gt;&gt;&gt; separated == friends True 获取长度:使用len()123&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; len(marxes) 3 使用sort()重新排列元素将列表中的元素按值排序,Python 为此 提供了两个函数： 列表方法sort()会对原列表进行排序，改变原列表内容； 通用函数sorted()则会返回排好序的列表副本，原列表内容不变。 如果列表中的元素都是数字，它们会默认地被排列成从小到大的升序。如果元素都是字符 串，则会按照字母表顺序排列 1234567891011# sorted_marxes是一个副本，它的创建并不会改变原始列表的内容&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; sorted_marxes = sorted(marxes) &gt;&gt;&gt; sorted_marxes ['Chico', 'Groucho', 'Harpo']&gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo']# 但对 marxes 列表调用列表函数 sort() 则会改变它的内容&gt;&gt;&gt; marxes.sort() &gt;&gt;&gt; marxes ['Chico', 'Groucho', 'Harpo'] 当列表中的所有元素都是同一种类型时（例如marxes中都是字符串），sort()会正常工作。有些时候甚至多种类型也可——例如整型和浮点型——只要它们之间能够自动地互相转换 123&gt;&gt;&gt; numbers = [2, 1, 4.0, 3] &gt;&gt;&gt; numbers.sort() &gt;&gt;&gt; numbers [1, 2, 3, 4.0] 默认的排序是升序的，通过添加参数reverse=True可以改变为降序排列 1234&gt;&gt;&gt; numbers = [2, 1, 4.0, 3] &gt;&gt;&gt; numbers.sort(reverse=True) &gt;&gt;&gt; numbers[4.0, 3, 2, 1] 使用=赋值，使用copy()复制如果将一个列表赋值给了多个变量，改变其中的任何一处会造成其他变量对应的值也被修改。 1234567&gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; a [1, 2, 3] &gt;&gt;&gt; b = a &gt;&gt;&gt; b [1, 2, 3] &gt;&gt;&gt; a[0] = 'surprise' &gt;&gt;&gt; a ['surprise', 2, 3]&gt;&gt;&gt; b ['surprise', 2, 3] b与a实际上指向的是同一个对象，因此，无论我们是通过a还是通过b来修改列表的内容，其结果都会作用于双方。通过下面任意一种方法，都可以将一个列表的值复制到另一个新的列表中： 列表copy()函数 list()转换函数 列表分片[:]1234567891011121314&gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; b = a.copy() &gt;&gt;&gt; c = list(a) &gt;&gt;&gt; d = a[:]&gt;&gt;&gt; a[0] = 'integer lists are boring' &gt;&gt;&gt; a ['integer lists are boring', 2, 3] &gt;&gt;&gt; b [1, 2, 3] &gt;&gt;&gt; c [1, 2, 3] &gt;&gt;&gt; d [1, 2, 3] 元组：Tuple元组也是由任意类型元素组成的序列。与列表不同的是，元组是不可变的，这意味着一旦元组被定义，将无法再进行增加、删除或修改元素等操作。因此，元组就像是一个常量列表。 创建元组：使用()可以用 () 创建一个空元组： 123&gt;&gt;&gt; empty_tuple = () &gt;&gt;&gt; empty_tuple () 创建包含一个或多个元素的元组时，每一个元素后面都需要跟着一个逗号，即使只包含一个元素也不能省略： 123&gt;&gt;&gt; one_marx = 'Groucho', &gt;&gt;&gt; one_marx ('Groucho',) 如果创建的元组所包含的元素数量超过1，最后一个元素后面的逗号可以省略： 123&gt;&gt;&gt; marx_tuple = 'Groucho', 'Chico', 'Harpo' &gt;&gt;&gt; marx_tuple ('Groucho', 'Chico', 'Harpo') Python的交互式解释器输出元组时会自动添加一对圆括号。你并不需要这么做——定义元组真正靠的是每个元素的后缀逗号——但如果你习惯添加一对括号也无可厚非。可以用括号将所有元素包裹起来，这会使得程序更加清晰： 123&gt;&gt;&gt; marx_tuple = ('Groucho', 'Chico', 'Harpo') &gt;&gt;&gt; marx_tuple ('Groucho', 'Chico', 'Harpo') 可以一口气将元组赋值给多个变量：(有时这个过程被称为元组解包。) 12345678&gt;&gt;&gt; marx_tuple = ('Groucho', 'Chico', 'Harpo') &gt;&gt;&gt; a, b, c = marx_tuple &gt;&gt;&gt; a 'Groucho' &gt;&gt;&gt; b 'Chico' &gt;&gt;&gt; c 'Harpo' 可以利用元组在一条语句中对多个变量的值进行交换，而不需要借助临时变量： 1234567&gt;&gt;&gt; password = 'swordfish' &gt;&gt;&gt; icecream = 'tuttifrutti' &gt;&gt;&gt; password, icecream = icecream, password &gt;&gt;&gt; password 'tuttifrutti' &gt;&gt;&gt; icecream 'swordfish' tuple() 函数可以用其他类型的数据来创建元组： 123&gt;&gt;&gt; marx_list = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; tuple(marx_list) ('Groucho', 'Chico', 'Harpo') 元组与列表在许多地方都可以用元组代替列表，但元组的方法函数与列表相比要少一些——元组没有append()、insert()，等等——因为一旦创建元组便无法修改。既然列表更加灵活，那为什么不在所有地方都使用列表呢？原因如下所示： 元组占用的空间较小 你不会意外修改元组的值 可以将元组用作字典的键 - 命名元组可以作为对象的替代 函数的参数是以元组形式传递的 字典: dict字典（dictionary）与列表类似，但其中元素的顺序无关紧要，因为它们不是通过像0或1的偏移量访问的。取而代之，每个元素拥有与之对应的互不相同的键（key），需要通过键来访问元素。键通常是字符串，但它还可以是Python中其他任意的不可变类型：布尔型、 整型、浮点型、元组、字符串，以及其他一些在后面的内容中会见到的类型。字典是可变的，因此你可以增加、删除或修改其中的键值对。 创建字典:使用{}用大括号（{}）将一系列以逗号隔开的键值对（key:value）包裹起来即可进行字典的创建。最简单的字典是空字典，它不包含任何键值对： 12345678910111213141516&gt;&gt;&gt; empty_dict = &#123;&#125; &gt;&gt;&gt; empty_dict &#123;&#125;&gt;&gt;&gt; pizza = &#123; "size":"medium", "type":"pepperoni", "crust":"Thick", "qty": 1, "deliver":True,&#125;&#123;'size': 'medium', 'type': 'pepperoni', 'crust': 'Thick', 'qty': 1, 'deliver': True&#125; Python 允许在列表、元组或字典的最后一个元素后面添加逗号，这不会产生任何问题。此外，在括号之间输入键值对来创建字典时并不强制缩进。 转换为字典：使用dict()可以用 dict() 将包含双值子序列的序列转换成字典。每个子序列 的第一个元素作为键，第二个元素作为值。 1234567&gt;&gt;&gt; lot = [ ('a', 'b'), ('c', 'd'), ('e', 'f') ] &gt;&gt;&gt; dict(lot) &#123;'c': 'd', 'a': 'b', 'e': 'f'&#125;&gt;&gt;&gt; los = [ 'ab', 'cd', 'ef' ] &gt;&gt;&gt; dict(los) &#123;'c': 'd', 'a': 'b', 'e': 'f'&#125; 添加或修改元素:使用[key]向字典中添加元素非常简单，只需指定该元素的键并赋予相应的值即可。如果该元素的键已经存在于字典中，那么该键对应的旧值会被新值取代。如果该元素的键并未在字典中出现，则会被加入字典。与列表不同，你不需要担心赋值过程中Python 会抛出越界异常。 123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; pythons = &#123; 'Chapman': 'Graham', 'Cleese': 'John', 'Idle': 'Eric', 'Jones': 'Terry', 'Palin': 'Michael', &#125; &gt;&gt;&gt; pythons &#123;'Cleese': 'John','Jones': 'Terry', 'Palin': 'Michael','Chapman': 'Graham', 'Idle': 'Eric'&#125;# 新增 pythons['Gilliam'] = 'Gerry'&gt;&gt;&gt; pythons['Gilliam'] = 'Gerry' &gt;&gt;&gt; pythons &#123;'Cleese': 'John', 'Gilliam': 'Gerry', 'Palin': 'Michael', 'Chapman': 'Graham', 'Idle': 'Eric', 'Jones': 'Terry'&#125;# 修改pythons['Gilliam'] = 'Terry'&gt;&gt;&gt; pythons['Gilliam'] = 'Terry' &gt;&gt;&gt; pythons &#123;'Cleese': 'John', 'Gilliam': 'Terry', 'Palin': 'Michael', 'Chapman': 'Graham', 'Idle': 'Eric', 'Jones': 'Terry'&#125; 合并字典：使用update()如果待添加的字典与待扩充的字典包含同样的键，那么新归入字典的值会取代原有的值 12345&gt;&gt;&gt; first = &#123;'a': 1, 'b': 2&#125; &gt;&gt;&gt; second = &#123;'b': 'platypus'&#125; &gt;&gt;&gt; first.update(second) &gt;&gt;&gt; first &#123;'b': 'platypus', 'a': 1&#125; 删除具有指定键的元素:使用del1234&gt;&gt;&gt; first = &#123;'a': 1, 'b': 2&#125; &gt;&gt;&gt; del first['a']&gt;&gt;&gt; first&#123;'b': 2&#125; 删除所有元素:使用clear()使用clear()，或者给字典变量重新赋值一个空字典（{}）可以将字典中所有元素删除： 123456&gt;&gt;&gt; pythons.clear() &gt;&gt;&gt; pythons &#123;&#125; &gt;&gt;&gt; pythons = &#123;&#125; &gt;&gt;&gt; pythons&#123;&#125; 使用in判断是否存在如果你希望判断某一个键是否存在于一个字典中，可以使用in。 12345&gt;&gt;&gt; pythons = &#123;'Chapman': 'Graham', 'Cleese': 'John', 'Jones': 'Terry', 'Palin': 'Michael'&#125;&gt;&gt;&gt; 'Chapman' in pythons True &gt;&gt;&gt; 'Palin' in pythons True 使用[key]获取元素这是对字典最常进行的操作，只需指定字典名和键即可获得对应的值： 12&gt;&gt;&gt; pythons['Cleese'] 'John' 如果字典中不包含指定的键，会产生一个异常。有两种方法可以避免这种情况的发生。第一种是在访问前通过in测试键是否存在，另一种方法是使用字典函数get()。你需要指定字典名，键以及一个可选值。如果键存在，会得到与之对应的值反之，若键不存在，如果你指定了可选值，那么get()函数将返回这个可选值,否则，会得到None（在交互式解释器中什么也不会显示）： 12345678&gt;&gt;&gt; pythons.get('Cleese') 'John'&gt;&gt;&gt; pythons.get('Marx', 'Not a Python') 'Not a Python'&gt;&gt;&gt; pythons.get('Marx') &gt;&gt;&gt; 获取所有键:使用keys()使用keys()可以获得字典中的所有键。在接下来的几个例子中，我们将换一个示例： 123&gt;&gt;&gt; signals = &#123;'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'&#125; &gt;&gt;&gt; signals.keys() dict_keys(['green', 'red', 'yellow']) 在Python 2里，keys()会返回一个列表，而在Python 3中则会返回dict_keys()，它是键的迭代形式。这种返回形式对于大型的字典非常有用，因为它不需要时间和空间来创建返回的列表。有时你需要的可能就是一个完整的列表，但在Python 3中，你只能自己调用list()将dict_keys转换为列表类型。 获取所有值:使用values()使用 values()可以获取字典中的所有值： 12&gt;&gt;&gt; list( signals.values() ) ['go', 'smile for the camera', 'go faster'] 获取所有键值对:使用items()使用items()函数可以获取字典中所有的键值对： 12&gt;&gt;&gt; list( signals.items() ) [('green', 'go'), ('red', 'smile for the camera'), ('yellow', 'go faster')] 每一个键值对以元组的形式返回，例如(&#39;green&#39;,&#39;go&#39;)。 使用=赋值，使用copy()复制与列表一样，对字典内容进行的修改会反映到所有与之相关联的变量名上： 12345&gt;&gt;&gt; signals = &#123;'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'&#125; &gt;&gt;&gt; save_signals = signals &gt;&gt;&gt; signals['blue'] = 'confuse everyone' &gt;&gt;&gt; save_signals&#123;'blue': 'confuse everyone', 'green': 'go', 'red': 'smile for the camera', 'yellow': 'go faster'&#125; 若想避免这种情况，可以使用copy(),将字典复制到一个新的字典中： 1234567&gt;&gt;&gt; signals = &#123;'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'&#125; &gt;&gt;&gt; original_signals = signals.copy() &gt;&gt;&gt; signals['blue'] = 'confuse everyone' &gt;&gt;&gt; signals &#123;'blue': 'confuse everyone', 'green': 'go', 'red': 'smile for the camera', 'yellow': 'go faster'&#125; &gt;&gt;&gt; original_signals &#123;'green': 'go', 'red': 'smile for the camera', 'yellow': 'go faster'&#125; 集合：set集合就像舍弃了值，仅剩下键的字典一样。键与键之间也不允许重复。如果你仅仅想知道某一个元素是否存在而不关心其他的，使用集合是个非常好的选择。 创建集合:使用set()与字典的键一样，集合是无序的。 123456789&gt;&gt;&gt; empty_set = set() &gt;&gt;&gt; empty_set set() &gt;&gt;&gt; even_numbers = &#123;0, 2, 4, 6, 8&#125; &gt;&gt;&gt; even_numbers &#123;0, 8, 2, 4, 6&#125; &gt;&gt;&gt; odd_numbers = &#123;1, 3, 5, 7, 9&#125; &gt;&gt;&gt; odd_numbers &#123;9, 3, 1, 5, 7&#125; 将其他类型转换为集合:使用set()利用已有列表、字符串、元组或字典的内容来创建集合，其中重复的值会被丢弃。 1234&gt;&gt;&gt; set( 'letters' )&#123;'l', 'e', 't', 'r', 's'&#125;&gt;&gt;&gt; set( ('Ummagumma', 'Echoes', 'Atom Heart Mother') ) &#123;'Ummagumma', 'Atom Heart Mother', 'Echoes'&#125; 测试值是否存在:使用in123&gt;&gt;&gt; martini = &#123;'vodka', 'vermouth'&#125;&gt;&gt;&gt; 'vodka' in martiniTrue 合并及运算符交集：通过使用特殊标点符号&amp;或者集合函数intersection() 获取集合的交集（两集合共有元素） 123456&gt;&gt;&gt; a = &#123;1, 2&#125; &gt;&gt;&gt; b = &#123;2, 3&#125;&gt;&gt;&gt; a &amp; b &#123;2&#125; &gt;&gt;&gt; a.intersection(b) &#123;2&#125; 并集：使用 |或者union()函数来获取集合的并集（至少出现在一个集合中的元素）： 123456&gt;&gt;&gt; a = &#123;1, 2&#125; &gt;&gt;&gt; b = &#123;2, 3&#125;&gt;&gt;&gt; a | b &#123;1, 2, 3&#125; &gt;&gt;&gt; a.union(b) &#123;1, 2, 3&#125; 差集：使用字符-或者difference()可以获得两个集合的差集（出现在第一个集合但不出现在第二个集合）： 1234&gt;&gt;&gt; a - b &#123;1&#125; &gt;&gt;&gt; a.difference(b) &#123;1&#125; 异或集:使用^或者symmetric_difference()可以获得两个集合的异或集（仅在两个集合中出现一次）： 1234&gt;&gt;&gt; a ^ b &#123;1, 3&#125; &gt;&gt;&gt; a.symmetric_difference(b) &#123;1, 3&#125; 子集：使用&lt;=或者issubset()可以判断一个集合是否是另一个集合的子集（第一个集合的所有元素都出现在第二个集合中）： 1234&gt;&gt;&gt; a &lt;= b False &gt;&gt;&gt; a.issubset(b) False 真子集:当第二个集合包含所有第一个集合的元素，且仍包含其他元素时，我们称第一个集合为第二个集合的真子集。使用&lt;可以进行判断： 1234&gt;&gt;&gt; a &lt; b False &gt;&gt;&gt; a &lt; a False 超集：超集与子集正好相反（第二个集合的所有元素都出现在第一个集合中），使用 &gt;=或者 issuperset() 可以进行判断： 1234&gt;&gt;&gt; a &gt;= b False &gt;&gt;&gt; a.issuperset(b) False 一个集合是它本身的超集： 1234&gt;&gt;&gt; a &gt;= a True &gt;&gt;&gt; a.issuperset(a) True 真超集:使用&gt;可以找到一个集合的真超集（第一个集合包含第二个集合的所有元素且还包含其他元素）： 12&gt;&gt;&gt; a &gt; b False]]></content>
      <categories>
        <category>计算机</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机：语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作：媒立方采集点数据与天目云采集点差异比较]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%B7%A5%E4%BD%9C%EF%BC%9A%E5%AA%92%E7%AB%8B%E6%96%B9%E9%87%87%E9%9B%86%E7%82%B9%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%A4%A9%E7%9B%AE%E4%BA%91%E9%87%87%E9%9B%86%E7%82%B9%E5%B7%AE%E5%BC%82%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[请输入密码以阅读这篇私密文章。 Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python：excel处理（xld与xlwt）]]></title>
    <url>%2F2019%2F07%2F16%2FPython%EF%BC%9Aexcel%E5%A4%84%E7%90%86%EF%BC%88xld%E4%B8%8Exlwt%EF%BC%89%2F</url>
    <content type="text"><![CDATA[excel处理工具:xlrd与xlwt xlrd是python语言中读取excel的扩展工具包，可以实现指定表单、指定单元格的读取。 xlwt是python语言中写excel的扩展工具包，可以实现指定表单、指定单元格的写入。 一、xlrd安装使用 pip install xlrd 来安装xlrd模块。 基本操作123456789101112131415161718192021222324252627282930313233343536# 示例：# 导入扩展包import xlrd# 打开Excel文件读取数据data = xlrd.open_workbook('excelFile.xls') [1] # 获取一个工作表table = data.sheets()[0] #通过索引顺序获取table = data.sheet_by_index(0) #通过索引顺序获取table = data.sheet_by_name(u'Sheet1') #通过名称获取# 获取整行和整列的值（数组）table.row_values(i)table.col_values(i)# 获取行数和列数nrows = table.nrowsncols = table.ncols# 循环行列表数据for i in range(nrows ):print table.row_values(i)# 单元格table.cell(rowx,colx)cell_A1 = table.cell(0,0).valuecell_C4 = table.cell(3,2).value# 使用行列索引cell_A1 = table.row(0)[0].valuecell_A2 = table.col(1)[0].value# 简单的写入row = 0col = 0# 常用单元格中的类型 empty,1 string, 2 number, 3 date, 4 boolean, 5 error, 6 blankctype = 1 value = '单元格的值'# 扩展的格式化xf = 0 table.put_cell(row, col, ctype, value, xf)table.cell(0,0) #单元格的值'table.cell(0,0).value #单元格的值' 二、xlwt安装使用 pip install xlwt 来安装xlwt模块。 基本操作12345678910# 导入模块import xlwt# 创建workbook（其实就是excel，后来保存一下就行）workbook = xlwt.Workbook(encoding = 'ascii')# 创建表worksheet = workbook.add_sheet('My Worksheet')# 往单元格内写入内容worksheet.write(0, 0, label = 'Row 0, Column 0 Value')# 保存workbook.save('Excel_Workbook.xls')]]></content>
      <categories>
        <category>计算机</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机：语言</tag>
      </tags>
  </entry>
</search>
