<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL：添加数据]]></title>
    <url>%2F2019%2F10%2F01%2FMySQL%EF%BC%9A3.%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245-- DROP TABLE IF EXISTS products;-- 1.mysql的字段名、表名通常不需要加任何引号，如果非要加上引号，必须加反引号； -- 2.mysql的别名可以不加引号，如果加引号，单引号和双引号以及反引号都可以； -- 3.单引号和双引号都可以表示字符串；-- 中文可以，但绝对不推荐-- CREATE TABLE `products` (-- `名称` varchar(100) DEFAULT NULL-- );create database KFC;use KFC;CREATE TABLE products ( PRIMARY KEY (product_id), product_id INT(11) NOT NULL AUTO_INCREMENT, name VARCHAR(100) DEFAULT NULL, image_url VARCHAR(255) DEFAULT NULL, sales_status ENUM('NEW', 'DEPRECATED') DEFAULT 'NEW', price DECIMAL(9 , 2 ) DEFAULT NULL, create_date DATETIME);-- 插入列ALTER TABLE products ADD COLUMN detail VARCHAR(100) NOT NULL after `name`;-- 修改列ALTER TABLE products CHANGE COLUMN detail more_info VARCHAR(200) NOT NULL default 'N/A'; -- 删除列alter table products drop column more_info;describe products;INSERT INTO productsVALUES(1,'香辣鸡腿堡人气餐A','http://img.mp.itc.cn/upload/20170424/4349e424649342c3b7227b5cde643902_th.jpeg','NEW',36,'2014-11-20 08:20:00'),(2,'海苔岩烧大鸡腿饭套餐A2','','NEW',37,'2014-12-20 08:20:00'),(3,'夏日缤纷桶','','NEW',88,'2016-11-20 10:20:00'),(4,'新奥尔良烤鸡腿堡人气餐B','','NEW',36,'2016-11-20 10:20:00');INSERT INTO products (name, price, create_date)VALUES ('超级塔可午餐套餐',27, now());SELECT *FROM products;-- 删除product_id = 6的记录DELETE FROM products WHERE product_id = '6';-- 更新记录UPDATE products SET price = 50WHERE product_id = '5';-- select 查询SELECT name, priceFROM products;UPDATE products SET sales_status = 'DEPRECATED'WHERE product_id = 1;-- 查询有多少种sales_statusSELECT DISTINCT sales_statusFROM products;-- 按条件查询SELECT *FROM productsWHERE product_id = 1;/*********************conditional queryOperators in the WHERE clause= Equal&lt;&gt; Not equal. Note: In some versions of SQL this operator may be written as !=&gt; Greater than&lt; Less than&gt;= Greater than or equal&lt;= Less than or equalBETWEEN Between an inclusive rangeLIKE Search for a patternIN To specify multiple possible values for a column *********************/SELECT *FROM productsWHERE price &gt; 60; -- 价格在30-40区间SELECT *FROM productsWHERE price BETWEEN 30 AND 40;-- 价格是50和36的SELECT *FROM productsWHERE price IN (50 , 36);SELECT *FROM productsWHERE price = 50 OR price = 36;-- 图片是空与不是空SELECT *FROM productsWHERE image_url IS NULL;SELECT *FROM productsWHERE image_url IS NOT NULL;-- 名字中间有鸡腿内容的SELECT *FROM productsWHERE `name` LIKE '%鸡腿%';-- 名字以香辣开头SELECT *FROM productsWHERE `name` LIKE '香辣%';-- 名字以桶结尾SELECT *FROM productsWHERE `name` LIKE '%桶';-- 名字是香x鸡腿堡SELECT *FROM productsWHERE `name` LIKE '香_鸡腿堡%';-- 名字是5个子的（5个_）SELECT *FROM productsWHERE `name` LIKE '_____'; SELECT *FROM products;SELECT *FROM productsWHERE price BETWEEN 40 AND 60;SELECT *FROM productsWHERE create_date &lt; '2016-01-01' AND sales_status &lt;&gt; 'DEPRECATED';-- 按照价格降序排列SELECT *FROM productsORDER BY PRICE DESCLIMIT 3;-- 按照价格升序排序SELECT *FROM productsORDER BY price;SELECT *FROM productsWHERE create_date &gt; '2015-12-31'ORDER BY create_date , price ASCLIMIT 3;SELECT *FROM productsLIMIT 3 , 5;SELECT name, price, price + 10 AS adjusted_priceFROM products;SELECT product_id, name, IF(image_url IS NULL, 'n/a', image_url) AS image_url_detailFROM products;-- &lt;20 ,&gt;-20,30 , 30,40 ,40,50,50,50+,price_groupSELECT `name`, price, (CASE WHEN price &lt; 20 THEN '0-20' WHEN price &gt;= 20 AND price &lt; 30 THEN '20-30' WHEN price &gt;= 30 AND price &lt; 50 THEN '20-50' ELSE '+_+' END) AS price_groupFROM products;]]></content>
      <categories>
        <category>计算机</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>计算机：数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL：1.数据库概要]]></title>
    <url>%2F2019%2F10%2F01%2FMySQL%EF%BC%9A1.%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%A6%81%2F</url>
    <content type="text"><![CDATA[使用环境和工具 MySQL 8.0 sever（5.7之后就是8） MySQL Workbench 8.0 Excel VS Code 关于本课程学习熟悉数据库的使用及设计，有能力设计基本的数据库 第一阶段：数据库入门 基本概念及SQL基本语法 第二阶段：数据库建模 关系型数据库设计，实体关系模型，Normalize Data Model 第三阶段：数据库分析 数据仓库及纬度模型设计 Dimensional Model 第四阶段：数据库优化及整合 操作+超商数据库项目 几个原则 语言规范 https://www.sqlstyle.guide/zh/ 按需求设计 =》使用 =》优化，循序渐进 Workbench 针对MySQL的图形界面工具 SQL Development Data Modeling Server Administration Data Migration 宏观看数据 计算机都在干什么？ graph LR id1[计算]-- 传输---id2[存储] 流动的数据 graph LR id1[产生] id2[存储] id3[传输] id4[处理] id1-->id2 id2-->id3 id3-->id4 id4-->id1 场景 网站 应用程序 手机App 智能家电 商业智能系统 大数据系统 数据存储及访问的问题？ 存储 电脑查询，人工查询 新建，增加，修改，删除 大量 故障？ 同时访问 数据库数据库 数据库就像电子化的档案库，用来存储数字档案的。 本质上讲，数据库就是数据的集合，信息的载体。 数据库的特点 可以通过某种特定的操作语言（SQL）进行增删改查（CRUD）等数据操作 可以通过某种特定的数据定义语言来建立新的数据库 支持大量，长时间的存储，并在数据查询和更新时支持对数据的有效存储 具有持久性，面对故障、错误或用户错误使用数据库时，数据库可以恢复保证数据一致性 可以控制多个用户对数据的同时存取，不允许相互干扰，也不允许对数据不完整的操作 Excel ？ Excel算不算数据库？ 可以算，也可以不算。因为其有些特点不适合数据库。比如说数据库支持数据量大，但是excel存数据并不算很大。 数据库相关的数据 数据： 数据库存的数据 元数据：描述数据库结构及其约束的数据 日志记录：修改信息等 统计记录：数据特征的数据，例如，库大小等 索引：对数据库数据有效存取的数据结构 关系型数据库 基本理念 数据库数据基本概念 常见关系型数据库 Oracle mysql sql sever …… 数据库历史推荐文章：https://www.vertabelo.com/blog/notes-from-the-lab/why-sql-is-neither-legacy-nor-low-level-but-simply-awesome 关系型数据库 关系 一对一 一对多 多对多 关系型数据库的一些主要概念 表 Table(s) 列 Column(s) 记录 Record(s) 关系 Relation(s) 键值 Key(s) Schema 模式 数据库的组织和结构 就是数据库对象的集合，所谓的数据库对象也就是常说的表， 索引，视图，存储过程等。 关系 Relationships 一对多 一对一 多对多 我们怎么使用数据库 先想清楚需要存储什么的数据到数据库 然后根据需求创建数据库结构 然后我们之后可以用来怎样查询 约束 Constrains 主键约束,Primary Key constraint Unique Identifier. Not Null. 非空,NOT NULL constraint Ensures that column does not accept nulls 唯一,UNIQUE constraint Ensures that all values in column are unique 预设值,DEFAULT constraint Assigns value to attribute when a new row is added to table 限定,CHECK constraint Validates data when attribute value is entered SQL 结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新 和管理关系数据库系统； 狭义上说，SQL就是用来和关系型数据库交互的语言 哪里都有SQL 全栈 大数据 excel BI …… SQL Language DDL data definition language DML data manipulation language DCL data control language Data Definition Data Manipulation Query Create Database Add Data Select Create Table Update Data Join Alter Table Delete Data Union Drop Table Query Data Sub-Query Create Index Aggregation 语言的描述——BNF范式 描述一个文法，我们常常使用巴斯克范式（BNF范式）来描述一个文法的结构 方括号( [ ] )内包含的为可选项。 大括号( { } )内包含的为可重复0至无数次的项。 竖线( | )表示在其左右两边任选一项，相当于”OR”的意思。 尖括号( &lt; &gt; )内包含的为必选项 创建 SELECT语句1select * from employment 这句话的意思是从查询表employment所有数据 select 和 from 是关键字 *：代表了所有 employment：表名称 一些简单的操作SQL语句12345USE 数据库名称database1; #使用数据库database1SHOW DATABASE; #显示所有的数据库名称SHOW TABLES; #显示正在使用的数据库的所有表名称 数据类型 创建一个表格的基本语句123456CREATE TABLE 表名称(列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,) 几种数据类型 数值 Numeric Types 日期和时间 Date and Time Types 字符串 String Types 空间数据 Spatial Data Types JSON数据 The JSON Data Type]]></content>
      <categories>
        <category>计算机</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>计算机：数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL：2.数据库概要]]></title>
    <url>%2F2019%2F10%2F01%2FMySQL%EF%BC%9A2.%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[相关代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* 创建数据库*/create database del_learning;create database if not exists del_learning;/* 删除数据库 */drop database del_learning;drop database if exists del_learning;/*创建表单*/use del_learning;create table number_test( number_a int, number_b int zerofill, number_c int(3), number_d int(3) zerofill, number_e int(11), number_f int(11) zerofill, number_g int(100) zerofill);/*int(数值)，里面的数值是只具有显示意义，与int类型范围无关*/INSERT INTO number_test VALUES (1,1,1,1,1,1,1);INSERT INTO number_test VALUES (11111,11111,1111,1,1,1,1);INSERT INTO number_test VALUES (1,1,1,1,1,1,42949672952);/*报错42949672952，超过int规定的范围*/select * from number_test;CREATE TABLE t1 (i1 TINYINT, i2 TINYINT UNSIGNED);-- UNSIGNED代表无符号-- 浮点create table t3 (di decimal(5,2), d2 double(5,2), d3 float(5,2), d4 decimal, d5 double, d6 float);insert into t3values(34.432,34.432,34.432,34.432,34.432,34.432),(34,34,34,34,34,34),(34.439,34.439,34.439,34.439,34.439,34.439);select * from t3;create table decimal_float (dml decimal(10,2),flt float(10,2));insert into decimal_float values (64.83,74.88);insert into decimal_float values(25.99,45.99);-- 运算SELECT flt,( 1.0000000 * flt ) FROM decimal_float;SELECT flt,( 1.0000000000 * flt ) FROM decimal_float;SELECT dml,( 1.000000000000000 * dml ) FROM decimal_float;-- 0-13.20+59.60+30.40 = 76.8-- 0+0+46.40+30.40 = 76.8-- but!create table t2 (i int, d1 double, d2 double);insert into t2 values (2, 0.00 , 0.00),(2, -13.20, 0.00),(2, 59.60 , 46.40),(2, 30.40 , 30.40);SELECT i, SUM(d1) AS a, SUM(d2) AS bFROM t1GROUP BY iHAVING a &lt;&gt; b; -- a != b-- 字符串-- TEXT : 一般存超长文本CREATE TABLE vc (v VARCHAR(4), c CHAR(4),detail TEXT);INSERT INTO vc VALUES ('ab ', 'ab ');select * from vc;-- CONCAT()是一个函数，把两个字符串连接起来的函数select CONCAT('a','b');SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;-- 枚举和集合CREATE TABLE fonts ( name VARCHAR(40), color ENUM('red','green','blue'), attribute SET('bold','italic','underline'));INSERT INTO fonts (color) VALUES ('red');INSERT INTO fonts (color) VALUES (1);-- 枚举从1开始对应，0对应的是''INSERT INTO fonts (color) VALUES ('gray');INSERT INTO fonts (color) VALUES ('red,green');/*set 可以多选*/INSERT INTO fonts (attribute) VALUES ('bold');INSERT INTO fonts (attribute) VALUES ('gray');INSERT INTO fonts (attribute) VALUES (1);-- set值与数值对应的1，2，4（如果是3，那么意味着1对应的值+2对应的值）INSERT INTO fonts (attribute) VALUES ('bold,italic');INSERT INTO fonts (attribute) VALUES ('bold,italic,underline');INSERT INTO fonts (attribute) VALUES (1+2+4);select * from fonts;-- 时间与日期create table if not exists date_time_types(employee_date date comment 'YYYY-MM-DD, between 1000-01-01 and 9999-12-31. 1973-12-30',department_datetime datetime comment 'YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 to 9999-12-31 23:59:59',dpt_datetime DATETIME(6),details_datetime timestamp comment '1970-01-01 00:00:01 UTC to 2038-01-19 03:14:07');INSERT INTO date_time_types(`employee_date`,`department_datetime`,`dpt_datetime`,`details_datetime`)VALUES('1973-12-30','1234-12-31 23:59:59','1234-12-31 23:59:59','2028-01-19 03:14:07');select * from date_time_types; 课件]]></content>
      <categories>
        <category>计算机</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>计算机：数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python：正则表达式]]></title>
    <url>%2F2019%2F09%2F11%2FPython%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Python 正则表达式 正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。 Python 自1.5版本起增加了re模块，它提供Perl风格的正则表达式模式。 re模块使 Python 语言拥有全部的正则表达式功能。 compile函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 re模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。 re.match函数re.match尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。函数语法： 1re.match(pattern, string, flags=0) 函数参数说明： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 匹配成功re.match方法返回一个匹配的对象，否则返回None。 我们可以使用group(num)或groups()匹配对象函数来获取匹配表达式。 匹配对象方法 描述 group(num=0) 匹配的整个表达式的字符串，group()可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 start() 返回开始位置 end() 返回结束位置 span() 以tuple形式返回范围 实例 1234567#!/usr/bin/python import reprint(re.match('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.match('www', 'www.runoob.com').start()) #返回开始位置print(re.match('www', 'www.runoob.com').end()) # 返回结束位置print(re.match('com', 'www.runoob.com')) # 不在起始位置匹配 以上实例运行输出结果为： 1234(0, 3)03None 实例 12345678910111213#!/usr/bin/python3import re line = "Cats are smarter than dogs"# .* 表示任意匹配除换行符（\n、\r）之外的任何单个或多个字符matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I) if matchObj: print ("matchObj.group() : ", matchObj.group()) print ("matchObj.group(1) : ", matchObj.group(1)) print ("matchObj.group(2) : ", matchObj.group(2))else: print ("No match!!") 以上实例执行结果如下： 123matchObj.group() : Cats are smarter than dogsmatchObj.group(1) : CatsmatchObj.group(2) : smarter re.search方法re.search扫描整个字符串并返回第一个成功的匹配。 函数语法： 1re.search(pattern, string, flags=0) 函数参数说明： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 匹配成功re.search方法返回一个匹配的对象，否则返回None。 我们可以使用group(num)或groups()匹配对象函数来获取匹配表达式。 匹配对象方法 描述 group(num=0) 匹配的整个表达式的字符串，group()可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 实例 123456#!/usr/bin/python3 import re print(re.search('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.search('com', 'www.runoob.com').span()) # 不在起始位置匹配 以上实例运行输出结果为： 12(0, 3)(11, 14) 实例 1234567891011121314#!/usr/bin/python3 import re line = "Cats are smarter than dogs"; searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I) if searchObj: print ("searchObj.group() : ", searchObj.group()) print ("searchObj.group(1) : ", searchObj.group(1)) print ("searchObj.group(2) : ", searchObj.group(2))else: print ("Nothing found!!") 以上实例执行结果如下： 123searchObj.group() : Cats are smarter than dogssearchObj.group(1) : CatssearchObj.group(2) : smarter re.match与re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 实例 1234567891011121314151617#!/usr/bin/python3 import re line = "Cats are smarter than dogs"; matchObj = re.match( r'dogs', line, re.M|re.I)if matchObj: print ("match --&gt; matchObj.group() : ", matchObj.group())else: print ("No match!!") matchObj = re.search( r'dogs', line, re.M|re.I)if matchObj: print ("search --&gt; matchObj.group() : ", matchObj.group())else: print ("No match!!") 以上实例运行结果如下： 12No match!!search --&gt; matchObj.group() : dogs 检索和替换Python的re模块提供了re.sub用于替换字符串中的匹配项。 语法： 1re.sub(pattern, repl, string, count=0, flags=0) 参数 描述 pattern 正则中的模式字符串。 repl 替换的字符串，也可为一个函数。 string 要被查找替换的原始字符串。 count 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 flags 编译时用的匹配模式，数字形式。 前三个为必选参数，后两个为可选参数。 12345678910111213实例#!/usr/bin/python3import re phone = "2004-959-559 # 这是一个电话号码"# 删除注释num = re.sub(r'#.*$', "", phone)print ("电话号码 : ", num) # 移除非数字的内容num = re.sub(r'\D', "", phone)print ("电话号码 : ", num) 以上实例执行结果如下： 12电话号码 : 2004-959-559 电话号码 : 2004959559 repl参数是一个函数以下实例中将字符串中的匹配的数字乘于 2： 123456789101112实例#!/usr/bin/python import re # 将匹配的数字乘于 2def double(matched): value = int(matched.group('value')) return str(value * 2) s = 'A23G4HFD567'print(re.sub('(?P&lt;value&gt;\d+)', double, s)) 执行输出结果为： 1A46G8HFD1134 compile 函数compile 函数用于编译正则表达式，生成一个正则表达式（Pattern）对象，供match()和search()这两个函数使用。 语法格式为： 1re.compile(pattern[, flags]) 参数 pattern 一个字符串形式的正则表达式 flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境 re.M 多行模式 re.S 即为’ . ‘并且包括换行符在内的任意字符（’ . ‘不包括换行符） re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和’ # ‘后面的注释1实例 import repattern = re.compile(r’\d+’) # 用于匹配至少一个数字m = pattern.match(‘one12twothree34four’) # 查找头部，没有匹配print =(m)Nonem = pattern.match(‘one12twothree34four’, 2, 10) # 从’e’的位置开始匹配，没有匹配print(m)Nonem = pattern.match(‘one12twothree34four’, 3, 10) # 从’1’的位置开始匹配，正好匹配print(m) # 返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10a42aac0&gt;m.group(0) # 可省略 0‘12’m.start(0) # 可省略 03m.end(0) # 可省略 05m.span(0) # 可省略 0(3, 5) 1234567在上面，当匹配成功时返回一个`Match`对象，其中：- `group([group1, …]) `方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 `group()` 或 `group(0)`；- `start([group])` 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 `0`；- `end([group])` 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 `0`；- `span([group])` 方法返回 `(start(group), end(group))`。再看看一个例子：实例 import repattern = re.compile(r’([a-z]+) ([a-z]+)’, re.I) # re.I 表示忽略大小写m = pattern.match(‘Hello World Wide Web’)print(m) # 匹配成功，返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10bea83e8&gt;m.group(0) # 返回匹配成功的整个子串‘Hello World’m.span(0) # 返回匹配成功的整个子串的索引(0, 11)m.group(1) # 返回第一个分组匹配成功的子串‘Hello’m.span(1) # 返回第一个分组匹配成功的子串的索引(0, 5)m.group(2) # 返回第二个分组匹配成功的子串‘World’m.span(2) # 返回第二个分组匹配成功的子串索引(6, 11)m.groups() # 等价于 (m.group(1), m.group(2), …)(‘Hello’, ‘World’)m.group(3) # 不存在第三个分组Traceback (most recent call last): File ““, line 1, in IndexError: no such group 123456# `findall`在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。注意： `match`和 `search`是匹配一次,`findall`匹配所有。语法格式为： re.findall(string[, pos[, endpos]]) 123456789参数 | 描述--|--string |待匹配的字符串。pos |可选参数，指定字符串的起始位置，默认为 0。endpos |可选参数，指定字符串的结束位置，默认为字符串的长度。查找字符串中的所有数字：实例 import re pattern = re.compile(r’\d+’) # 查找数字result1 = pattern.findall(‘runoob 123 google 456’)result2 = pattern.findall(‘run88oob123google456’, 0, 10) print(result1)print(result2) 1输出结果： [‘123’, ‘456’][‘88’, ‘12’] 12# `re.finditer`和`findall`类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 re.finditer(pattern, string, flags=0) 12345678参数：参数 | 描述--|--pattern |匹配的正则表达式string |要匹配的字符串。flags |标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志实例 import re it = re.finditer(r”\d+”,”12a32bc43jf3”)for match in it: print (match.group() ) 1输出结果： 1232433 12# `re.split``split`方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： re.split(pattern, string[, maxsplit=0, flags=0]) 12345678参数|描述--|--pattern |匹配的正则表达式string |要匹配的字符串。maxsplit |分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。flags |标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志实例 import rere.split(‘\W+’, ‘runoob, runoob, runoob.’)[‘runoob’, ‘runoob’, ‘runoob’, ‘’]re.split(‘(\W+)’, ‘ runoob, runoob, runoob.’)[‘’, ‘ ‘, ‘runoob’, ‘, ‘, ‘runoob’, ‘, ‘, ‘runoob’, ‘.’, ‘’]re.split(‘\W+’, ‘ runoob, runoob, runoob.’, 1)[‘’, ‘runoob, runoob, runoob.’] re.split(‘a*’, ‘hello world’) # 对于一个找不到匹配的字符串而言，split 不会对其作出分割[‘hello world’] 正则表达式对象re.RegexObjectre.compile()返回RegexObject对象。 re.MatchObjectgroup()返回被RE 匹配的字符串。 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置 正则表达式修饰符 - 可选标志正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如re.I | re.M被设置成 I 和 M标志： 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 参考文档 Python3 正则表达式]]></content>
      <categories>
        <category>计算机</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机：语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python：xml输入输出（lxml方式）]]></title>
    <url>%2F2019%2F09%2F09%2FPython%EF%BC%9Axml%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88lxml%E6%96%B9%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[xml简介什么是xml？xml即可扩展标记语言，它可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 XML 树结构XML 文档形成了一种树结构，它从”根部”开始，然后扩展到”枝叶”。 一个 XML 文档实例XML 文档使用简单的具有自我描述性的语法： 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt; 第一行是 XML 声明。它定义 XML 的版本（1.0）和所使用的编码（UTF-8 : 万国码, 可显示各种语言）。 下一行描述文档的根元素（像在说：”本文档是一个便签”）： 1&lt;note&gt; 接下来 4 行描述根的 4 个子元素（to, from, heading 以及 body）： 1234&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don't forget me this weekend!&lt;/body&gt; 最后一行定义根元素的结尾： 1&lt;/note&gt; 可以假设，从这个实例中，XML 文档包含了一张 Jani 写给 Tove 的便签。 XML 文档形成一种树结构XML 文档必须包含根元素。该元素是所有其他元素的父元素。 XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。 所有的元素都可以有子元素： 12345&lt;root&gt;&lt;child&gt;&lt;subchild&gt;.....&lt;/subchild&gt;&lt;/child&gt;&lt;/root&gt; 父、子以及同胞等术语用于描述元素之间的关系。父元素拥有子元素。相同层级上的子元素成为同胞（兄弟或姐妹）。 所有的元素都可以有文本内容和属性（类似 HTML 中）。 实例 1234567891011121314151617181920&lt;bookstore&gt; &lt;book category="COOKING"&gt; &lt;title lang="en"&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt; &lt;book category="CHILDREN"&gt; &lt;title lang="en"&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book category="WEB"&gt; &lt;title lang="en"&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; 实例中的根元素是&lt;bookstore&gt;。文档中的所有&lt;book&gt;元素都被包含在&lt;bookstore&gt; 中。&lt;book&gt;元素有 4 个子元素：&lt;title&gt;、&lt;author&gt;、&lt;year&gt;、&lt;price&gt;。 lxml方式:读写xml文档lxml不是Python自带的标准库。需要自己安装，如下方式安装： 1pip install lxml 读xml文档1）文档解析lxml可以解析xml的字符串，使用etree.fromstring方法，如下所示： 12345#coding:utf-8from lxml import etree xml_text = '&lt;xml&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/xml&gt;'xml = etree.fromstring(xml_text) lxml可以直接读取xml文件。 为了演示方便，找个xml文档作为例子，文件名为test.xml： 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;root version="1.2" tag="test"&gt; &lt;head&gt; &lt;title&gt;test xml document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;items id="1"&gt; &lt;source&gt;aa&lt;/source&gt; &lt;target&gt;AA&lt;/target&gt; &lt;/items&gt; &lt;items id="2"&gt; &lt;source&gt;bb&lt;/source&gt; &lt;target&gt;BB&lt;/target&gt; &lt;/items&gt; &lt;items id="3"&gt; &lt;source&gt;cc&lt;/source&gt; &lt;target id="3t"&gt;CC&lt;bpt id="3t1"/&gt;cc&lt;/target&gt; &lt;/items&gt; &lt;/body&gt;&lt;/root&gt; lxml读取xml文件的代码如下所示： 1234#coding:utf-8from lxml import etree xml = etree.parse('test.xml') #读取test.xml文件 获取属性根节点root中有两个属性，我们可以通过如下方法获取根节点和其属性： 12345678910#coding:utf-8from lxml import etree xml = etree.parse('test.xml') #读取test.xml文件root = xml.getroot() #获取根节点#获取属性print(root.items()) #获取全部属性和属性值print(root.keys()) #获取全部属性print(root.get('version', '')) #获取具体某个属性 得到如下结果： 123[('version', '1.0'), ('tag', 'test')]['version', 'tag']1.2 获取节点假如我们不知道root节点下有什么节点，可以通过循环遍历。 12for node in root.getchildren(): print(node.tag) #输出节点的标签名 得到如下结果： 12headbody 若xml文档比较大，还可以使用itergetchildren方法。该方法得到一个生成器。 这里，你可以用dir(root)可以查得节点对象有什么方法。可以获取兄弟节点、父节点等方法。 若知道文档结构，还可以使用XPath方法获取节点。 如，需要获取全部items节点。使用XPath方法得到一个元素列表，代码如下： 1root.xpath('//items') 可得到3个items元素，无论items元素的位置在哪。 我们也可以通过root和items之间的相对路径，严格得到我们想要位置的元素： 1root.xpath('body/items') 一样可以得到3个元素，不过该xpath语法要严格很多。 假如head节点下也有items元素，该语法就不会获取到该元素。 若指定的XPath语法获取不到任何元素，将返回空列表。 获取文本有些元素中有文本，这个可以通过text属性获取。 123#获取source元素中的文本for node in root.xpath('//source'): print(node.text) 另外，还有一种情况，节点和文本混合的情况。 如test.xml中id为3t的target元素。target元素中有两段文本，以及文本中间还有个bpt元素。 1&lt;target id="3t"&gt;&lt;bpt id="3t1"/&gt;CCcc&lt;/target&gt; 在xml.minidom的方法，文本也是一种节点，这个问题好解决。 而在lxml中，文本不是节点。这种情况需要通过itertext方法或tail属性解决。 先尝试获取该元素的text属性： 12345#获取id属性为3t的target元素，注意后面的[0]target = root.xpath('//target[@id="3t"]')[0] #输出该元素的text属性值print(target.text) 将得到”CC”，后面的节点和”cc”获取不到。则text属性是获取到该节点下的第1段文本。 若该节点先是一个节点，再是文字： 1&lt;target id="3t"&gt;&lt;bpt id="3t1"/&gt;CCcc&lt;/target&gt; text属性将为None。 我们可以用itertext方法获取全部文本： 1''.join(target.itertext()) 将得到”CCcc”。itertext方法得到一个生成器。该生成器是该节点下的全部文本生成器列表。 那假如我还需要获取其中的子节点，确保xml的结构的话，就需要使用tail属性。 tail属性是获取节点后的文本。我们可以先用text属性获取第1个文本，其他文本都通过子节点的tail属性获取。例如，我需要获取上面target元素的全部文本，若碰到子节点，则获取其id属性值一起拼成一个字符串。 12345678910111213texts = [] #获取第1段文本if target.text: texts.append(target.text) #遍历子节点for sub in target.iterchildren(): texts.append('-%s-' % sub.get('id', '')) texts.append(sub.tail) #合并结果print(''.join(texts)) 将得到”CC-3t1-cc”。 写xml文档模范test.xml文件，用lxml创建新的xml文档，结构和test.xml文件一致。 创建文档（节点） 对于lxml来说，任意节点都可以保存成一个xml文档。 我们只需要给该节点加入属性、内容、子节点等等即可。 那么创建节点方法如下： 12345#coding:utf-8from lxml import etree #创建标签为root的节点root = etree.Element('root') 在创建节点的同时，也可以给该节点加入命名空间： 1root = etree.Element('root', nsmap=&#123;'xmlns':'http://www.w3.org/1999/xhtml'&#125;) 在上面的test.xml中，还有两组属性。可用set方法添加属性： 12root.set('version', '1.2')root.set('tag', 'test') 当然，也可以在创建节点的时候，就写入属性： 12attribs = &#123;'version':'1.2', 'tag':'test'&#125;root = etree.Element('root', attrib=attribs) 添加子节点添加根节点之后，根节点下有两个子节点：head和body。 添加子节点有两种方法，先看方法1： 12head = etree.Element('head')root.append(head) 该方法是创建节点，再用append方法追加到root节点中。 还有一种方法，直接创建子节点： 1head = etree.SubElement(root, 'head') 推荐使用第2种方法，比较快捷。若需要写属性值，除了用set方法。etree.SubElement方法也可以像etree.Element方法一样直接写入属性。 1head = etree.SubElement(root, 'head', attrib=&#123;'id':'head_id'&#125;) 添加文本test.xml文档中，有几个地方需要添加文本。先给head添加title属性，并加入文本： 12title = etree.SubElement(head, 'title')title.text = 'test xml document' 直接给text赋值即可。 比较复杂的情况是上面提到的节点和文本混合的情况。这里同样给tail属性赋值即可。 1234567891011body = etree.SubElement(root, 'body')items = etree.SubElement(body, 'items', attrib=&#123;'id':'3'&#125;)target = etree.SubElement(items, 'target', attrib=&#123;'id':'3t'&#125;)#写入第1段文本target.text = 'CC' #写入CC后面的节点bpt = etree.SubElement(target, 'bpt', attrib=&#123;'id':'3t1'&#125;) #写入第2段文本，即bpt元素后面的文本bpt.tail = 'cc' 通过，该方法可以有条理的写入文本。 写CDATA形式123456&gt;&gt;&gt; el = Element('content')&gt;&gt;&gt; el.text = CDATA('a string')&gt;&gt;&gt; print(el.text)a string&gt;&gt;&gt; print(tostring(el, encoding="unicode")) 保存文档文档写好之后，就保存文档。保存文档这里有两种方法。 一种为通过etree.tostring方法得到xml的文本，再手动写入。这个方法过于麻烦。 常规方法是通过etree的tree对象保存文件: 123#节点转为tree对象tree = etree.ElementTree(root)tree.write('test.xml', pretty_print=True, xml_declaration=True, encoding='utf-8') 各个参数含义如下： 第1个参数是xml的完整路径(包括文件名)； pretty_print参数是否美化代码； xml_declaration参数是否写入xml声明，就是我们看到xml文档第1行文字； encoding参数很明显是保存的编码。 参考文档 XML树结构 Python读写XML文档(lxml方式) lxml-etree]]></content>
      <categories>
        <category>计算机</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机：语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium-Python基础使用和常用语法]]></title>
    <url>%2F2019%2F09%2F09%2FSelenium2.x-Python%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[selenium1.x：这个时候的selenium，使用的是JavaScript注入技术与浏览器打交道。 需要Selenium RC启动一个Server，将操作Web元素的API调用转化为一段段Javascript，在Selenium内核启动浏览器之后注入这段Javascript。 Javascript可以获取并调用DOM的任何元素，自如的进行操作。 由此才实现了Selenium的目的：自动化Web操作。 这种Javascript注入技术的缺点是速度不理想，而且稳定性大大依赖于Selenium内核对API翻译成的Javascript质量高低。 selenium2.x：相比于selenium1.x，2.x版本整合了webdriver以及原版selenium。 两个项目合二为一，虽然名字还叫selenium，但也可以叫Webdriver。 这个版本的selenium是利用浏览器原生的API，封装成一套更加面向对象的Selenium WebDriver API。 直接操作浏览器页面里的元素，甚至操作浏览器本身（截屏，窗口大小，启动，关闭，安装插件，配置证书之类的）。 由于使用的是浏览器原生的API，速度大大提高，而且调用的稳定性交给了浏览器厂商本身，显然是更加科学。 然而带来的一些副作用就是，不同的浏览器厂商，对Web元素的操作和呈现多少会有一些差异，这就直接导致了Selenium WebDriver要分浏览器厂商不同，而提供不同的实现。 本文介绍和使用的selenium2.x 安装下载 Python bindings for Selenium使用 pip命令,安装 selenium: 1pip install selenium 下载打算操作浏览器的对应webdriveselenium工作原理 graph TD 脚本[脚本] webdriver[webdriver] 浏览器[浏览器] 脚本-->webdriver 脚本-->|request|浏览器 webdriver-->浏览器 浏览器-->|response|脚本 从上图看出码输入操作给webdriver，webdriver再去控制浏览器，最终达到的效果就是代码实现对浏览器的操作。而不同的浏览器对应着不同的webdriver，各个浏览器的webdriver下载： Chrome 点击下载chrome的webdriver： http://chromedriver.storage.googleapis.com/index.html 不同的Chrome的版本对应的chromedriver.exe版本也不一样，下载时不要搞错了。如果是最新的Chrome, 下载最新的chromedriver.exe就可以了。把chromedriver的路径也加到环境变量里。 Firefox Firefox驱动下载地址为： https://github.com/mozilla/geckodriver/releases/ 根据自己的操作系统下载对应的驱动即可，使用的话，需要把驱动的路径和火狐浏览器的路径加入到环境变量里面才可以 IE IE浏览器驱动下载地址为：http://selenium-release.storage.googleapis.com/index.html 根据自己selenium版本下载对应版本的驱动即可，python的话，下载里面的IEDriverServerxxx.zip即可，这个是区分32和64位系统的，根据自己的系统下载即可，需要注意的是，如果要打开IE浏览器的话，需要在浏览器的Internet选项中的安全页里有4个安全选项，Internet、本地Internet、受信任的站点、受限制的站点，这4个里面都有一个启用保护模式，都需要勾选上才可以，还得把驱动的路径加入到环境变量中。 基本使用这里都使用chrome浏览器 声明浏览器对象12from selenium import webdriverbrowser = webdriver.Chrome() 请求页面12345# 使用get方法请求百度browser.get('https://www.baidu.com')# page_source属性用于获取网页的源代码print(browser.page_source)browser.close() 操作Cookies首先，你需要打开一个也面，因为Cookie是在某个域名下才生效的: 12345678# 打开一个页面 driver.get(“http://www.example.com”)# 现在设置Cookies，这个cookie在域名根目录下（”/”）生效 cookie = &#123;‘name’ : ‘foo’, ‘value’ : ‘bar’&#125; driver.add_cookie(cookie)# 现在获取所有当前URL下可获得的Cookies driver.get_cookies() 查找元素在一个页面中有很多不同的策略可以定位一个元素。可以根据情况选择最合适的方法去查找元素。Selenium提供了下列的方法:(返回的结果是WebElement类型的) find_element_by_id find_element_by_name find_element_by_xpath find_element_by_link_text find_element_by_partial_link_text find_element_by_tag_name find_element_by_class_name find_element_by_css_selector 一次查找多个元素 (这些方法会返回一个list列表): find_elements_by_name find_elements_by_xpath find_elements_by_link_text find_elements_by_partial_link_text find_elements_by_tag_name find_elements_by_class_name find_elements_by_css_selector 除了上述的公共方法，下面还有两个私有方法，在你查找也页面元素的时候也许有用。 他们是find_element和find_elements。用法示例: 1234from selenium.webdriver.common.by import Bydriver.find_element(By.XPATH, '//button[text()="Some text"]')driver.find_elements(By.XPATH, '//button') 下面是 By 类的一些可用属性: 12345678ID = "id"XPATH = "xpath"LINK_TEXT = "link text"PARTIAL_LINK_TEXT = "partial link text"NAME = "name"TAG_NAME = "tag name"CLASS_NAME = "class name"CSS_SELECTOR = "css selector" 通过ID查找元素当你知道一个元素的id时，你可以使用本方法。在该策略下，页面中第一个该id元素 会被匹配并返回。如果找不到任何元素，会抛出NoSuchElementException异常。 作为示例，页面元素如下所示: 123456789&lt;html&gt; &lt;body&gt; &lt;form id="loginForm"&gt; &lt;input name="username" type="text" /&gt; &lt;input name="password" type="password" /&gt; &lt;input name="continue" type="submit" value="Login" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;html&gt; 可以这样查找表单(form)元素: 1login_form = driver.find_element_by_id('loginForm') 通过Name查找元素当你知道一个元素的name时，你可以使用本方法。在该策略下，页面中第一个该name 元素会被匹配并返回。如果找不到任何元素，会抛出NoSuchElementException异常。 作为示例，页面元素如下所示: 12345678910&lt;html&gt; &lt;body&gt; &lt;form id="loginForm"&gt; &lt;input name="username" type="text" /&gt; &lt;input name="password" type="password" /&gt; &lt;input name="continue" type="submit" value="Login" /&gt; &lt;input name="continue" type="button" value="Clear" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;html&gt; name属性为username&amp; password的元素可以像下面这样查找: 12username = driver.find_element_by_name('username')password = driver.find_element_by_name('password') 这会得到 “Login” 按钮，因为他在 “Clear” 按钮之前: 1continue = driver.find_element_by_name('continue') 通过XPath查找元素XPath是XML文档中查找结点的语法。因为HTML文档也可以被转换成XML(XHTML)文档，Selenium的用户可以利用这种强大的语言在web应用中查找元素。XPath扩展了（当然也支持）这种通过id或name属性获取元素的简单方式，同时也开辟了各种新的可能性，例如获取页面上的第三个复选框。 使用XPath的主要原因之一就是当你想获取一个既没有id属性也没有name属性的元素时，你可以通过XPath使用元素的绝对位置来获取他（这是不推荐的），或相对于有一个id或name属性的元素（理论上的父元素）的来获取你想要的元素。XPath定位器也可以通过非id和name属性查找元素。 绝对的XPath是所有元素都从根元素的位置（HTML）开始定位，只要应用中有轻微的调整，会就导致你的定位失败。但是通过就近的包含id或者name属性的元素出发定位你的元素，这样相对关系就很靠谱，因为这种位置关系很少改变，所以可以使你的测试更加强大。 作为示例，页面元素如下所示: 12345678910&lt;html&gt; &lt;body&gt; &lt;form id="loginForm"&gt; &lt;input name="username" type="text" /&gt; &lt;input name="password" type="password" /&gt; &lt;input name="continue" type="submit" value="Login" /&gt; &lt;input name="continue" type="button" value="Clear" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;html&gt; 可以这样查找表单(form)元素: 123login_form = driver.find_element_by_xpath("/html/body/form[1]")login_form = driver.find_element_by_xpath("//form[1]")login_form = driver.find_element_by_xpath("//form[@id='loginForm']") 绝对定位 (页面结构轻微调整就会被破坏) HTML页面中的第一个form元素 包含 id 属性并且其值为 loginForm 的form元素username元素可以如下获取: 123username = driver.find_element_by_xpath("//form[input/@name='username']")username = driver.find_element_by_xpath("//form[@id='loginForm']/input[1]")username = driver.find_element_by_xpath("//input[@name='username']") 第一个form元素中包含name属性并且其值为 username 的input元素 id为 loginForm 的form元素的第一个input子元素 第一个name属性为 username 的input元素 “Clear” 按钮可以如下获取: 12clear_button = driver.find_element_by_xpath("//input[@name='continue'][@type='button']")clear_button = driver.find_element_by_xpath("//form[@id='loginForm']/input[4]") 通过链接文本获取超链接当你知道在一个锚标签中使用的链接文本时使用这个。在该策略下，页面中第一个匹配链接内容锚标签会被匹配并返回。如果找不到任何元素，会抛出 NoSuchElementException 异常。作为示例，页面元素如下所示: 1234567&lt;html&gt; &lt;body&gt; &lt;p&gt;Are you sure you want to do this?&lt;/p&gt; &lt;a href="continue.html"&gt;Continue&lt;/a&gt; &lt;a href="cancel.html"&gt;Cancel&lt;/a&gt;&lt;/body&gt;&lt;html&gt; continue.html 超链接可以被这样查找到: 12continue_link = driver.find_element_by_link_text('Continue')continue_link = driver.find_element_by_partial_link_text('Conti') 通过标签名查找元素当你向通过标签名查找元素时使用这个。在该策略下，页面中第一个匹配该标签名的元素会被匹配并返回。如果找不到任何元素，会抛出 NoSuchElementException 异常。 作为示例，页面元素如下所示: 123456&lt;html&gt; &lt;body&gt; &lt;h1&gt;Welcome&lt;/h1&gt; &lt;p&gt;Site content goes here.&lt;/p&gt;&lt;/body&gt;&lt;html&gt; h1 元素可以如下查找: 1heading1 = driver.find_element_by_tag_name('h1') 通过Class name 定位元素当你向通过class name查找元素时使用这个。在该策略下，页面中第一个匹配该class属性的元素会被匹配并返回。如果找不到任何元素，会抛出 NoSuchElementException 异常。 作为示例，页面元素如下所示: 12345&lt;html&gt; &lt;body&gt; &lt;p class="content"&gt;Site content goes here.&lt;/p&gt;&lt;/body&gt;&lt;html&gt; p 元素可以如下查找: 1content = driver.find_element_by_class_name('content') 通过CSS选择器查找元素当你向通过CSS选择器查找元素时使用这个。在该策略下，页面中第一个匹配该CSS选择器的元素会被匹配并返回。如果找不到任何元素，会抛出 NoSuchElementException 异常。 作为示例，页面元素如下所示: 12345&lt;html&gt; &lt;body&gt; &lt;p class="content"&gt;Site content goes here.&lt;/p&gt;&lt;/body&gt;&lt;html&gt; p 元素可以如下查找: 1content = driver.find_element_by_css_selector('p.content') 等待页面加载完成(Waits)现在的大多数的Web应用程序是使用Ajax技术。当一个页面被加载到浏览器时，该页面内的元素可以在不同的时间点被加载。这使得定位元素变得困难， 如果元素不再页面之中，会抛出ElementNotVisibleException异常。使用waits,我们可以解决这个问题。waits提供了一些操作之间的时间间隔,主要是定位元素或针对该元素的任何其他操作。 Selenium Webdriver 提供两种类型的waits 隐式和显式。 显式等待会让WebDriver等待满足一定的条件以后再进一步的执行。 隐式等待让Webdriver等待一定的时间后再才是查找某元素。 显式等待 显式等待是你在代码中定义等待一定条件发生后再进一步执行你的代码。 最糟糕的案例是使用time.sleep()，它将条件设置为等待一个确切的时间段。 这里有一些方便的方法让你只等待需要的时间。WebDriverWait结合ExpectedCondition是实现的一种方式。12345678910111213from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdriver = webdriver.Firefox()driver.get("http://somedomain/url_that_delays_loading")try: element = WebDriverWait(driver, 10).until( EC.presence_of_element_located((By.ID, "myDynamicElement")) )finally: driver.quit() 在抛出TimeoutException异常之前将等待10秒或者在10秒内发现了查找的元素。WebDriverWait默认情况下会每500毫秒调用一次ExpectedCondition直到结果成功返回。ExpectedCondition成功的返回结果是一个布尔类型的true或是不为null的返回值。 预期的条件 自动化的Web浏览器中一些常用的预期条件，下面列出的是每一个实现， Selenium Python binding都提供了一些方便的方法，这样你就不用去编写expected_condition类或是创建至今的工具包去实现他们。 所有的等待条件 title_is 标题是某内容 title_contains 标题包含某内容 presence_of_element_located 节点加载出来，传入定位元组 visibility_of_element_located 节点可见，传入定位元组 visibility_of 可见，传入节点对象 presence_of_all_element_located 所有节点加载出来 text_to_be_present_in_element 某个节点文本包含某文字 text_to_be_present_in_element_value 某个节点值包含某文字 frame_to_be_available_and_switch_to_it 加载并且切换 invisibility_of_element_located 节点不可见 element_to_be_clickable 节点可点击 staleness_of 判断一个节点是否在DOM，可判断页面是否已经刷新 element_to_be_selected 节点可选择，传节点对象 element_located_to_be_selected 节点可选择，传定位元组 element_selection_state_to_be 传入节点对象以及状态，相等返回true，否则返回false element_located_selection_state_to_be 传入定位元组以及状态，相等返回true，否则返回false alert_is_present 是否出现警告 1234from selenium.webdriver.support import expected_conditions as ECwait = WebDriverWait(driver, 10)element = wait.until(EC.element_to_be_clickable((By.ID,'someid'))) expected_conditions模块提供了一组预定义的条件供WebDriverWait使用。 隐式等待如果某些元素不是立即可用的，隐式等待是告诉WebDriver去等待一定的时间后去查找元素。 默认等待时间是0秒，一旦设置该值，隐式等待是设置该WebDriver的实例的生命周期。 123456from selenium import webdriverdriver = webdriver.Firefox()driver.implicitly_wait(10) # secondsdriver.get("http://somedomain/url_that_delays_loading")myDynamicElement = driver.find_element_by_id("myDynamicElement") 模拟浏览器进行操作在打开浏览器之后，我们往往需要在一些搜索框里输入文字，删除文字，点击一些按钮等等，这时我们需要用到一下几种方法 123send_keys()：输入文字clear()：清除文字click()：点击按钮 示例 12345678910111213import timefrom selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com')input = browser.find_element_by_id('kw')input.send_keys('许嵩')time.sleep(3)input.clear()input.send_keys('python')input.send_keys(Keys.ENTER)# button = browser.find_element_by_class_name('btn self_btn')# button.click()browser.close() 获取节点信息获取节点信息与两种方法，第一种是使用page_source属性，获取到目标网页的源代码之后，使用正则表达式，css,xpath ,bs4等工具进行抓取信息。第二种就是直接使用selenium的一些方法和属性。 获取属性首先选中要匹配解析的节点，然后调用get_attribute方法来获取节点的属性。 1234567from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()browser.get('https://www.baidu.com')input = browser.find_element_by_id('kw')print(input)print(input.get_attribute('class')) 获取文本依然是先代开网址，然后定位到目标节点，再使用text属性来获取文本 1234567from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()browser.get('https://www.baidu.com')input = browser.find_element_by_id('kw')print(input)print(input.text) 获取ID，位置，标签名和大小方法和前两个类似，直接调用即可获得相关的值 1234567891011121314from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()browser.get('https://www.baidu.com')input = browser.find_element_by_id('kw')print(input)# 获取节点idprint(input.id)# 获取节点在页面的相对位置print(input.location)# 获取节点标签名称print(input.tag_name)# 获取节点大小print(input.size) 参考文档 搞懂webdriver的底层原理，才敢说自己懂自动化！ Selenium-Python中文文档 selenium的基本使用和常用语法]]></content>
      <categories>
        <category>计算机</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机：语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考研数学第一课]]></title>
    <url>%2F2019%2F09%2F06%2F%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6%E7%AC%AC%E4%B8%80%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>考研</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python：面向对象]]></title>
    <url>%2F2019%2F08%2F20%2FPython%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[什么是对象Python 里的所有数据都是以对象形式存在的，无论是简单的数字类型还是复杂的代码模块。然而，Python 特殊的语法形式巧妙地将实现对象机制的大量细节隐藏了起来。输入num=7就可以创建一个值为7的整数对象，并且将这个对象赋值给变量num。 对象既包含数据（变量，更习惯称之为特性，attribute），也包含代码（函数，也称为方法）。它是某一类具体事物的特殊实例。例如，整数7就是一个包含了加法、乘法之类方法的对象。整数8则是另一个对象。这意味着在Python里，7和8都属于一个公共的类，我们称之为整数类。 当你想要创建一个别人从来没有创建过的新对象时，首先必须定义一个类，用以指明该类型的对象所包含的内容（特性和方法）。 可以把对象想象成名词，那么方法就是动词。对象代表着一个独立的事物，它的方法则定义了它是如何与其他事物相互作用的。 与模块不同，你可以同时创建许多同类的对象，它们的特性值可能各不相同。对象就像是包含了代码的超级数据结构。 使用class定义类对象如同塑料盒子。类（class）则像是制作盒子用的模具。例如，Python 的内置类String可以创建像 ‘cat’ 和 ‘duck’这样的字符串对象。Python中还有许多用来创建其他标准数据类型的类，包括列表、字典等。如果想要在Python中创建属于自己的对象，首先你必须用关键词class来定义一个类。先来看一个简单的例子。 12&gt;&gt;&gt; class Person(): ... pass 同函数一样，用pass表示这个类是一个空类。上面这种定义类的方法已经是最简形式，无法再省略。你可以通过类名来创建对象，同调用函数一样： 1&gt;&gt;&gt; someone = Person() 在这个例子中，Person()创建了一个Person类的对象，并给它赋值someone这个名字。但是，由于我们的Person类是空的，所以由它创建的对象someone实际上什么也做不了。接下来将 Python 中特殊的对象初始化方法 __ init__ 放入其中： 123&gt;&gt;&gt; class Person(): ... def __init__(self): ... pass __ init__()是Python中一个特殊的函数名，用于根据类的定义创建实例对象。self参数指向了这个正在被创建的对象本身。 当你在类声明里定义__init__()方法时，第一个参数必须为self。尽管self并不是一个 Python 保留字，但它很常用。没有人（包括你自己）在阅读你的代码时需要猜测使用self的意图。 接着在初始化方法中添加name参数： 1234&gt;&gt;&gt; class Person(): ... def __init__(self, name): ... self.name = name ... &gt;&gt;&gt; 现在，用Person类创建一个对象，为name特性传递一个字符串参数： 1&gt;&gt;&gt; hunter = Person('Elmer Fudd') 上面这短短的一行代码实际做了以下工作： 查看Person类的定义； 在内存中实例化（创建）一个新的对象； 调用对象的__init__方法，将这个新创建的对象作为self传入，并将另一个参数（’Elmer- Fudd’）作为name传入； 将name的值存入对象； 返回这个新的对象； 将名字 hunter 与这个对象关联。 这个新对象与任何其他的 Python 对象一样。你可以把它当作列表、元组、字典或集合中的 元素，也可以把它当作参数传递给函数，或者把它做为函数的返回结果。 我们刚刚传入的name参数此时又在哪儿呢？它作为对象的特性存储在了对象里。可以直接对它进行读写操作： 1&gt;&gt;&gt; print('The mighty hunter: ', hunter.name) The mighty hunter: Elmer Fudd 记住，在Person类定义的内部，你可以直接通过 self.name访问name特性。而当创建了一个实际的对象后，例如这里的hunter，需要通过hunter.name来访问它。 在类的定义中，__init__并不是必需的。只有当需要区分由该类创建的不同对象时，才需要指定__init__ 方法。 继承继承：从已有类中衍生出新的类，添加或修改部分功能。这是代码复用的一个绝佳的例子。使用继承得到的新类会自动获得旧类中的所有方法，而不需要进行任何复制。 你只需要在新类里面定义自己额外需要的方法，或者按照需求对继承的方法进行修改即可。修改得到的新方法会覆盖原有的方法。我们习惯将原始的类称为父类、超类或基类，将新的类称作孩子类、子类或衍生类。 现在，我们来试试继承。首先，定义一个空类Car。然后，定义一个Car的子类Yugo。定义子类使用的也是class关键词，不过需要把父类的名字放在子类名字后面的括号里 （class Yugo(Car)）： 123456&gt;&gt;&gt; class Car(): ... pass ... &gt;&gt;&gt; class Yugo(Car): ... pass ... 接着，为每个类创建一个实例对象： 12&gt;&gt;&gt; give_me_a_car = Car() &gt;&gt;&gt; give_me_a_yugo = Yugo() 子类是父类的一种特殊情况，它属于父类。在面向对象的术语里，我们经常称Yugo是一个（is-a）Car。对象give_me_a_yugo是Yugo类的一个实例，但它同时继承了Car能做到的所有事情。 更新一下类的定义，让它们发挥点儿作用： 1234567&gt;&gt;&gt; class Car(): ... def exclaim(self): ... print("I'm a Car!") ... &gt;&gt;&gt; class Yugo(Car): ... pass ... 最后，为每一个类各创建一个对象，并调用刚刚声明的exclaim方法： 123456&gt;&gt;&gt; give_me_a_car = Car() &gt;&gt;&gt; give_me_a_yugo = Yugo() &gt;&gt;&gt; give_me_a_car.exclaim() I'm a Car! &gt;&gt;&gt; give_me_a_yugo.exclaim() I'm a Car! 我们不需要进行任何特殊的操作，Yugo就自动从 Car那里继承了exclaim()方法。但事实上，我们并不希望Yugo在exlaim()方法里宣称它是一个 Car，这可能会造成身份危机 （无法区分 Car 和 Yugo）。让我们来看看怎么解决这个问题。 覆盖方法就像上面的例子展示的一样，新创建的子类会自动继承父类的所有信息。接下来将看到子类如何替代——更习惯说覆盖（override）——父类的方法。Yugo和 Car一定存在着某些区别，不然的话，创建它又有什么意义？试着改写一下Yugo中exclaim()方法的功能： 12345678&gt;&gt;&gt; class Car(): ... def exclaim(self): ... print("I'm a Car!") ... &gt;&gt;&gt; class Yugo(Car): ... def exclaim(self): ... print("I'm a Yugo! Much like a Car, but more Yugo-ish.") ... 现在，为每个类创建一个对象： 12&gt;&gt;&gt; give_me_a_car = Car() &gt;&gt;&gt; give_me_a_yugo = Yugo() 看看它们各自会宣称什么？ 1234&gt;&gt;&gt; give_me_a_car.exclaim() I'm a Car! &gt;&gt;&gt; give_me_a_yugo.exclaim() I'm a Yugo! Much like a Car, but more Yugo-ish. 在上面的例子中，我们覆盖了父类的exclaim() 方法。在子类中，可以覆盖任何父类的方法，包括 __init__()。下面的例子使用了之前创建过的 Person类。我们来创建两个子类，分别代表医生（MDPerson）和律师（JDPerson）： 123456789101112&gt;&gt;&gt; class Person(): ... def __init__(self, name): ... self.name = name ... &gt;&gt;&gt; class MDPerson(Person): ... def __init__(self, name): ... self.name = "Doctor " + name ... &gt;&gt;&gt; class JDPerson(Person): ... def __init__(self, name): ... self.name = name + ", Esquire" ... 在上面的例子中，子类的初始化方法__init__() 接收的参数和父类Person一样，但存储到对象内部 name特性的值却不尽相同： 123456789&gt;&gt;&gt; person = Person('Fudd') &gt;&gt;&gt; doctor = MDPerson('Fudd') &gt;&gt;&gt; lawyer = JDPerson('Fudd')&gt;&gt;&gt; print(person.name) Fudd &gt;&gt;&gt; print(doctor.name) Doctor Fudd &gt;&gt;&gt; print(lawyer.name) Fudd, Esquire 添加新方法子类还可以添加父类中没有的方法。回到Car类和 Yugo类，我们给Yugo类添加一个新的方法need_a_push()： 12345678910&gt;&gt;&gt; class Car(): ... def exclaim(self): ... print("I'm a Car!") ... &gt;&gt;&gt; class Yugo(Car): ... def exclaim(self): ... print("I'm a Yugo! Much like a Car, but more Yugo-ish.") ... def need_a_push(self): ... print("A little help here?") ... 接着，创建一个Car和一个Yugo对象： 12&gt;&gt;&gt; give_me_a_car = Car() &gt;&gt;&gt; give_me_a_yugo = Yugo() Yugo类的对象可以响应need_a_push()方法： 12&gt;&gt;&gt; give_me_a_yugo.need_a_push() A little help here? 但比它广义的Car无法响应该方法： 123&gt;&gt;&gt; give_me_a_car.need_a_push() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: 'Car' object has no attribute 'need_a_push' 至此，Yugo终于可以做一些Car做不到的事情了。它的与众不同的特征开始体现了出来。 使用super从父类得到帮助我们已经知道如何在子类中覆盖父类的方法，但如果想要调用父类的方法怎么办？使用super()。下面的例子将定义一个新的类EmailPerson，用于表示有电子邮箱的Person。首先，来定义熟悉的Person类： 1234&gt;&gt;&gt; class Person(): ... def __init__(self, name): ... self.name = name ... 下面是子类的定义。注意，子类的初始化方法 __init__()中添加了一个额外的email参数： 1234&gt;&gt;&gt; class EmailPerson(Person): ... def __init__(self, name, email): ... super().__init__(name) ... self.email = email 在子类中定义__init__()方法时，父类的__init__()方法会被覆盖。因此，在子类中，父类的初始化方法并不会被自动调用，我们必须显式调用它。以上代码实际上做了这样几件事情。 通过super()方法获取了父类Person的定义。 - 子类的 __init__()调用了Person.__init__() 方法。它会自动将self参数传递给父类。因此，你只需传入其余参数即可。在上面的例子中，Person()能接受的其余参数指的是name。 self.email=email这行新的代码才真正起到了将EmailPerson与Person区分开的作用。 接下来，创建一个EmailPerson类的对象： 1&gt;&gt;&gt; bob = EmailPerson('Bob Frapples', 'bob@frapples.com') 我们既可以访问name特性，也可以访问email特性： 1234&gt;&gt;&gt; bob.name 'Bob Frapples' &gt;&gt;&gt; bob.email 'bob@frapples.com' 为什么不像下面这样定义EmailPerson类呢？ 1234&gt;&gt;&gt; class EmailPerson(Person): ... def __init__(self, name, email): ... self.name = name ... self.email = email 确实可以这么做，但这有悖我们使用继承的初衷。我们应该使用super()来让Person完成它应该做的事情，就像任何一个单纯的Person对象一样。除此之外，不这么写还有另一个好处：如果Person类的定义在未来发生改变，使用super()可以保证这些改变会自动反映到EmailPerson类上，而不需要手动修改。 子类可以按照自己的方式处理问题，但如果仍需要借助父类的帮助，使用super()是最佳的选择（就像现实生活中孩子与父母的关系一样）。 self的自辩Python 中经常被争议的一点就是必须把self设置为实例方法（前面例子中你见到的所有方法都是实例方法）的第一个参数。Python使用self参数来找到正确的对象所包含的特性和方法。通过下面的例子，我会告诉你调用对象方法背后Python实际做的工作。 123&gt;&gt;&gt; car = Car() &gt;&gt;&gt; car.exclaim() I'm a Car! Python 在背后做了以下两件事情： 查找car对象所属的类（Car）； 把car对象作为self参数传给Car类所包含的 exclaim()方法。 了解调用机制后，为了好玩，我们甚至可以像下面这样进行调用，这与普通的调用语法 （car.exclaim()）效果完全一致： 12&gt;&gt;&gt; Car.exclaim(car) I'm a Car! 当然，我们没有理由使用这种臃肿的语法。 使用属性对特性进行访问和设置有一些面向对象的语言支持私有特性。这些特性无法从对象外部直接访问，我们需要编写getter和 setter方法对这些私有特性进行读写操作。 Python 不需要getter和setter方法，因为 Python 里所有特性都是公开的，使用时全凭自觉。如果你不放心直接访问对象的特性，可以为对象编写 setter和getter方法。但更具Python风格的解决方案是使用属性（property）。 下面的例子中，首先定义一个Duck类，它仅包含一个hidden_name特性。（下一节会告诉你命名私有特性的一种更好的方式。）我们不希望别人能够直接访问这个特性，因此需要 定义两个方法：getter 方法（get_name()）和setter方法（set_name()）。我们在每个方法中都添加一个print()函数，这样就能方便地知道它们何时被调用。最后，把这些方法设置为name属性： 12345678910&gt;&gt;&gt; class Duck(): ... def __init__(self, input_name): ... self.hidden_name = input_name ... def get_name(self): ... print('inside the getter') ... return self.hidden_name ... def set_name(self, input_name): ... print('inside the setter') ... self.hidden_name = input_name ... name = property(get_name, set_name) 这两个新方法在最后一行之前都与普通的getter和 setter方法没有任何区别，而最后一行则把这两个方法定义为了name属性。property()的第一个参数是getter方法，第二个参数是setter方法。现在，当你尝试访问Duck类对象的name特性时，get_name()会被自动 调用： 1234&gt;&gt;&gt; fowl = Duck('Howard') &gt;&gt;&gt; fowl.name inside the getter 'Howard' 当然，也可以显式调用get_name()方法，它就像普通的getter方法一样： 123&gt;&gt;&gt; fowl.get_name() inside the getter 'Howard' 当对name特性执行赋值操作时，set_name() 方法会被调用： 12345&gt;&gt;&gt; fowl.name = 'Daffy' inside the setter &gt;&gt;&gt; fowl.name inside the getter 'Daffy' 也可以显式调用set_name()方法： 12345&gt;&gt;&gt; fowl.set_name('Daffy') inside the setter &gt;&gt;&gt; fowl.name inside the getter 'Daffy' 另一种定义属性的方式是使用修饰符（decorator）。下一个例子会定义两个不同的方法，它们都叫 name()，但包含不同的修饰符： @property，用于指示getter方法； @name.setter，用于指示setter方法。 实际代码如下所示： 1234567891011&gt;&gt;&gt; class Duck(): ... def __init__(self, input_name): ... self.hidden_name = input_name ... @property ... def name(self): ... print('inside the getter') ... return self.hidden_name ... @name.setter ... def name(self, input_name): ... print('inside the setter') ... self.hidden_name = input_name 你仍然可以像之前访问特性一样访问name，但这里没有了显式的get_name()和set_name()方法： 123456789&gt;&gt;&gt; fowl = Duck('Howard') &gt;&gt;&gt; fowl.name inside the getter 'Howard' &gt;&gt;&gt; fowl.name = 'Donald' inside the setter &gt;&gt;&gt; fowl.name inside the getter 'Donald' 实际上，如果有人能猜到我们在类的内部用的特性名是hidden_name，他仍 然可以直接通过 fowl.hidden_name进行读写操作。 在前面几个例子中，我们都使用name属性指向类中存储的某一特性（在我们的例子中是hidden_name）。除此之外，属性还可以指向一个计算结果值。我们来定义一个Circle类，它包含radius特性以及一个计算属性diameter： 1234567&gt;&gt;&gt; class Circle():... def __init__(self, radius): ... self.radius = radius ... @property ... def diameter(self): ... return 2 * self.radius ... 创建一个Circle对象，并给radius赋予一个初值： 123&gt;&gt;&gt; c = Circle(5) &gt;&gt;&gt; c.radius 5 可以像访问特性（例如radius）一样访问属性 diameter： 12&gt;&gt;&gt; c.diameter 10 真正有趣的还在后面。我们可以随时改变radius 特性的值，计算属性diameter会自动根据新的值更新自己： 123&gt;&gt;&gt; c.radius = 7 &gt;&gt;&gt; c.diameter 14 如果你没有指定某一特性的setter属性（@diameter.setter），那么将无法从类的外部对它的值进行设置。这对于那些只读的特性非常有用： 123&gt;&gt;&gt; c.diameter = 20 Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: can't set attribute 与直接访问特性相比，使用property还有一个巨大的优势：如果你改变了某个特性的定义，只需要在类定义里修改相关代码即可，不需要在每一处调用修改。 使用名称重整保护私有特性前面的Duck例子中，为了隐藏内部特性，我们曾将其命名为hidden_name。其实，Python对那些需要刻意隐藏在类内部的特性有自己的命名规范：由连续的两个下划线开头（）。我们来把hidden_name改名为`name`，如下所示： 123456789101112&gt;&gt;&gt; class Duck(): ... def __init__(self, input_name): ... self.__name = input_name ... @property ... def name(self): ... print('inside the getter') ... return self.__name ... @name.setter ... def name(self, input_name): ... print('inside the setter') ... self.__name = input_name ... 看看代码是否还能正常工作： 123456789&gt;&gt;&gt; fowl = Duck('Howard') &gt;&gt;&gt; fowl.name inside the getter 'Howard' &gt;&gt;&gt; fowl.name = 'Donald' inside the setter &gt;&gt;&gt; fowl.name inside the getter 'Donald' 看起来不错！现在，你无法在外部访问 __name 特性了： 123&gt;&gt;&gt; fowl.__name Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: 'Duck' object has no attribute '__name' 这种命名规范本质上并没有把特性变成私有，但 Python 确实将它的名字重整了，让外部 的代码无法使用。如果你实在好奇名称重整是怎么实现的，我可以偷偷地告诉你其中的奥 秘，但不要告诉别人哦： 12&gt;&gt;&gt; fowl._Duck__name 'Donald' 方法的类型有些数据（特性）和函数（方法）是类本身的一部分，还有一些是由类创建的实例的一部分。 在类的定义中，以self作为第一个参数的方法都是实例方法（instance method）。它们在创建自定义类时最常用。实例方法的首个参数是self，当它被调用时，Python 会把调用该方法的对象作为self参数传入。 与之相对，类方法（class method）会作用于整个类，对类作出的任何改变会对它的所有实例对象产生影响。在类定义内部，用前缀修饰符@classmethod指定的方法都是类方法。与 实例方法类似，类方法的第一个参数是类本身。在 Python 中，这个参数常被写作cls，因为全称 class是保留字，在这里我们无法使用。下面的例子中，我们为类A定义一个类方法来记录一共有多少个类A的对象被创建： 123456789101112131415&gt;&gt;&gt; class A(): ... count = 0 ... def __init__(self): ... A.count += 1 ... def exclaim(self): ... print("I'm an A!") ... @classmethod ... def kids(cls): ... print("A has", cls.count, "little objects.") ... &gt;&gt;&gt; &gt;&gt;&gt; easy_a = A() &gt;&gt;&gt; breezy_a = A() &gt;&gt;&gt; wheezy_a = A() &gt;&gt;&gt; A.kids() A has 3 little objects. 注意，上面的代码中，我们使用的是A.count（类特性），而不是self.count（可能是对象 的特性）。在kids()方法中，我们使用的是 cls.count，它与A.count的作用一样。 类定义中的方法还存在着第三种类型，它既不会影响类也不会影响类的对象。它们出现在类的定义中仅仅是为了方便，否则它们只能孤零零地出现在代码的其他地方，这会影响代码的逻辑性。这种类型的方法被称作静态方法（static method），用@staticmethod修饰， 它既不需要 self参数也不需要class参数。下面例子中的静态方法是一则CoyoteWeapon的广告： 1234567&gt;&gt;&gt; class CoyoteWeapon(): ... @staticmethod ... def commercial(): ... print('This CoyoteWeapon has been brought to you by Acme') &gt;&gt;&gt; &gt;&gt;&gt; CoyoteWeapon.commercial() This CoyoteWeapon has been brought to you by Acme 注意，在这个例子中，我们甚至都不用创建任何 CoyoteWeapon类的对象就可以调用这个方法，句法优雅不失风格。 鸭子类型Python 对实现多态（polymorphism）要求得十分宽松，这意味着我们可以对不同对象调用同名的操作，甚至不用管这些对象的类型是什么。 我们来为三个Quote类设定同样的初始化方法 __init__()，然后再添加两个新函数： who()返回保存的person字符串的值； says()返回保存的words字符串的内容，并添上指定的标点符号。 它们的具体实现如下所示： 123456789101112131415161718&gt;&gt;&gt; class Quote(): ... def __init__(self, person, words): ... self.person = person ... self.words = words ... def who(self): ... return self.person ... def says(self): ... return self.words + '.' ... &gt;&gt;&gt; class QuestionQuote(Quote): ... def says(self): ... return self.words + '?' ... &gt;&gt;&gt; class ExclamationQuote(Quote): ... def says(self): ... return self.words + '!' ... &gt;&gt;&gt; 我们不需要改变QuestionQuote或者ExclamationQuote的初始化方式，因此没有覆盖它们的__init__() 方法。Python会自动调用父类Quote的初始化函数__init__()来存储实例变量person和words，这就是我们可以在子类QuestionQuote和 ExclamationQuote的对象 里访问 self.words 的原因。 接下来创建一些对象： 12345678910&gt;&gt;&gt; hunter = Quote('Elmer Fudd', "I'm hunting wabbits") &gt;&gt;&gt; print(hunter.who(), 'says:',hunter.says()) Elmer Fudd says: I'm hunting wabbits. &gt;&gt;&gt; hunted1 = QuestionQuote('Bugs Bunny', "What's up, doc") &gt;&gt;&gt; print(hunted1.who(),'says:',hunted1.says()) Bugs Bunny says: What's up, doc? &gt;&gt;&gt; hunted2 = ExclamationQuote('Daffy Duck', "It's rabbit season") &gt;&gt;&gt; print(hunted2.who(),'says:',hunted2.says()) Daffy Duck says: It's rabbit season! 三个不同版本的says()为上面三种类提供了不同的响应方式，这是面向对象的语言中多态的传统形式。 Python 在这方面走得更远一些，无论对象的种类是什么，只要包含who()和says()，你便可以调用它。我们再来定义一个BabblingBrook类，它与我们之前的猎人猎物（Quote类的后代）什么的没有任何关系： 1234567&gt;&gt;&gt; class BabblingBrook(): ... def who(self): ... return 'Brook' ... def says(self): ... return 'Babble' ... &gt;&gt;&gt; brook = BabblingBrook() 现在，对不同对象执行who()和says()方法，其中有一个（brook）与其他类型的对象毫无关联： 12345678910&gt;&gt;&gt; def who_says(obj): ... print(obj.who(), 'says', obj.says()) ... &gt;&gt;&gt; who_says(hunter) Elmer Fudd says I'm hunting wabbits. &gt;&gt;&gt; who_says(hunted1) Bugs Bunny says What's up, doc? &gt;&gt;&gt; who_says(hunted2) Daffy Duck says It's rabbit season! &gt;&gt;&gt; who_says(brook) Brook says Babble 这种方式有时被称作鸭子类型（duck typing） 特殊方法到目前为止，你已经能创建并使用基本对象了。现在再往深钻研一些。 当我们输入像a = 3 + 8这样的式子时，整数 3 和 8 是怎么知道如何实现+的？同样，a又是怎么知道如何使用 = 来获取计算结果的？你可以使用 Python 的特殊方法（special method），有时也被称作魔术方法（magic method），来实现这些操作符的功能。 这些特殊方法的名称以双下划线（）开头和结束。没错，你已经见过其中一个： `init__` ，它根据类的定义以及传入的参数对新创建的对象进行初始化。 假设你有一个简单的Word类，现在想要添加一个 equals()方法来比较两个词是否一致，忽略大小写。也就是说，一个包含值 ‘ha’ 的 Word 对象与包含 ‘HA’ 的是相同的。 下面的代码是第一次尝试，创建一个普通方法equals()。self.text是当前Word对象所包含的字符串文本，equals()方法将该字符串与word2（另一个Word对象）所包含的字符串做比较： 1234567&gt;&gt;&gt; class Word(): ... def __init__(self, text): ... self.text = text ... ... def equals(self, word2): ... return self.text.lower() == word2.text.lower() ... 接着创建三个包含不同字符串的Word对象： 123&gt;&gt;&gt; first = Word('ha') &gt;&gt;&gt; second = Word('HA') &gt;&gt;&gt; third = Word('eh') 当字符串’ha’和’HA’被转换为小写形式再进行比较时（我们就是这么做的），它们应该是相等的： 12&gt;&gt;&gt; first.equals(second) True 但字符串 ‘eh’ 无论如何与 ‘ha’ 也不会相等： 12&gt;&gt;&gt; first.equals(third) False 我们成功定义了equals()方法来进行小写转换并比较。但试想一下，如果能通过 if first == second 进行比较的话岂不更妙？这样类会更自然，表现得更像一个 Python 内置的类。 好的，来试试吧，把前面例子中的equals()方法的名称改为 __eq__()（请先暂时接受，后面我会解释为什么这么命名）： 123456&gt;&gt;&gt; class Word(): ... def __init__(self, text): ... self.text = text ... def __eq__(self, word2): ... return self.text.lower() == word2.text.lower() ... 修改就此结束，来看看新的版本能否正常工作： 1234567&gt;&gt;&gt; first = Word('ha') &gt;&gt;&gt; second = Word('HA') &gt;&gt;&gt; third = Word('eh') &gt;&gt;&gt; first == second True &gt;&gt;&gt; first == third False 太神奇了！是不是如同魔术一般？仅需将方法名改为 Python 里进行相等比较的特殊方法名__eq__() 即可。表 1 和表 2 列出了最常用的一些魔术方法。表1：和比较相关的魔术方法 方法名 使用 __eq__(self, other) self == other __ne__(self, other) self != other __lt__(self, other) self &lt; other __gt__(self, other) self &gt; other __le__(self, other) self &lt;= other __ge__(self, other) self &gt;= other 表2：和数学相关的魔术方法 方法名 使用 __add__(self, other) self + other __sub__(self, other) self - other __mul__(self, other) self * other __ﬂoordiv__(self, other) self // other __truediv__(self, other) self / other __mod__(self, other) self % other __pow__(self, other) self ** other 不仅数字类型可以使用像+（魔术方法__add__()）和 -（魔术方法__sub__()）的数学运算符，一些其他的类型也可以使用。例如，Python 的字符串类型使用 + 进行拼接，使用 * 进 行复制。关于字符串的魔术方法还有很多，你可以在 Python 3 在线文档的 Special method names（https://docs.python.org/3/reference/datamodel.html#special-method-names）里找到，其中 最常用的一些参见下面的表3。 表3：其他种类的魔术方法 方法名 使用 __str__(self) str(self) __repr__(self) repr(self) __len__(self) len(self) 除了 __init__()外，你会发现在编写类方法时最常用到的是 __str__()，它用于定义如何打印对象信息。print() 方法，str()方法以及关于字符串格式化的相 关方法都会用到__str__()。交互式解释器则用 __repr__()方法输出变量。如果在你的类 既没有定义 __str__()也没有定义 __repr__()，Python会输出类似下面这样的默认字符串： 12345&gt;&gt;&gt; first = Word('ha') &gt;&gt;&gt; first &lt;__main__.Word object at 0x1006ba3d0&gt; &gt;&gt;&gt; print(first) &lt;__main__.Word object at 0x1006ba3d0&gt; 我们将__str__() 和__repr__()方法都添加到 Word类里，让输出的对象信息变得更好看些： 1234567891011121314&gt;&gt;&gt; class Word(): ... def __init__(self, text): ... self.text = text ... def __eq__(self, word2): ... return self.text.lower() == word2.text.lower() ... def __str__(self): ... return self.text ... def __repr__(self): ... return 'Word("' self.text '")' ... &gt;&gt;&gt; first = Word('ha') &gt;&gt;&gt; first # uses __repr__ Word("ha") &gt;&gt;&gt; print(first) # uses __str__ ha 更多关于魔术方法的内容请查看 Python 在线文档（https://docs.python.org/3/reference/ datamodel.html#special-method-names）。 组合如果你想要创建的子类在大多数情况下的行为都和父类相似的话（子类是父类的一种特殊情况，它们之间是 is-a 的关系），使用继承是非常不错的选择。建立复杂的继承关系确实很吸引人，但有些时候使用组合（composition）或聚合（aggregation）更加符合现实的逻辑（x 含有 y，它们之间是 has-a 的关系）。 一只鸭子是鸟的一种（is-a），它有一条尾巴 （has-a）。尾巴并不是鸭子的一种，它是鸭子的组成部分。下个例子中，我们会建立 bill 和 tail 对象，并将它们都提供给 duck 使用： 1234567891011121314151617181920&gt;&gt;&gt; class Bill(): ... def __init__(self, description): ... self.description = description ... &gt;&gt;&gt; class Tail(): ... def __init__(self, length): ... self.length = length ... &gt;&gt;&gt; class Duck(): ... def __init__(self, bill, tail): ... self.bill = bill ... self.tail = tail ... def about(self): ... print('This duck has a', bill.description, 'bill and a',tail.length, 'tail') ... &gt;&gt;&gt; tail = Tail('long') &gt;&gt;&gt; bill = Bill('wide orange') &gt;&gt;&gt; duck = Duck(bill, tail) &gt;&gt;&gt; duck.about() This duck has a wide orange bill and a long tail 何时使用类和对象而不是模块有一些方法可以帮助你决定是把你的代码封装到类里还是模块里。 当你需要许多具有相似行为（方法）但不同状态（特性）的实例时，使用对象是最好的选择。 类支持继承，但模块不支持。 如果你想要保证实例的唯一性，使用模块是最好的选择。不管模块在程序中被引用多少次，始终只有一个实例被加载。（对Java和C++程序员来说，如果读过Erich Gamma的《设计模式：可复用面向对象软件的基础》，可以把 Python 模块理解为单例。） 如果你有一系列包含多个值的变量，并且它们能作为参数传入不同的函数，那么最好将它们封装到类里面。举个例子，你可能会使用以 size和color 为键的字典代表一张彩色图片。你可以在程序中为每张图片创建不同的字典，并把它们作为参数传递给像 scale()或者transform()之类的函数。但这么做的话，一旦你想要添加其他的键或者函数会变得非常麻烦。为了保证统一性，应该定义一个Image 类，把size和color作为特性，把scale()和 transform()定义为方法。这么一来，关于一张图片的所有数据和可执行的操作都存储在了统一的位置。 用最简单的方式解决问题。使用字典、列表和元组往往要比使用模块更加简单、简洁且快速。而使用类则更为复杂。 创始人 Guido 的建议： 不要过度构建数据结构。尽量使用元组（以及命名元组）而不是对象。尽量使用 简单的属性域而不是 getter/setter函数……内置数据类型是你最好的朋友。尽可 能多地使用数字、字符串、元组、列表、集合以及字典。多看看容器库提供的类 型，尤其是双端队列。—— Guido van Rossum 命名元组由于 Guido 刚刚提到了命名元组（named tuple），那么我们就在这里谈一谈关于它的事情。 命名元组是元组的子类，你既可以通过名称（使用.name）来访问其中的值，也可以通过位置进行访问（使用 [offset]）。 我们来把前面例子中的Duck类改写成命名元组，简洁起见，把bill和tail当作简单的字符串特性而不当作类。我们可以通过将下面两个参数传入namedtuple函数来创建命名元组： 名称； 由多个域名组成的字符串，各个域名之间由空格隔开。 命名元组并不是Python自动支持的类型，使用之前需要加载与其相关的模块，下面例子中的第一行就是在进行模块加载工作： 12345678&gt;&gt;&gt; from collections import namedtuple &gt;&gt;&gt; Duck = namedtuple('Duck', 'bill tail') &gt;&gt;&gt; duck = Duck('wide orange', 'long') &gt;&gt;&gt; duck Duck(bill='wide orange', tail='long') &gt;&gt;&gt; duck.bill 'wide orange' &gt;&gt;&gt; duck.tail 'long' 也可以用字典来构造一个命名元组： 1234&gt;&gt;&gt; parts = &#123;'bill': 'wide orange', 'tail': 'long'&#125; &gt;&gt;&gt; duck2 = Duck(**parts) &gt;&gt;&gt; duck2 Duck(bill='wide orange', tail='long') 注意，上面例子中的**parts，它是个关键词变量（keyword argument）。它的作用是将 parts字典中的键和值抽取出来作为参数提供给Duck()使用。它与下面这行代码的功能一样： 1&gt;&gt;&gt; duck2 = Duck(bill = 'wide orange', tail = 'long') 命名元组是不可变的，但你可以替换其中某些域的值并返回一个新的命名元组： 123&gt;&gt;&gt; duck3 = duck2._replace(tail='magnificent', bill='crushing') &gt;&gt;&gt; duck3Duck(bill='crushing', tail='magnificent') 假设我们把 duck 定义为字典： 123&gt;&gt;&gt; duck_dict = &#123;'bill': 'wide orange', 'tail': 'long'&#125; &gt;&gt;&gt; duck_dict &#123;'tail': 'long', 'bill': 'wide orange'&#125; 可以向字典里添加新的域（键值对）： 123&gt;&gt;&gt; duck_dict['color'] = 'green' &gt;&gt;&gt; duck_dict &#123;'color': 'green', 'tail': 'long', 'bill': 'wide orange'&#125; 但无法对命名元组这么做： 12&gt;&gt;&gt; duck.color = 'green' Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: 'dict' object has no attribute 'color' 作为总结，我列出了一些使用命名元组的好处： 它无论看起来还是使用起来都和不可变对象非常相似； 与使用对象相比，使用命名元组在时间和空间上效率更高； 可以使用点号（.）对特性进行访问，而不需要使用字典风格的方括号； 可以把它作为字典的键。]]></content>
      <categories>
        <category>计算机</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机：语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习：Python基础（下）]]></title>
    <url>%2F2019%2F08%2F08%2FPython%E5%AD%A6%E4%B9%A0%EF%BC%9APython%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本章将介绍如何组织代码和数据。Python语言是通过代码缩进来区分代码块结构。 #注释与\链接注释是程序中会被Python解释器忽略的一段文本。通过使用注释，可以解释和明确Python代码的功能，记录将来要修改的地方，甚至写下你想写的任何东西。在Python中使用#字符标记注释，从#开始到当前行结束的部分都是注释。 注释#12345&gt;&gt;&gt; # 尽管Python不会喜欢，但是我可以在这里讲任何东西 ... # 因为我被“保护”... # 令人敬畏的#号 ... &gt;&gt;&gt; 程序在合理的长度下是易读的。一行程序的（非强制性）最大长度建议为80个字符。如果你在该长度下写不完你的代码，可以使用连接符\（反斜线）。把它放在一行的结束位置，Python仍然将其解释为同一行。 链接\ 1&gt;&gt;&gt; alphabet = 'abcdefg' + \ ... 'hijklmnop' + \ ... 'qrstuv' + \ ... 'wxyz' Python的条件语句Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。Python程序语言指定任何非0和非空值为true，0或者 其他空值为false。Python编程中if语句用于控制程序的执行，基本形式为： if使用1234if 判断条件： 执行语句……else： 执行语句…… 其中”判断条件”成立时，则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。else为可选语句，当需要在条件不成立时执行内容则可以执行相关语句。 if 基本用法12345678 flag = Falsename = 'luren'if name == 'python': # 判断变量是否为 python flag = True # 条件成立时设置标志为真 print 'welcome boss' # 并输出欢迎信息else: print name # 条件不成立时输出变量名称 输出结果为： 1luren # 输出结果 当判断条件为多个值时，可以使用if、elif（即 else if）和 else: if`、`elif`（即 `else if`）和 `else`12345678if 判断条件1: 执行语句1……elif 判断条件2: 执行语句2……elif 判断条件3: 执行语句3……else: 执行语句4…… 实例： elif用法123456789101112 num = 5 if num == 3: # 判断num的值 print 'boss' elif num == 2: print 'user'elif num == 1: print 'worker'elif num &lt; 0: # 值小于零时输出 print 'error'else: print 'roadman' # 条件均不成立时输出 输出结果： 1roadman # 输出结果 Python 循环语句使用if、elif和else条件判断的例子是自顶向下执行的，但是有时候我们需要重复一些操作——循环 Python中循环类型循环类型 | 循环描述—|—while循环| 在给定的判断条件为 true 时执行循环体，否则退出循环体。for循环 |重复执行语句嵌套循环|可以在while循环、for循环中相互嵌套 循环控制语句循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句：控制语句 | 描述—|—break语句 | 在语句块执行过程中终止循环，并且跳出整个循环continue语句 | 在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。pass语句 |pass是空语句，是为了保持程序结构的完整性。 while循环Python编程中while语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为： while循环12while 判断条件： 执行语句…… 执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空的值均为true。当判断条件假false时，循环结束。 while实例123456count = 0while (count &lt; 9): print 'The count is:', count count = count + 1 print "Good bye!" 输出结果： 12345678910The count is: 0The count is: 1The count is: 2The count is: 3The count is: 4The count is: 5The count is: 6The count is: 7The count is: 8Good bye! 跳出循环while语句时还有另外两个重要的命令continue，break 来跳过循环，continue用于跳过该次循环，break则是用于退出循环。 continue 和 break 用法12345678910111213i = 1while 1: # 循环条件为1必定成立 print(i) # 输出1~10 i += 1 if i &gt; 10: # 当i大于10时跳出循环 break i = 1while i &lt; 10: i += 1 if i%2 &gt; 0: # 非双数时跳过输出 continue print(i) # 输出双数2、4、6、8、10 循环使用 else 语句如果while循环正常结束（没有使用break跳出），程序将进入到可选的else段。当你使用循环来遍历检查某一数据结构时，找到满足条件的解使用break跳出；循环结束，即没 有找到可行解时，将执行else部分代码段： while的else语句123456count = 0while count &lt; 5: print count, " is less than 5" count = count + 1else: print count, " is not less than 5" 输出结果： 1234560 is less than 51 is less than 52 is less than 53 is less than 54 is less than 55 is not less than 5 for迭代 Python频繁地使用迭代器。它允许在数据结构长度未知和具体实现未知的情况下遍历整个数据结构，并且支持迭代快速读写中的数据，以及允许不能一次读入计算机内存的数据流 的处理。 Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。 for迭代实例12345678for letter in 'Python': # 第一个实例 print '当前字母 :', letter fruits = ['banana', 'apple', 'mango']for fruit in fruits: # 第二个实例 print '当前水果 :', fruit print "Good bye!" 输出结果： 12345678910当前字母 : P当前字母 : y当前字母 : t当前字母 : h当前字母 : o当前字母 : n当前水果 : banana当前水果 : apple当前水果 : mangoGood bye! 跳出循环break和continue在for循环中跳出的用法和在while 循环中是一样的。continue用于跳过该次循环，break则是用于退出循环。 循环使用 else 语句类似于while，for循环也可以使用可选的else代码段，用来判断for循环是否正常结束（没有调用break跳出），否则会执行else段。 12345678&gt;&gt;&gt; cheeses = [] &gt;&gt;&gt; for cheese in cheeses: ... print('This shop has some lovely', cheese) ... break ... else: # 没有break表示没有找到奶酪 ... print('This is not much of a cheese shop, is it?') ...This is not much of a cheese shop, is it? 使用zip()并行迭代zip()函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。 语法：1zip([iterable, ...]) 参数说明： iterabl – 一个或多个迭代器; 返回值 返回一个对象。 实例 1234567891011121314151617&gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b) # 返回一个对象&gt;&gt;&gt; zipped&lt;zip object at 0x103abc288&gt;&gt;&gt;&gt; list(zipped) # list() 转换为列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; list(zip(a,c)) # 元素个数与最短的列表一致[(1, 4), (2, 5), (3, 6)] &gt;&gt;&gt; a1, a2 = zip(*zip(a,b)) #与zip相反，zip(*) 可理解为解压，返回二维矩阵式&gt;&gt;&gt; list(a1)[1, 2, 3]&gt;&gt;&gt; list(a2)[4, 5, 6]&gt;&gt;&gt; 使用range()生成自然数序列range()函数返回在特定区间的自然数序列，不需要创建和存储复杂的数据结构，例如列表或者元组。这允许在不使用计算机全部内存的情况下创建较大的区间，也不会使你的程序崩溃。 函数语法 12range(stop)range(start, stop[, step]) 参数说明： start:计数从start开始。默认是从0开始。例如range（5）等价于range（0， 5）; stop: 计数到stop结束，但不包括stop。例如：range（0， 5）是[0, 1, 2, 3, 4]没有5 step：步长，默认为1。例如：range（0， 5） 等价于range(0, 5, 1) 实例 12345678910&gt;&gt;&gt;list(range(0, 30, 5))[0, 5, 10, 15, 20, 25]&gt;&gt;&gt; list(range(0, 10, 2))[0, 2, 4, 6, 8]&gt;&gt;&gt; list(range(0, -10, -1))[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]&gt;&gt;&gt; list(range(1, 0))[]&gt;&gt;&gt;&gt;&gt;&gt; 推导式 推导式是从一个或者多个迭代器快速简洁地创建数据结构的一种方法。它可以将循环和条件判断结合，从而避免语法冗长的代码。 列表推导式最简单的形式如下所示：[ expression for item in iterable ]实例： 12&gt;&gt;&gt; number_list = [number for number in range(1,6)] &gt;&gt;&gt; number_list [1, 2, 3, 4, 5] 在第一行中，第一个number变量为列表生成值，也就是说，把循环的结果放在列表number_list中。第二个number为循环变量。其中第一个number可以为表达式: 12&gt;&gt;&gt; number_list = [number-1 for number in range(1,6)] &gt;&gt;&gt; number_list [0, 1, 2, 3, 4] 列表推导也可以像下面的例子加上条件表达式：[expression for item in iterable if condition] 123&gt;&gt;&gt; a_list = [number for number in range(1,6) if number % 2 == 1] &gt;&gt;&gt; a_list [1, 3, 5] 正如存在很多嵌套循环一样，在对应的推导中会有多个for语句,推导式也可以嵌套循环。 123456789101112&gt;&gt;&gt; rows = range(1,4) &gt;&gt;&gt; cols = range(1,3) &gt;&gt;&gt; cells = [(row, col) for row in rows for col in cols] &gt;&gt;&gt; for cell in cells: ... print(cell) ... (1, 1) (1, 2) (2, 1)(2, 2) (3, 1)(3, 2) 字典推导式与列表的推导式类似，其中最简单的例子就像：{ key_expression : value_expression for expression in iterable } 1234&gt;&gt;&gt; word = 'letters' &gt;&gt;&gt; letter_counts = &#123;letter: word.count(letter) for letter in set(word)&#125; &gt;&gt;&gt; letter_counts &#123;'t': 2, 'l': 1, 'e': 2, 'r': 1, 's': 1&#125; 集合推导式集合也不例外，同样有推导式。最简单的版本和之前的列表、字典推导类似：{expression for expression in iterable }最长的版本（if tests, multiple for clauses）对于集合而言也是可行的： 123&gt;&gt;&gt; a_set = &#123;number for number in range(1,6) if number % 3 == 1&#125; &gt;&gt;&gt; a_set &#123;1, 4&#125; 生成器推导式1&gt;&gt;&gt; number_thing = (number for number in range(1, 6)) 其实，圆括号之间的是生成器推导式，它返回的是一个生成器对象： 12&gt;&gt;&gt; type(number_thing) &lt;class 'generotor'&gt; 。一个生成器只能运行一次。列表、集合、字符串和字典都存储在内存中，但是生成器仅在运行中产生值，不会被存下来，所以不能重新使用或者备份一个生成器。如果想再一次迭代此生成器，会发现它被擦除了。生成器既可以通过生成器推导式创建生成器，也可以使用生成器的函数 123&gt;&gt;&gt; try_again = list(number_thing) &gt;&gt;&gt; try_again [] 函数 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。Python提供了许多内建函数，比如print()。但也可以自己创建函数，这被叫做用户自定义函数 定义一个函数可以定义一个由自己想要功能的函数，以下是简单的规则： 函数代码块以def关键词开头，后接函数标识符名称和圆括号 ()。 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式]结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 语法Python定义函数使用def关键字，一般格式如下： 12def 函数名（参数列表）: 函数体 默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。实例： 1234567891011# 计算面积函数def area(width, height): return width * height def print_welcome(name): print("Welcome", name) print_welcome("Runoob")w = 4h = 5print("width =", w, " height =", h, " area =", area(w, h)) 运行结果： 12Welcome Runoobwidth = 4 height = 5 area = 20 参数传递在python中，类型属于对象，变量是没有类型的： 123a=[1,2,3]a="Runoob" 以上代码中，[1,2,3] 是List类型，&quot;Runoob&quot;是String类型，而变量a是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。 可更改(mutable)与不可更改(immutable)对象在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。可变类型：变量赋值la=[1,2,3,4]后再赋值la[2]=5则是将list la的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python函数的参数传递：不可变类型：类似c++的值传递，如整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在fun（a）内部修改a的值，只是修改另一个复制的对象，不会影响a本身。 可变类型：类似c++的引用传递，如列表，字典。如fun（la），则是将la真正的传过去，修改后fun外部的la也会受影响。 python中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 python 传不可变对象实例 1234567 def ChangeInt( a ): a = 10 b = 2ChangeInt(b)print( b ) # 结果是 2 实例中有int对象2，指向它的变量是b，在传递给ChangeInt函数时，按传值的方式复制了变量b，a和b都指向了同一个Int对象，在a=10时，则新生成一个int值对象10，并让a指向它。 传可变对象实例可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如： 123456789101112 # 可写函数说明def changeme( mylist ): "修改传入的列表" mylist.append([1,2,3,4]) print ("函数内取值: ", mylist) return # 调用changeme函数mylist = [10,20,30]changeme( mylist )print ("函数外取值: ", mylist) 传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下： 12函数内取值: [10, 20, 30, [1, 2, 3, 4]]函数外取值: [10, 20, 30, [1, 2, 3, 4]] 参数以下是调用函数时可使用的正式参数类型： 必需参数 关键字参数 默认参数 不定长参数 必需参数必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 调用printme()函数，你必须传入一个参数，不然会出现语法错误： 123456789 #可写函数说明def printme( str ): "打印任何传入的字符串" print (str) return # 调用 printme 函数，不加参数会报错printme() 以上实例输出结果： 1234Traceback (most recent call last): File "test.py", line 10, in &lt;module&gt; printme()TypeError: printme() missing 1 required positional argument: 'str' 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为Python解释器能够用参数名匹配参数值。 以下实例在函数printme()调用时使用参数名： 123456789 #可写函数说明def printme( str ): "打印任何传入的字符串" print (str) return #调用printme函数printme( str = "cyy") 以上实例输出结果： 1cyy 以下实例中演示了函数参数的使用不需要使用指定顺序： 123456789#可写函数说明def printinfo( name, age ): "打印任何传入的字符串" print ("名字: ", name) print ("年龄: ", age) return #调用printinfo函数printinfo( age=50, name="runoob" ) 以上实例输出结果： 12名字: runoob年龄: 50 默认参数调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入age参数，则使用默认值： 123456789101112 #可写函数说明def printinfo( name, age = 35 ): "打印任何传入的字符串" print ("名字: ", name) print ("年龄: ", age) return #调用printinfo函数printinfo( age=50, name="runoob" )print ("------------------------")printinfo( name="runoob" ) 以上实例输出结果： 12345名字: runoob年龄: 50------------------------名字: runoob年龄: 35 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下： 1234def functionname([formal_args,] *var_args_tuple ): "函数_文档字符串" function_suite return [expression] 加了星号*的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。 12345678910 # 可写函数说明def printinfo( arg1, *vartuple ): "打印任何传入的参数" print ("输出: ") print (arg1) print (vartuple) # 调用printinfo 函数printinfo( 70, 60, 50 ) 以上实例输出结果： 123输出: 70(60, 50) 如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例： 123456789101112# 可写函数说明def printinfo( arg1, *vartuple ): "打印任何传入的参数" print ("输出: ") print (arg1) for var in vartuple: print (var) return # 调用printinfo 函数printinfo( 10 )printinfo( 70, 60, 50 ) 以上实例输出结果： 123456输出:10输出:706050 还有一种就是参数带两个星号**基本语法如下： 1234def functionname([formal_args,] **var_args_dict ): "函数_文档字符串" function_suite return [expression] 加了两个星号 **的参数会以字典的形式导入。 12345678910 # 可写函数说明def printinfo( arg1, **vardict ): "打印任何传入的参数" print ("输出: ") print (arg1) print (vardict) # 调用printinfo 函数printinfo(1, a=2,b=3) 以上实例输出结果： 123输出: 1&#123;'a': 2, 'b': 3&#125; 声明函数时，参数中星号* 可以单独出现，例如: 12def f(a,b,*,c): return a+b+c 如果单独出现星号*后的参数必须用关键字传入。 12345678910&gt;&gt;&gt; def f(a,b,*,c):... return a+b+c... &gt;&gt;&gt; f(1,2,3) # 报错Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: f() takes 2 positional arguments but 3 were given&gt;&gt;&gt; f(1,2,c=3) # 正常6&gt;&gt;&gt; 文档字符串程序的可读性很重要。建议在函数体开始的部分附上函数定义说明的文档，这就是函数的文档字符串： 123&gt;&gt;&gt; def echo(anything): ... 'echo returns its input argument' ... return anything 可以定义非常长的文档字符串，加上详细的规范说明，如下所示： 123456789def print_if_true(thing, check): ''' Prints the first argument if a second argument is true. The operation is: 1. Check whether the *second* argument is true. 2. If it is, print the *first* argument. ''' if check: print(thing) 调用Python函数help()可以打印输出一个函数的文档字符串。把函数名传入函数help()就会得到参数列表和规范的文档： 1234&gt;&gt;&gt; help(echo) Help on function echo in module __main__: echo(anything) echo returns its input argument 如果仅仅想得到文档字符串： 12&gt;&gt;&gt; print(echo.__doc__) echo returns its input argument 内部函数在Python中，可以在函数中定义另外一个函数： 12345678&gt;&gt;&gt; def outer(a, b): ... def inner(c, d): ... return c + d ... return inner(a, b) ... &gt;&gt;&gt; &gt;&gt;&gt; outer(4, 7) 11 当需要在函数内部多次执行复杂的任务时，内部函数是非常有用的，从而避免了循环和代码的堆叠重复。 支持类型提示python是一门动态语言，而动态语言的变量类型极其灵活，使其在做一些工具，脚本时非常方便，但是同时也给大型项目的开发带来了一些麻烦，比如过一阵子就不知道这个变量啥类型的了，而且IDE还不容易识别你的变量类型，使用.的时候不会自动提示等。自python3.5开始，PEP484为python引入了类型注解(type hints)。 例子： 12def greeting(name: str) -&gt; str: return 'Hello ' + name 在函数参数的后面用冒号加类型就可以声明该参数的类型，-&gt;代表了函数返回值的类型。 闭包内部函数可以看作一个闭包。闭包是一个可以由另一个函数动态生成的函数，并且可以改变和存储函数外创建的变量的值。以下面的例子knights()为基础。现在，调用新的函数knight2()，把inner()函数变成一个叫inner2()的闭包。可以看出有以下不同点。 inner2()直接使用外部的saying参数，而不是通过另外一个参数获取。 knights2()返回值为inner2函数，而不是调用它。12345678910111213&gt;&gt;&gt; def knights(saying): ... def inner(quote): ... return "We are the knights who say: '%s'" % quote ... return inner(saying) ... &gt;&gt;&gt; knights('Ni!') "We are the knights who say: 'Ni!'"&gt;&gt;&gt; def knights2(saying): ... def inner2(): ... return "We are the knights who say: '%s'" % saying ... return inner2 ... inner2()函数可以得到saying参数的值并且记录下来。return inner2这一行返回的是inner2函数的复制（没有直接调用）。所以它就是一个闭包：一个被动态创建的可以记录 外部变量的函数。用不同的参数调用knights2()两次： 12&gt;&gt;&gt; a = knights2('Duck') &gt;&gt;&gt; b = knights2('Hasenpfeffer') 那么a和b会是什么类型？ 1234&gt;&gt;&gt; type(a) &lt;class 'function'&gt; &gt;&gt;&gt; type(b) &lt;class 'function'&gt; 它们是函数，同时也是闭包： 1234&gt;&gt;&gt; a &lt;function knights2.&lt;locals&gt;.inner2 at 0x10193e158&gt; &gt;&gt;&gt; b &lt;function knights2.&lt;locals&gt;.inner2 at 0x10193e1e0&gt; 如果调用它们，它们会记录被knights2函数创建时的外部变量saying： 1234&gt;&gt;&gt; a() "We are the knights who say: 'Duck'" &gt;&gt;&gt; b() "We are the knights who say: 'Hasenpfeffer'" 匿名函数：lambda()函数Python中，lambda函数是用一个语句表达的匿名函数。可以用它来代替小的函数。首先，举一个使用普通函数的例子。定义函数edit_story()，参数列表如下所示： words——单词列表 func——遍历列表中单词的函数123&gt;&gt;&gt; def edit_story(words, func): ... for word in words: ... print(func(word)) 现在，需要一个单词列表和一个遍历单词的函数。对于单词，可以选择我的猫从某一台阶上掉下时发出的声音： 1&gt;&gt;&gt; stairs = ['thud', 'meow', 'thud', 'hiss'] 对于函数，它要将每个单词的首字母变为大写，然后在末尾加上感叹号 , 用作猫画报的标题非常完美： 123&gt;&gt;&gt; def enliven(word): # 让这些单词更有情感 ... return word.capitalize() + '!' 混合这些“配料”： 12345&gt;&gt;&gt; edit_story(stairs, enliven) Thud! Meow! Thud! Hiss! 最后，到了lambda。enliven() 函数可以简洁地用下面的一个lambda代替： 1234567&gt;&gt;&gt; &gt;&gt;&gt; edit_story(stairs, lambda word: word.capitalize() + '!') Thud! Meow! Thud! Hiss! &gt;&gt;&gt; lambda函数接收一个参数word。在冒号和末尾圆括号之间的部分为函数的定义。通常，使用实际的函数（例如enliven()）会比使用lambda更清晰明了。但是，当需要定义很多小的函数以及记住它们的名字时，lambda会非常有用。尤其是在图形用户界面中，可以使用lambda来定义回调函数。 lambda函数的使用当我们在短时间内需要一个无名称函数时，我们使用lambda函数。 在Python中，我们通常将它用作高阶函数（接受其他函数作为参数的函数）的参数。lambda函数与内置函数一起使用，如filter（）、map（）等。 与filter()一起使用python中的filter（）函数接受一个函数和一个列表作为参数。 使用列表中的所有项调用函数，并返回一个新的列表，其中包含函数为其值为true的项。 下面是一个使用filter（）函数的示例，它只从列表中过滤偶数。 123456my_list = [1, 5, 4, 6, 8, 11, 3, 12]new_list = list(filter(lambda x: (x%2 == 0) , my_list))# Output: [4, 6, 8, 12]new_list 输出 1[4, 6, 8, 12] filter创建一个元素列表，函数为其返回true。 该filter类似于for循环，但它是一个内置函数，速度更快。 123number_list = range(-5, 5)less_than_zero = list(filter(lambda x: x &lt; 0, number_list))less_than_zero 输出 1[-5, -4, -3, -2, -1] 与map()一起使用map将一个函数应用于输入列表中的所有项。 map(function_to_apply, list_of_inputs) 大多数情况下，我们希望将所有列表元素逐个传递给函数，然后收集输出。例如： 12345items = [1, 2, 3, 4, 5]squared = []for i in items: squared.append(i**2)squared 输出 1[1, 4, 9, 16, 25] 123items = [1, 2, 3, 4, 5]squared = list(map(lambda x: x**2, items))squared 输出 1[1, 4, 9, 16, 25] 大多数时候，我们在让lambda()和map()一起使用 我们甚至可以拥有一个函数列表，而不是一个输入列表！ 123456789def multiply(x): return (x*x)def add(x): return (x+x)funcs = [add, multiply]for i in range(5): value = list(map(lambda x: x(i), funcs)) print(value) 输出 12345[0, 0][2, 1][4, 4][6, 9][8, 16] 与reduce()一起使用函数reduce（func，seq）继续将函数func（）应用于序列seq。它返回单个值。 如果seq=[s1，s2，s3，…，sn]，调用reduce（func，seq）的工作方式如下： 首先，seq的前两个元素将应用于func，即func（s1，s2），reduce（）工作的列表现在如下所示：[func（s1，s2），s3，…，Sn]在下一步中，func将应用于上一个结果和列表的第三个元素，即func（func（s1，s2），s3），列表现在如下所示：【func（func（s1，s2），s3，……，Sn] 这样继续，直到只剩下一个元素，并作为reduce（）的结果返回该元素 12from functools import reducereduce(lambda x,y: x+y, [47,11,42,13]) 输出 1113 使用reduce确定数值列表的最大值： 12f = lambda a,b: a if (a &gt; b) else breduce(f, [47,11,42,102,13]) 输出 1102 生成器生成器是用来创建Python序列的一个对象。使用它可以迭代庞大的序列，且不需要在内存中创建和存储整个序列。通常，生成器是为迭代器产生数据的。回想起来，我们已经在之前的例子中使用过其中一个，即range()，来产生一系列整数。range()在 Python 2中返回一个列表，这也限制了它要进入内存空间。Python 2中同样存在的生成器xrange()在 Python 3中成为标准的range()生成器。这个例子累加从 1 到 100 的整数： 12&gt;&gt;&gt; sum(range(1, 101)) 5050 每次迭代生成器时，它会记录上一次调用的位置，并且返回下一个值。这一点和普通的函数是不一样的，一般函数都不记录前一次调用，而且都会在函数的第一行开始执行。如果你想创建一个比较大的序列，使用生成器推导的代码会很长，这时可以尝试写一个生成器函数。生成器函数和普通函数类似，但是它的返回值使用 yield语句声明而不是return。下面编写我们自己的range()函数版本： 12345&gt;&gt;&gt; def my_range(first=0, last=10, step=1): ... number = first ... while number &lt; last: ... yield number ... number += step ... 这是一个普通的函数： 12&gt;&gt;&gt; my_range &lt;function my_range at 0x10193e268&gt; 并且它返回的是一个生成器对象： 123&gt;&gt;&gt; ranger = my_range(1, 5) &gt;&gt;&gt; ranger &lt;generator object my_range at 0x101a0a168&gt; 可以对这个生成器对象进行迭代： 1234567&gt;&gt;&gt; for x in ranger:... print(x) ... 1 2 34 装饰器有时你需要在不改变源代码的情况下修改已经存在的函数。常见的例子是增加一句调试声明，以查看传入的参数。装饰器实质上是一个函数。它把一个函数作为输入并且返回另外一个函数。在装饰器中，通常使用下面这些Python技巧： args 和 *kwargs 闭包 作为参数的函数 函数document_it()定义了一个装饰器，会实现如下功能： 打印输出函数的名字和参数的值 执行含有参数的函数 打印输出结果 返回修改后的函数 看下面的代码： 123456789&gt;&gt;&gt; def document_it(func): ... def new_function(*args, **kwargs): ... print('Running function:', func.__name__) ... print('Positional arguments:', args) ... print('Keyword arguments:', kwargs) ... result = func(*args, **kwargs) ... print('Result:', result) ... return result ... return new_function 无论传入document_it()的函数func是什么，装饰器都会返回一个新的函数，其中包含函数document_it() 增加的额外语句。实际上，装饰器并不需要执行函数func中的代码，只是在结束前函数document_it()调用函数func以便得到func的返回结果和附加代码的结果。 那么，如何使用装饰器？当然，可以通过人工赋值： 123456789101112&gt;&gt;&gt; def add_ints(a, b): ... return a + b ... &gt;&gt;&gt; add_ints(3, 5) 8 &gt;&gt;&gt; cooler_add_ints = document_it(add_ints) # 人工对装饰器赋值 &gt;&gt;&gt; cooler_add_ints(3, 5) Running function: add_ints Postitional arguments: （3， 5）Keyword arguments: &#123;&#125; Result: 8 8 作为对前面人工装饰器赋值的替代，可以直接在要装饰的函数前添加装饰器名字@decorator_name： 123456789&gt;&gt;&gt; @document_it ... def add_ints(a, b): ... return a + b ... &gt;&gt;&gt; add_ints(3, 5) Start function add_ints Positional arguments: (3, 5) Keyword arguments: &#123;&#125; Result: 8 8 同样一个函数可以有多个装饰器。下面，我们写一个对结果求平方的装饰器square_it()： 123456&gt;&gt;&gt; def square_it(func): ... def new_function(*args, **kwargs): ... result = func(*args, **kwargs) ... return result * result ... return new_function ... 靠近函数定义（def上面）的装饰器最先执行，然后依次执行上面的。任何顺序都会得到相同的最终结果。下面的例子中会看到中间步骤的变化： 1234567891011&gt;&gt;&gt; @document_it ... @square_it ... def add_ints(a, b): ... return a + b ... &gt;&gt;&gt; add_ints(3, 5) Running function: new_function Positional arguments: (3, 5) Keyword arguments: &#123;&#125; Result: 64 64 交换两个装饰器的顺序： 1234567891011&gt;&gt;&gt; @square_it ... @document_it ... def add_ints(a, b): ... return a + b ... &gt;&gt;&gt; add_ints(3, 5) Running function: add_ints Positional arguments: (3, 5) Keyword arguments: &#123;&#125; Result: 8 64 命名空间和作用域一个名称在不同的使用情况下可能指代不同的事物。Python程序有各种各样的命名空间，它指的是在该程序段内一个特定的名称是独一无二的，它和其他同名的命名空间是无关的。 每一个函数定义自己的命名空间。如果在主程序（main）中定义一个变量x，在另外一个函数中也定义 x 变量，两者指代的是不同的变量。但是，天下也没有完全绝对的事情，需要的话，可以通过多种方式获取其他命名空间的名称。 每个程序的主要部分定义了全局命名空间。因此，在这个命名空间的变量是全局变量。 你可以在一个函数内得到某个全局变量的值： 1234567&gt;&gt;&gt; animal = 'fruitbat' &gt;&gt;&gt; def print_global(): ... print('inside print_global:', animal) ... &gt;&gt;&gt; print('at the top level:', animal) at the top level: fruitbat &gt;&gt;&gt; print_global() inside print_global: fruitbat 但是，如果想在函数中得到一个全局变量的值并且改变它，会报错： 1234567&gt;&gt;&gt; def change_and_print_global(): ... print('inside change_and_print_global:', animal) ... animal = 'wombat' ... print('after the change:', animal) ... &gt;&gt;&gt; change_and_print_global() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in change_and_report_it UnboundLocalError: local variable 'animal' referenced before assignment 实际上，你改变的另外一个同样被命名为animal 的变量，只不过这个变量在函数内部： 12345678910&gt;&gt;&gt; def change_local(): ... animal = 'wombat' ... print('inside change_local:', animal, id(animal)) ... &gt;&gt;&gt; change_local() inside change_local: wombat 4330406160 &gt;&gt;&gt; animal 'fruitbat' &gt;&gt;&gt; id(animal) 4330390832 这里发生了什么？在函数第一行将字符串fruitbat 赋值给全局变量animal。函数change_ local() 也有一个叫作animal的变量。不同的是，它在自己的局部命名空间。 我们使用Python内嵌函数id()打印输出每个对象的唯一的 ID 值，证明在函数change_ local() 中的变量animal和主程序中的animal不是同一个。 为了读取全局变量而不是函数中的局部变量，需要在变量前面显式地加关键字global）： 123456789101112&gt;&gt;&gt; animal = 'fruitbat' &gt;&gt;&gt; def change_and_print_global(): ... global animal ... animal = 'wombat' ... print('inside change_and_print_global:', animal) ... &gt;&gt;&gt; animal 'fruitbat' &gt;&gt;&gt; change_and_print_global() inside change_and_print_global: wombat &gt;&gt;&gt; animal 'wombat' 如果在函数中不声明关键字global，Python会使用局部命名空间，同时变量也是局部的。函数执行后回到原来的命名空间。Python提供了两个获取命名空间内容的函数： locals()返回一个局部命名空间内容的字典； globals()返回一个全局命名空间内容的字典。下面是它们的实例：12345678910111213141516&gt;&gt;&gt; animal = 'fruitbat' &gt;&gt;&gt; def change_local(): ... animal = 'wombat' #局部变量 ... print('locals:',locals()) ... &gt;&gt;&gt; animal 'fruitbat' &gt;&gt;&gt; change_local() locals: &#123;'animal':'wombat'&#125; &gt;&gt;&gt; print('globals:', globals()) #表示时格式稍微发生变化 globals:&#123;'animal': 'fruitbat', '__doc__': None, 'change_local': &lt;function change_it at 0x1006c0170&gt;, '__package__': None, '__name__': '__main__', '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__builtins__': &lt;module 'builtins'&gt;&#125; &gt;&gt;&gt; animal 'fruitbat' 函数change_local()的局部命名空间只含有局部变量animal。全局命名空间含有全局变量animal 以及其他一些东西。 名称中_和__的用法以两个下划线__开头和结束的名称都是Python的保留用法。因此，在自定义的变量中不能使用它们。选择这种命名模式是考虑到开发者一般是不会选择它们作为自己的变量的。 例如，一个函数的名称是系统变量function.__name__，它的文档字符串是function.__ doc__： 12345678&gt;&gt;&gt; def amazing(): ... '''This is the amazing function. ... Want to see it again?''' ... print('This function is named:', amazing.__name__) ... print('And its docstring is:', amazing.__doc__) ... &gt;&gt;&gt; amazing() This function is named: amazing And its docstring is: This is the amazing function. Want to see it again? 如同之前globals的输出结果所示，主程序被赋值特殊的名字__main__。 使用try和except处理错误在一些编程语言中，错误是通过特殊的函数返回值指出的，而Python使用异常，它是一段只有错误发生时执行的代码。 之前已经接触到一些有关错误的例子，例如读取列表或者元组的越界位置或者字典中不存在的键。所以，当你执行可能出错的代码时，需要适当的异常处理程序用于阻止潜在的错误发生。 在异常可能发生的地方添加异常处理程序，对于用户明确错误是一种好方法。即使不会及时解决问题，至少会记录运行环境并且停止程序执行。如果发生在某些函数中的异常不能被立刻捕捉，它会持续，直到被某个调用函数的异常处理程序所捕捉。在你不能提供自己的异常捕获代码时，Python会输出错误消息和关于错误发生处的信息，然后终止程序，例如下面的代码段： 12345&gt;&gt;&gt; short_list = [1, 2, 3] &gt;&gt;&gt; position = 5 &gt;&gt;&gt; short_list[position] Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt; IndexError: list index out of range 与其让错误随机产生，不如使用try和except提供错误处理程序： 123456789&gt;&gt;&gt; short_list = [1, 2, 3] &gt;&gt;&gt; position = 5 &gt;&gt;&gt; try: ... short_list[position] ... except: ... print('Need a position between 0 and', len(short_list)-1, ' but got', ... position) ... Need a position between 0 and 2 but got 5 在try中的代码块会被执行。如果存在错误，就会抛出异常，然后执行except中的代码；否则，跳过except块代码。像前面那样指定一个无参数的 except适用于任何异常类型。如果可能发生多种类型的异常，最好是分开进行异常处理。当然，没人强迫你这么做，你可以使一个except去捕捉所 有的异常，但是这样的处理方式会比较泛化（类似于直接输出发生了一个错误）。当然也可以使用任意数量的异常处理程序。 有时需要除了异常类型以外其他的异常细节，可以使用下面的格式获取整个异常对象：except exceptiontype as name 下面的例子首先会寻找是否有IndexError，因为它是由索引一个序列的非法位置抛出的异常类型。将一个IndexError异常赋给变量err，把其他的异常赋给变量other。示例中会输出所有存储在other中的该对象的异常。 12345678910111213141516171819202122232425&gt;&gt;&gt; short_list = [1, 2, 3] &gt;&gt;&gt; while True: ... value = input('Position [q to quit]? ') ... if value == 'q': ... break ... try: ... position = int(value) ... print(short_list[position]) ... except IndexError as err: ... print('Bad index:', position) ... except Exception as other: ... print('Something else broke:', other) ... Position [q to quit]? 1 2 Position [q to quit]? 0 1 Position [q to quit]? 2 3 Position [q to quit]? 3 Bad index: 3 Position [q to quit]? 2 3 Position [q to quit]? twoSomething else broke: invalid literal for int() with base 10: 'two' Position [q to quit]? q 输入 3 会抛出异常IndexError；输入two会使函数int()抛出异常，被第二个except所捕获。 编写自己的异常前面一节讨论了异常处理，但是其中讲到的所有异常（例如IndexError）都是在Python或者它的标准库中提前定义好的。根据自己的目的可以使用任意的异常类型，同时也可以自己定义异常类型,用来处理程序中可能会出现的特殊情况。 这里需要定义一个类的新对象。一个异常是一个类，即类Exception的一个子类。现在编写异常UppercaseException，在一个字符串中碰到大写字母会被抛出。 123456789&gt;&gt;&gt; class UppercaseException(Exception): ... pass ... &gt;&gt;&gt; words = ['eeenie', 'meenie', 'miny', 'MO'] &gt;&gt;&gt; for word in words: ... if word.isupper(): ... raise UppercaseException(word) ... Traceback (most recent call last): File "&lt;stdin&gt;", line 3, in &lt;module&gt; __main__.UppercaseException: MO 即使没有定义UppercaseException的行为（注意到只使用pass），也可以通过继承其父类Exception在抛出异常时输出错误提示。 你当然能够访问异常对象本身，并且输出它： 123456&gt;&gt;&gt; try: ... raise OopsException('panic') ... except OopsException as exc: ... print(exc) ... panic]]></content>
      <categories>
        <category>计算机</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机：语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作：天目云网站采集点增删改操作后的数据复查]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%B7%A5%E4%BD%9C%EF%BC%9A%E5%A4%A9%E7%9B%AE%E4%BA%91%E7%BD%91%E7%AB%99%E9%87%87%E9%9B%86%E7%82%B9%E5%A2%9E%E5%88%A0%E6%94%B9%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%8D%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[请输入密码以阅读这篇私密文章。 Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mermaid]]></title>
    <url>%2F2019%2F08%2F05%2FMermaid%2F</url>
    <content type="text"><![CDATA[Mermaid Mermaid是一款开源的画流程图、甘特图、时序图工具，她提供了一种类似markdown的语法来创建各种图。 官网：Mermaid 基本用法：Mermaid基本语法 在线编辑器：在线编辑器 NexT-Mermaid设置next/_config.yml123456789# Mermaid tagmermaid: enable: true # Available themes: default | dark | forest | neutral theme: forest # Use 8.0.0 as default, jsdelivr as default CDN, works everywhere even in China cdn: //cdn.jsdelivr.net/npm/mermaid@8.0.0/dist/mermaid.min.js # CDNJS, provided by cloudflare, maybe the best CDN, but not works in China #cdn: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js 使用mermaid.js1234&#123;% mermaid type %&#125;&#123;% endmermaid %&#125;type : mermaid chart的类型 实例流程图 书写 123456&#123;% mermaid graph TD %&#125;A--&gt;B;A--&gt;C;B--&gt;D;C--&gt;D;&#123;% endmermaid %&#125; 显示： graph TD A-->B; A-->C; B-->D; C-->D; 时序图 书写 1234567891011121314151617181920212223&#123;% mermaid sequenceDiagram %&#125;participant Aliceparticipant Bobparticipant John as John&lt;br/&gt;Second LineAlice -&gt;&gt; Bob: Hello Bob, how are you?Bob--&gt;&gt;John: How about you John?Bob--x Alice: I am good thanks!Bob-x John: I am good thanks!Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row.Bob--&gt;Alice: Checking with John...alt either thisAlice-&gt;&gt;John: Yeselse or thisAlice-&gt;&gt;John: Noelse or this will happenAlice-&gt;John: Maybeendpar this happens in parallelAlice --&gt;&gt; Bob: Parallel message 1andAlice --&gt;&gt; John: Parallel message 2end&#123;% endmermaid %&#125; 显示 sequenceDiagram participant Alice participant Bob participant John as JohnSecond Line Alice ->> Bob: Hello Bob, how are you? Bob-->>John: How about you John? Bob--x Alice: I am good thanks! Bob-x John: I am good thanks! Note right of John: Bob thinks a longlong time, so longthat the text doesnot fit on a row. Bob-->Alice: Checking with John... alt either this Alice->>John: Yes else or this Alice->>John: No else or this will happen Alice->John: Maybe end par this happens in parallel Alice -->> Bob: Parallel message 1 and Alice -->> John: Parallel message 2 end 甘特图 书写 1234567891011121314151617181920212223242526272829&#123;% mermaid gantt %&#125;dateFormat YYYY-MM-DDaxisFormat %d/%mtitle Adding GANTT diagram to mermaidsection A sectionCompleted task :done, des1, 2014-01-06,2014-01-08Active task :active, des2, 2014-01-09, 3dFuture task : des3, after des2, 5dFuture task2 : des4, after des3, 5dsection Critical tasksCompleted task in the critical line :crit, done, 2014-01-06,24hImplement parser and jison :crit, done, after des1, 2dCreate tests for parser :crit, active, 3dFuture task in critical line :crit, 5dCreate tests for renderer :2dAdd to mermaid :1dsection DocumentationDescribe gantt syntax :active, a1, after des1, 3dAdd gantt diagram to demo page :after a1 , 20hAdd another diagram to demo page :doc1, after a1 , 48hsection Last sectionDescribe gantt syntax :after doc1, 3dAdd gantt diagram to demo page : 20hAdd another diagram to demo page : 48h&#123;% endmermaid %&#125; 显示 gantt dateFormat YYYY-MM-DD axisFormat %d/%m title Adding GANTT diagram to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h git分支图 书写 1234567891011121314151617&#123;% mermaid gitGraph: %&#125;options&#123; "nodeSpacing": 150, "nodeRadius": 10&#125;endcommitbranch newbranchcheckout newbranchcommitcommitcheckout mastercommitcommitmerge newbranch&#123;% endmermaid %&#125; 显示 gitGraph: options { "nodeSpacing": 150, "nodeRadius": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch 参考链接Mermaid]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
        <category>NexT</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年9月-12月学习计划]]></title>
    <url>%2F2019%2F08%2F02%2F2019%E5%B9%B49%E6%9C%88-12%E6%9C%88%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[gantt dateFormat YYYY-MM-DD title 2019年9月-12月学习计划 section 9/6-9/17 Python（16讲）（工作日每天一讲，休息日每天两讲）:2019-09-06, 12d section 9/18-9/29 MySQL（14讲）（工作日每天一讲，休息日每天两讲）: 2019-09-18, 12d section 9/30-10/1 数据结构与算法：基础（4讲）（工作日每天一讲，休息日每天两讲）: 2019-09-30, 2d section 10/2-10/23 数据结构与算法：进阶（30讲）（工作日每天一讲，休息日每天两讲）: 2019-10-02, 22d section 10/24-12/7 商业数据分析（57讲）（工作日每天一讲，休息日每天两讲）: 2019-10-24, 45d section 9/6-12/31 数学课本+基础+1000题（每天晚上3-4则）: 2019-9-6, 116d section 9/6-11/10 英语语法+1500题（休息日每天两则）: 2019-9-6, 64d]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel函数]]></title>
    <url>%2F2019%2F08%2F01%2FExcel%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Left()与LeftB():含截取到倒数指定字符如果要从左边开始截取字符，在Excel中，可以用Left()和；其中Left()是按字符个数截取，LeftB()是按字节个数截取；它们的区别在于，Left()把每个汉字算一个字符，而 LeftB()把每个汉字算两个字节；每个数字和字母，它们都算一个。 语法 Left() 表达式：LEFT(text, [Num_Chars]) 中文表达式：LEFT(文本, [截取字符个数]) LeftB() 表达式：LEFTB(text, [Num_Bytes]) 中文表达式：LEFTB(文本, [截取字节个数]) 说明： Num_Chars为可选项，若省略，则默认截取一个字符。Num_Bytes也为可选项，若省略，则默认截取一个字节。 Num_Chars必须大于等于0，如果Num_Chars大于文本长度，则返回所有文本。Num_Bytes也必须大于等于0；若文本全是中文，Num_Bytes大于等于文本长度的两倍，则返回把有文本；若文本由字母或数字组成，Num_Bytes大于等于文本长度，则返回所有文本。 使用方法及实例 Left() 假如要截取3个汉字。选中E2单元格，输入公式=LEFT(B2,3)，按回车，返回“蝴蝶结”三个字，操作过程步骤，如下图所示： LeftB() 把公式=LEFTB(A1,5)复制到B2单元格，按回车，则返回Excel；双击B2，把公式改为=LEFTB(A1,10)，按回车，则返回“Excel 2016”；操作过程步骤，如下图所示： 从两次返回结果可以看出，LeftB函数把字母、数字和空格都当成一个字节。 Find()与FindB():返回指定字符位置在Excel中，查找指定字符在源字符串中的位置，既可以用Find()，也可以用FindB()，它们都有三个参数，所不同的是，前者把汉字、字母和数字都算一个字符，后者把汉字算两个字节，数字和字母算一个字节。 语法 Find() 表达式：FIND(Find_Text, Within_Text, [Start_Num]) 中文表达式：FIND(查找文本, 源文本, [查找开始位置]) FindB() 表达式：FINDB(Find_Text, Within_Text, [Start_Num]) 中文表达式：FINDB(查找文本, 源文本, [查找开始位置]) 说明： FIND和FINDB区分大小写，并且不允许使用通配符。如果希望执行区分大小写的搜索或使用通配符，则可以使用 SEARCH和SEARCHB函数。 如果find_text为空文本 (“”)，则FIND会匹配搜索字符串中的首字符（即编号为start_num或1的字符）。 Find_text不能包含任何通配符。 如果find_text未显示在within_text中, 则FIND和FINDB返回#VALUE!。 如果start_num不大于零, 则FIND和FINDB返回#VALUE!。 如果start_num大于within_text的长度, 则FIND和FINDB返回#VALUE!。 可以使用start_num来跳过指定数目的字符。以FIND为例，假设要处理文本字符串“AYF0093.YoungMensApparel”。若要在文本字符串的说明部分中查找第一个“Y”的编号，请将start_num设置为8，这样就不会搜索文本的序列号部分。FIND从第8个字符开始查找，在下一个字符处找到find_text，然后返回其编号9。FIND始终返回从within_text 的起始位置计算的字符编号，如果start_num大于1，则会对跳过的字符计数。 使用方法及实例 数据 A 2 Miriam McGovern 公式 说明 结果 =FIND(“M”,A2) 单元格 A2 中第一个“M”的位置 1 =FIND(“m”,A2) 单元格 A2 中第一个“M”的位置 6 =FIND(“M”,A2,3) 从单元格 A2 的第三个字符开始查找第一个“M”的位置 8 参考文章 微软支持-Excel-公式和函数 Excel Left函数与LeftB函数使用方法，含截取到倒数指定字符实例]]></content>
      <categories>
        <category>工具</category>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作：天目云租户转成品库采集点增删改自动化查询]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%B7%A5%E4%BD%9C%EF%BC%9A%E5%A4%A9%E7%9B%AE%E4%BA%91%E7%A7%9F%E6%88%B7%E8%BD%AC%E6%88%90%E5%93%81%E5%BA%93%E9%87%87%E9%9B%86%E7%82%B9%E5%A2%9E%E5%88%A0%E6%94%B9%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[请输入密码以阅读这篇私密文章。 Incorrect Password! No content to display! U2FsdGVkX1+SblTDxvr50Y9eE4H/+cTFLFTSZ6gkmwk/SlAoaaQ9grP8AciifVczYQd/lo5aTxn79Ga1qrWxXV9A31597TdtZOSTYMYq6qsTpN3Rl8irsrfxfbU2JCXvED//TFyP6L9/9ojmGD5YarNV7p0aA/yux5v+Jnc4VbwrTmIvfcnpvdhq/ruF+iH9a7gNSqIMy6teJyLaA044Bf2LHz30+oivHeyhjnYIzybySL/JlwYe+M/CUbhyw0wOSCKXbhfcohgM0wTIuQBvZaYGxXHsMvzqcEGL42wVAsUCHxKRywi7goyFwtDcEsanfy2TVgEWAWH+Hmm2TQ4oZN3y2+sJjAusVRboHsGpe+dNEseTQKErUJYymoag+IqzQVUwVAiH63dHf1Rtbt9phGHcNXRL/g1fC+TNC/dN4FkpuWokHPQ+Z8XiwVKOn7KgwKb7P1fz5QfqmeZwK/iUFSheeo6yu+hgeOmk92IPjKjIWrxU1JFETSWW/H6R/DYsKneqEPoKwrMzSGj49HEsVSKmWtaw4oSRms6umHtKpGIdHfxJPRwUSz4hMwVh5xN6cGvxdS6BTcshUGnAhfk4QEV25BRJaKmWUGy7JQc05FIf+lvLMPdDN6++C1bN6+8AytPp7uZ1M6Wr5Zx4LKGD2TyAhLUeKS0FVi/DfLRF5XWGYnMEWEn8fKhdpjCPJ5yphCDewwuvjez9af7YHgM9aFwvmmE8HX1yLeZGucUxpNJLX09KPtdNwgy5hgsRK2vSR4E2sVyjX4BhIxiXyxxAn2KNpFywlOF9OL0XJM+pJ+JJKHF1j9V5eUIJtKIugfAXqfSySpchpLrNr5yON52ylmcCbxIjZazFc58wQkyldgXG441TULhVC9yyY5t0gLil8DahbL5sb9CNiSM77HOiJUNQbTcSWeyXZ/ySDxfmknqlMI6EgfMGmprH4sbchZPHZPmWTUE5lqQ2Ze5nLv2cNIfEGWy0m6skaOP4BMnk72rLPniF2cznDlZnBECLf68jR/OqLTFRJJ7EYka9bzCKaXgLat5JkFENaIfguhkcr4JH8AS50YrqjFZLEltRL9NfISczFmbnYu4OoZjNyWQ/fibqU2J9y04swrcNjoDiWhCYdf1hMoWGV91bxECWoHO1zSugU3hbsjRQiRstE6i9wiDNbsOCTwtCrchdb0gwnQkCIM9PnOunRh9qpnu8EZvzi+DE1MhCm9tdWyBTTbVVApZ/8WRuAFs2QX0wjAmc0eAWqv7Apdz/ZhEUaajbZJfRGOpR9y0MkwhtbDZE8vx0oG+NuEaI1cjCCw+lLxWyo1gPuUkK5fqe6g0ALLAd7RYUryXpo+5UdDWefkdAx2KLqugdqDJh/owqTmY5uD9ZWO58DKSeE2eUVJPdaXGARCoCZBCrM1LilNfCKEZLhNLCnipAMZf4A6nfuiMeZ2xcZGWcWt+7KAp+KpDo8HBlw60L5c+RGCrk0xgU61oHUwh10J8lJ7LL4jKRSPqWET7KPzyXPqf+5nWhX9iKcpCgYvqZOiT4NyY5Lq39HZ3U/NbwF8ueMj7Nsv23rGajW5H6V6EqLXzXC4IdqbFu5BzDp1oTwNzAJN/YmQQnDd9MZPt4ArAQvIOyfjiA0zFz0+ZivP69IdEfWFL1Gp7WN3mxH50WeNebw9tZZHSkr5WWtaWEFx7QYG1CVJ17XknL1RUumprk2m03MCANpHPEgjtaXqPBWbwBIK9ElqQusQ8DkGC+UQ8Jmc4jKx13jb6svKVCsG7hMAYrnHE4FJo3Vm4gJiFvMIdySfho2iBL+cYN+bEe/G66I0o15BPup/TQwQ/MtGkoaMNt97zxVgCB/BTkARBpzG1NaAcKjTnufZzLAmqHWHFuEFGfPNFDm97sKUxj+8ok93VSP8IKyzY03ytEvh9X5aXdKdg/Kst4BEj47Qqzwpoh1OeBnXNxIZXvmb8QdzgIJYo+cGCsE3AK6JsoGLmZT99H7NHT3tAjtxufuHkvyQu5Np8DAndsBUgufdaadqZUiOUXdJ4KLs48tE+ulkJf3WCEs9Dopg2orBvbovDrvG7TSItByeZHHzk5WGCmNxYldm+m3qyhG0yDrf+1Ap4oWonAxBkF+0y6CMiNSa/IUWFvAviyBs55aKi44fsBA0CH4VX2zMfLs72X++toitzS+nwnIwg/9j2etrfwsG9mBw5oN6gr9JhVdgX6379dfEUiqHFcFEtPNET0AZnfuNWBbICuoR4QD+icUCD342k1wx/R+G9SGm/AuwkkyIKgjEyWgzWvqDe/QdZnDWOlpOz6ZuKRNT4Qj+U+NJxIo+a5GgPisQs6QVp2a6t1k6fHhUEFUsVH1B9R9zW3QsqJOsgMkLqWg5gEK3z3jewwvp9XtptLkKo/LX7Ypy9jEsdVijP0QYjCjk58rcuxT0G1WtsXuNRrnCgNVmZY8WkrAwWBGLRrbA/qx05f9YkMyReL148BSwyemhCUrnssRK5LXs00Rm+1tKhJI+CgKK/rJRV9YbRJvn1FhvgNlzojqz/fEmhuVYxMUMn1pfdrb/RbMschdsadrabbYkRtDC9iDN5b8LymbvjDIpKRqzWXlA1mBcYw0TCAgOcF9hhOs/suQvjmyjaTvvmn3IThfRo14HNOTTh//SYrPuGmTSR7SseYBDhwwvmY8ObOLXKO53/Suc7aic5fOryq2FaqD2Bsg5Mi5p2jZcLFXEevl/yXoaU7DDDLRSPVtFpjwtEglyZkL00kX8qUk4fEM7sSb2kNr76ZLT4wa9LDdANRl487PeZ4IbBLVZ4k7sgrhZzUDczz2/DoKkCoIHwlHZBltmIH113JVJswd6Y2Sty59haT6vFwDY3NXayjlOYR3TSalNZ0ka55jKhJ5eRsFNPFezbC3W9HRuN6bSMA9z5m73FA9+miq5eIFb1/XukQoElsib+9xyrtEGqYnEmsniqujO0z03O84MLc5SbLLq/yPoxzLIsp+AhcqDz6u6KVsOIaq4Fop1LD6BnJ3aaTEv0eOi6GYqc5BGQrKRWw1PnzRYq5KcUqU947t5cKHFfngXMJFSbSzmbsVsshCzOnO42+TFpAZggMNVmrj/vzJaCRtxMrzhEkE4q2CyCswlW5bPgV3WeVMWkrg9LJnjN8uuCY7N+a5aqHpuzPU1TXR68XOngUKqPODqXOAcIOTpHsmjvOgINVBNFBKERsTxvBQW1Y7IkUM0ix37iROOchf7LbklZ7m4qffIzlRQSmvTAQA+dUOzVI9/K8sOK5XdG9q35ghF8FhTPyVeb36UdEPCDBfB720oRMb9Ppu8ModfMenr22FPTdInZ11+RVcSEGZgrGSLfXzq3fWetehAfQK+WpPxExU0udFg/F/Z5lC4FaKOjWfR4VZubwNEbUWTkSpQMkdNPyrcPv4hy/9AAn9MaT+bqEdt4K5fL7S19FREkGwzHziAZxwHYUqoiZuIpVUS/pHI9iOb11QeNEIN8DmK2RblZazcabUXt8M6Kaf+DM6yLDvIMYOx4QVw/WQSruvzs65ngo+W6GrOx13awIMeU2Bop3MkGmoxfcyHvAmEGZpJ3H3yKNmmiSM9P2MBR13u2z5clvWyyMRH9SFJBiMkx2Zv/T2JMQWXmGs6LXjtM4UYv9hjYESjPoadHZC0X7eYB/T8415rHDlfjkfVMjKHzig5XTqbQFo7NkjntHq8V2BLegGEMLztuv6JGoahuRamnV9E95OvGhC1jif112KLqGv737+/eoiNtBVSNbGdYRnI1CneXImP4XA5g8duWVtagErwlsLheJDD08lhrSw/we0EUTqGSKDT7Yf0Re9L0GD/jlSRGpq9w1qxx9UJqbKj683yJ9UvrWKowu8MWEnJWOa4SmbPrLm6AlGf8gXwxT7ssqCVc2DSYeZUl/WiTcsMqpM2M3/BHOdL5vdecFg38UihH4Bq/kb6HfLo1OE7d1DalyCNyoYp5afx1v/TJD6jYhR2tPDZtSdYV5/wPKF/3GAjqqkPSjTyUqkXqjjiI9GV5duPkYcKM3Tu0EPK4f8ET3T2cH5uVxOqm9oKl/01/mAU7G85aqJrS/x8gk1TkpBbV2Ers0u0igKFCPSWIylW9y8LqnzWo2aThc6ObmdeMNCBjRpIxvgqqTDK2iDXN5W6rfy0DpUwtiarIA+b72lJ+J6OqOY+mFSrGhM7kJ/YgrdtZsZsKDKSf9DVt+EDWBLd4A/yZhnz7NwOYtMsvm+WtJq52c7q4wWsW8kiU9ZCzE4xllCF8yaFgOItaPnI2mMuNnQA5hUGJHP1l3/tn4oZt9Xqp3TS6yn5yKPEpwA3ChnWoKX0qQKzfa/IV5Vo3IVEqXQ4DZ7onMtu2s9hHve85c+2ZiM/SpyDl0ywRy7MciOMuPPsY3WsXfHfgk/LR8tBfppIwdKOckMqyphSsJ4Pr4Z1tCbURJakos14kLTDUoWNRGKckYIRsMN//ZB820jLtaWFr3vcyQ3RocKb9tya7EM6tRxhf9BdIIigHGHLmCCk4Yo9VnB27W775nbfKbT8q0mKiOMLf1JvV94Rf6qIcg/gZ0RWSkQlHr7KQzu9ksJqO/bwpY4ZUoqP/ScjvIwtoZyzew0X8z66obJXJF/1DDfQhxc6kPJZ8FvTPyw7gSfhTezndJvnm59JUMTTMumWMJuRHv3YjUz4D/z73VLzd09yp2TcGzSwXntSBSez2wfjLYP8iMnHzpwZP6oaO8vaCrEEIW1sQMIRqPqzh+PCKMIgcXk9TvymdrkqIzL8NGY0ajJvgH6anpO/ewFPjOnX2yZRb7+WSw4nn5SYw50Xt5UyDGZB1239unIw+FR6QnVPvVlXHqzllfAX73duuTpbAfQgGpIYyWHSL67t+GDmySAlqa+6kiHiwxS+qc1/VBM/ECN0F31YbYM1A/ixEccDrUF5QtWzny7cb43u6qoRTOe+v4Kw63dKYy0B/kmBslppFALFTIt5pCqH7xsLQorZS2y7vktdAQZX8bU448koy4RDncQgxeMU3sB1yams3EwI6UFKWzrrUKLwlKH+7hhpwq6vscoUfJXBw5CPUi9Xvt5SxdWShJfkE8ALbOG/KvKrCkD8kn9ZnVkUqo0EfUaPzpz5vpLnc3bDH81GkM91D/ImtbNvycKnlZUJwN8A2Q9KMJtH6wNdEguvniHRkO3m1nwBBtBbC7tJDOQ/HYYaxQRY0SF/xMgNsebJwxMdTH3Fj20r5x1XQoSQlkEaZWBf2mxmSunzypZiyISLWE/UL+/1n1yHkl/jTps2L0OCVk8zzwidJ6mVIaWuugVZw+z/cwndYy5/LxLTLiG6ZA1wSy8Ky9hbb3bkadJ0Z9T+w0t62PzKy/nBxlrvxK5udXu4d41MoHwW/jT1UuHYbc4ij4mn+YYZCvQ4b1sQScCPB1DTkow+wA2xBA4jRGWOrPUCxTxnApLYeXcgYvx0T/Zelyzg8zcyBcvlNVMumyuAJJr/OqDUhN28PgCn8xEMOE233ZGk3LZFMyRUnHzt7lTjsd8KnA0V1dzIEdJQKk43yFfWWUB2tFQp0PPTFz/GZ7kYKVGz9dbTiDI7p7ZOg+ZwQ707jx5aR2TV8pXwjKo4WUFGU+W2RD0wEWiiQCeWmDpo52pXP/C8tYX2FL+SGBm7Rro7gU2DNSAZDzu32UwQasfI54ZXrAobAsy3Aq2uAF7EaZHLQ+AfwgtXSKHILzIJAY2qPxHYv8oqS7kBz0wg2aSwc/mS0oLGin8QStOkYCXTWwpFsTv+iKm/kBYaDT/EgqfGhuWmkg3lb4d5U2rPimof+5UnaLwXZ+SkEHpJpha3JuB4IorKTFE0ZHFIUYAK1x+N0FyR0AjQno3Wpx5mhf7JEAT38Dpn05pd2ucEhIc9P/S/ZBPkZsFXR4iR2cR2qJlHpgfksp2CsAVZKnKv0RokMCvqklC7Ej4N11nZr4B75XS9R/8zwwDlGchdDg5JBQka4BDo5gygUZEFiAnS2XR6x7nicZqFLfSvaM6Dzc4hGKi87VS+Ed99yC4Lo2gFM2UgiVO8S48iDZ7EkLGrFf95sULAnPnhefgIIzGcs0zo3GVsVcmliF7fHjVEATjUvlHz9TAbRzeU31bzydAtMPBCEpFmZyVystUN6gWSwwxokRze6pB7JrKQzfTMCrBr6zJI34m33scyUpcQR8lFblClVMBQJ5QlSYLcyLUgXzdT+mVzdD4iVw1HunSjRhWqLF9ET45JyciA0UzgPtrrHfSdLxpAp1P2w1eZycCyAEeE4ZrO+SG/Sf1aoEG43ukdcdq95bX3CzDnGdkD3LhC2OMskiCa2T9kKhs52SnQWsdA5cfJ2YhhlPRnTo9AniSGctuBWlBCrLOaBY4rfnQ8mm782twA0LYmhJCFGzTFpUX51rcy86vhmpYeKFxYplE67yN4vWt0pppAK+XH1zf6P4Z1LJFHF0YkoZfQdlkaiXjd/v7MVgs5UwbarnYzT+Xq5qZGbiuCZY+6oQyk5ob0UbqOvPNXYAcAwlz0HQa8glJ4W9IO/cnX/PjxMKIT8JG+KsJLqm9UiobH230SQ72IDCo9pILZzdNlIGNzYukSyXW3asl1EtPT0DaFXIF9O5eHTiIMWKMslhPZwQvnzZlsXOfVD4OGw7eSQGNR+r4bC4dliZpMDuFBIli0VmJvppg/Lfy45loWvkrllsHK5S/AJK/Ku7Bz4gC6jgXzUxrHBCnN0A+mEuHAn+IVU/yVu14ZwzA14HBru2xrRhT2xwY8XDfxoUTCOE6kJDOxvtnG/bgWK53JaV+vGk0Q7twvBvWmnDo9o7uK99AvVPuQMyM/IiHmt40mYxOhQJVJzFWjmgT8mSycg9GpmW28va8r7+iW7J7LeVOcBFcWGFJxFxr0f/+O4yZdzX7OIex6xYHdgdrV1lQDy+13V7SzFfzdu7YNmGJg38FLr9h/MWL2gdu8kODDmVA5vNjkr72hyxjZ6n+RgfAOBpY1Npb3uDnwS5zXSQ2H8swZEIGsjHkCAapOCIHpXcioDTivtu51Hqyu8GQAm+KXFBnOxgcJS7X4Cy42FpYLXy+OU4rA+1zkqCOcGllIQyyIPX5dUQgdIK/ysSAuIQt+po9B3hI39M9y7QNRWlLNIZH7KAnP8zKZfbCU0Ck94ivmYwMOOJJ0dqzbR452Gc7fNSfC64MyvDu6bvqyo/EAUoRpv7UQIjJRgCzyZ5Wai546zjU6/G/qJbP91x0r6YzP36wxwOC25KjGwI5VbX2pfdV8qkX3PMQN6M9TzsKtR9m3ehhpb+f0YHMclzMJJ//o9T0fh/fM8QUqKvNIdP6zvV7s69BsBdIgRdZWJfAM9xe3lHnqneeUosoudOvgKHyVbPPWf+FQUX3pEnkd7mzyV7zKusalnUUpZMm19zQ0CJ5M3fgzB/m+cec6Bd4XYRU895kBYTDipnwSX92DpdOM5MaAu1EI52rmIGLpXeulSmLW7p2Qyf6pPMj5CnT5kD/q1X3A5KKgH7xzEVS8xBjhvuL2IMOLmpYUYJd1VdSjx0FFC6VS+tlpdfO+9/BsNG4y27hlUQl3UxSZODR/qlXPbeQ2+pgdranyY+hKKus+Rmhkev61vCpEiena7H9mhoYJlo/0sHs8EJaIChhS65jPV+ZGZt2ApAXq6y8dgOF64XKObUqYPZdKT+FeABc1wMTdUsPf2LZCtmPA4d0/yqUPt5LHM5uXNdIH55KaCDaMvy8bSasDmYZ4snwDOAg0TiZpzqAzwXot3BvKRVQ9tm7Jn16uR4PHTxnPAhs6r7mr1ToTGptHsU9IQV9tHOAJhS/F4X92CjpCBCu3jJotGQufm5dkROqYd++3FxW+qxSu4h+pKGGzcTBGnrfqjsdjGE8pMqCGb0pLFoHrS39HrvdHC9Sop6YkUP9Jv3IveAPk7pK5jfm/7WdClY7kLk7/36rtTSDeQtLPTDEX/bz/0sNkxV6m8Mtz3f7cDVQZwGe9lCWBkbaCd2iEHexF5vyDiy6uEu6Tuljqldf1fmuHNhvWToy/a9dpcc3uNgjEo0tKGFbz4i+TO08MpUtueiLHcswiS5lJO8O6ztIMmpuhrpntgT57bZItz/Eev7iDkJOgDqCov27n0bXjwXKCa8tCjZVTHIVUBOxQ0IZjVENPpboFODZW1hAD9tdL/4Kv8aibB05vHAYPPBF6VPlrIVa2HwOqIzq6m8QW4dkhREGSviQjn2YQCWN4hJL06UWmkvOeCOMhrfJgo0CGbpL1hxJox4ScQJvMqatcQzM65xzZuR/pd6CzQOpCycLZ50ST3l/xZflB4DtC0tOumg//HoSVyB71OGSxBGCu7Sz/bRS5BWgTiJIIe9Wc2KNztWHbRXH7Khnmchvp6UJN/bwTAui53AHbkbaRRVijn+2Sjxw4FHIEi+cX7eVeWmzheaYa9/jZ2HsACUDTpIfGYjsSy+dsdr94SN2NSgAjB+Ltv14p1BM2nGko89EOhB9uP0pDSL62NmwdlJflkAUz1+fu6VE73fTESh7V9uoA89f+Ffy2ctxSuNJosClV9JTclLusHRwoXjqPqQeIfJZS5rRs70JzjXWKVNex5amRYECkPTCcu/iGVgJzY6Q/rKtHb1UajsJMZ6rcrJEuH9I1M0ZDFz4JItKrOnpOgecXtntlFl0To0H7sUjv/QTWEORKlMyKGdfqnaqthna6wtOWf/xQDuw9tl4v9uaMQQTVog2Zm0NmLD0jt/K04oChpTA0lH8Chk7kW52v7fP8Dkf9wpeyRsKk/KDYosP5cSNI0bnVRDKQslHyDPMjuQlTSzqiBOt2g2A6uS6NtQMgLW8DMskZnPBSkE7HKDfpgB9K9RT/TSX1PZJh+xDpDF60GLURuLtYIxJjqQNnozzpEQkpBOx091pkVfL9xly2OIsBTBLR57x6H+VKE303D32MMjmEWF5XTEj4AgUV4VHMy6ntCQCcYMw8bJKJameCeLcHFPsE83mCG48n8QyuQ+dJOx27Pzrole7PKvrjYHexTy98FetKaRZyvXcvOqfeWpnATkl0gjzMAWQpjkxE2cGxn/056HqY63M/ObXxnZWmv2RdBG7ukFOyC21JP+KIiGcwIxUHxACtXxDkL4cFZqC2f2hlm8mk1LvUA/7P4oRH7zTK3AoIOWwrAsTAhFlkw5MM2JJ6crgMemR15TNvdRi/HaBGROEBAO0aIq4CM4NJx7+XZ59svnSdxR/w+C8erT7xutLQvRVtXThIHj2upO+7HsIKIKVk2fsL54iJSy5O0kzL1vFwrVRHaMEZnStwoedFFIeGISRKl4AMWV4nWdIoOzSz+q79j1r2llfK9Ij4m5SmCDxYpQsB5/rsraONmLORQX8fK/IF6df37s3D9ymOAq5zx+QONKCG2JNFkwVW21UJHjsrkZR6N/+Uxn/3nQ0wRwiEZ1qjTMM0CdLjYbL1ocnaQjnNl1AZjYMQqy+XU0w5OzjjSdn0Ow+6Lk/p9srjMdB9UCDLiitDuPP8Ey4jmuWRzrqy67D3dq6siX7EBGZwDJ2G8jmwC8b+EqKBpODh6nvid+e9Xx0dODNSM4mq+Xk1wdb2lHM5LtaAsvKmMgeuZgcGe8ea2X6VnrFBj1C/wGTiEAZ3qaqa9VCM5yPynqA2f9nNJZiZHPgAbxWJZcK+NFamPHYZ/Egl+Kd8OOQf7tB0nJy9LeXZzCdF2WQRjvhcFyX5dM/NSR4u6c/KczAw2WEoFQr2fxbqCQp9haAL0iTEhuLRyL22QIG/v8pJsQHiOdyCaqfKilAEKgzeZYv3fSc4Ri3uLJ/gXbzRrMpDCmekVXNqvFg6KZIVGceRkZAczdh741rX5xiCBIyuwkh2/zr1uNeIhYoxq+GVJDjAyhfk85ht4vBrmi2dJ02El6SX61Arwj+sEJ/esPdebKLktxu8pMa/82CItqfPJcKFaQyUIwnvX5gGrInuy2mHMPWlec8XN/lRBWDru9e1F6CrvMcUxVHXF/21LLdKno6Uc/W1eb7sg5eZXJBCH0cvDTYkljbqPY/KbTpTTQWP7UQP/FnxQIAJCWxMQLS93xhTUoWn/OUquroILKZ1LfTb3kD/41GSNKapQ8mbQ3tNyX/DswdnvBD5bkbAmHVB9pUJOalGwfWNgNcHL0ILA+BwvqMIsTzb3NcaEkq6KugTyYhWYRoeU98O2EaJqEQXvRztzAJSceipzD+UjEuL+teQerZ0i/wV2nJmFPODboa1+pMJFYMZNqyGAHxyZ20DoP4t6fdIEkrbUmg03sR3aU7yCvj+cyl3yni4gAIwjVyhkQRHVPnH6wxQvP8kxFssdpujGCNj2x3vnXPZyWdaIV6WJAco/hfERZ68Bp1YkcG8M363s3+6esecD/HPH+AEC6DmFKVnja6QIU+l9jKyaXvBffWvukZQYpixYbn1SST5U04onAbyR4olWUSaCmVE9QUdyd/aevBy1ha3prZuyuJQfbTb0ktxZfrNgb53Ae8yJluXb3NNJDzzuE+yEPsIpHJYvmTB8O0HawoOxKPaB+C51XbV95KpwTO08Qz2dyQT6CSi5HGlhiMb+M+8IyKW2OQAWkxOiOe0pCbBLkRQ7PgOTUq+0+dpTnmfmGb68OgY4ZXTrymJ/2U0TbENGBA3flD47seDExqANq614td+vZcVtvLbL/vv8IDsrhUXouX9u7E/LGzLd6doLn350jW0LVwFULO4LOYhaFu2L4lJ0FyswI2GEyiLs4HXSvOemz621BLse8VjAMiuXVrY61VByquJu3yVV3HRrMpQeZAwHY0WzeKX8KJK5S/ct8Z6On3rOxbzTCYmzSMS/voJaBgmVaWsL1z3Gu4C6MSTm4hO57xZFWoP2m2aM6KZWfPflVOMGQnfG6drKVQgYoyoX65qfqOW1Py5iW+GOY3GJYs5+NlKhjYFcmt5J0hJJcicpEtZ6W6o2ngthjSLTqxp88qFI82pizxGqILlYipSLmakFXJIbQElgVPW2ObDQcZG8POM/10yQdkzExUnEcIzExGktV+jI1cXabRTewaerXSmVgMb8s0KMzbPqResZCkr5qglrWCg1Nyia+5+HxtZNWvC2xalnxVHYEO6r3nr1OnHs2cA8PvpVhs67X0dBrHgVZTooUnNANoTEWrhz445L9vMNCwN3t6uhzgfME87gMBaYP4paiyIIr2T4aCjnp9wn7o0qNcMF5JuR24vgymzvosX2Okczhy06IJ/rDDWMM+IMyPonhSEzQguJ8ndeJg0B5hGDOdHJHAMPSwHFZly0ezTJ0ERU7eobUuFkSP/jV5YRRCCRGSV1rwa5EwAUBH9V4mPQVHu/R+8SUliWOD0zeIYqWRfXnA+wALi7cjkDRgNzXuKuij30un3qTyN9tKCanThSwTWif31HrYsRJ66a7AKGp+AQ65v8IxY/fpDITUkJ9Hf4hcAjX++/HKLf7OI7A26Oj9qwf50600ynhpcB6NKwbCBrUvMLf9RzJ1Lyf8bWi9/Dqlsq+SOft5aUQclWaWsJvjfbJkuaIl9KRoUOU/hHHnEuch2cy9er+uYBzPhJAzDrK88gmelVshn0DEprjgKp+E94zGeIcoFZfjvxZ4bSKmaM9j4b0CN9iPkAcU+Xf7LO32q91c4DCVZKjnWSZDeJKtznNWtwFgkZ/rLff989mjjVCZE1fuq5yQ7grP/juH5QjP1lrFnKmLrtFAFen8JASn06wSeT9Z9ZTn74KH7NnM2lFq6spdcsMgB+0M6mkZ0I7MV9JuFUkhGgcLsef/6dgmYyT6OTeiOlZI/lt9EDB6hQhhisZW0hNpiFHFzFibJ14jF0UIlv+rUXRgtUu7Cudk+XLsFcSyD9e8S5VHy72SO8FBzsh6F/9Um44iWB3n+jUqos8fL4XxZEwQ5ZuxjXJEReEhGXuDUFjhFXU4YTBB2Fkuc+ICd8TtYmUUU0eYgMoChd6ZRKRe9h8asybJbeIsCnaohKJxOlWZF3cPSo7gLCsTvbzPM6/dEaOPZIQr2F7HYRGQ5RuUzIR6LsUL+QxpjhDl00QllEQR9wLsYA08MVyYbUuZxXUC1gsYS1uWx83YZBa0k5VjagV03/0JOF3I3lxq+FX+vS4pAtmJYEogshc1YUTrWyLqEEnIxONqh0b+wpzxpiiVHBsWTe8pUnwl2aF02YG+57V3mRiQ5Nu7lmbFSOLGEJj/G5O3r3AlJpWRi6H2iSc/z6qH01c3VMVv+o9Ga83vXEJiCEeHoEMQUGSTB/S/dplGXonHVUPQWnvJoFq3Qa78L7a8XCmUObXi5yLMdL5AkkKCVfveM+ljlJ/PA83OkAOG4DPKU1fwF6v0Q4ydLJOQPDsrV6Ee2cvQFtpIAyivZq4lcYldEbHhCqzdzHABN2xvml8At9IlWVt/5AnfCMOp3tDfSiAYtdOHc8DJEDI6FiLei1HlfHc3XWXcgLWgchDMD6OfAqNUvN0KrLRSROcRGmcI8hNkiaPd/Qt4dbkMBYpL+CUYMAo7KqKJXt2aKC6YB7jWD2QcfKkkY3r1MZ6TCXCR/xZC7f4t2Mi6yDVW9cpX/LLAwC5rzdZVyVOT94XmLj0y0w7A3JaLw7116vL4z899k71rPthdWLi/COXommC2XTunQeVXp3skGCgTGnyUMBab7H+1hj2k6uf7+wryKKQctLjh72NQzJ7+mtzxtckn1CYU/QkFCRRuV0Ah5e2ul19NNc3nvkWxl3o3KP4Vd8rXEQwmvthUJezwS79BvVjpNWPDOVMZ4dgHbERPreEZ2ppPFCAo2HLu8KxCCkBatrlIJ/RFnYtgNmd2Br52Ja0TPRs1X4n/YvknyYSTLuSNnzCtLd2FvZM1uIG/VteCjGVXUpHLGMKbrDI8dkMQXpPbx3+tKxfCWO6qLbP8YkCwrhCQ8jjDGXAljWvq73UgxjZBpz8rI2YS4JCI6bEHJQZP9JBHTccSgfdjNV35qokvBUEzQXb5JW+uiwWPNnxpwbv+B41Vns+c/5pIHW4h0Cpeak4n+EtrZn9mTyYQw/uA8mtB/ztKfGO8BLA7Bm4+MGnmmGh4it4JuTH0HuPC96koHbWaL0KuIUFo6ihlsvvFv6ax0UrQVGBomJ5AosZVGOj+se6AXWs0gQfuG1KUg49lVw83kvZnJuKG33ddsH6ybvWnTAA07Yfm0LDYsw0A8NvABCHSKUcefKzmxLk5SY9Yb0q8Dvqy8ypYIrm6tjUQ4xot2rlkiP73H7TaewkrtH390fftlnvb1dhRF/YlEzkpLeTpu+Qs/ukC9hdcoCJsDBxAcNdczJ0lVdP+vfYO1q+FvaFuy52abn0xhVzEFdogruTGx4M7XSwG1foQgZFpIjieTnkqIlNs9J2flm4fFGz3AduV+kFLpjOuYlQwrgLmfo+lWIKoa1cnhXcJa6RW3IclyCT4sxL9K3vr9q+cZSEP1K32zU4gnivlCZJ2xELjbbAIYvNwrF2E3yXOJQT2lp1YmKq2maLZbgLMQ/45OKfKtCC3z2cOuGN9Dn97KjDUqvFe0cR13O5XpDNgjFkYd6waimut8CUwuJPyLxVurnezNqqOfiFhPWYMTnO/57oSkKiDMdKOqmB5p/9L6M7R43rU/0DyQkBrrLSu7g9gSkcNxpKqCPgGVEyFJrem1frx3a5kYqq6laBccNvZGKU5Gla+pjW9x7QC2WN9hLiAcc2s/sdXvxzW4p5tLxIWOyq6HB/QZPW2cHvxmiEa2/NXL41CFX6BceDzJhJx2i972srCmX/ZyMgZGomoTsFIIFCSY68iNeYeDsq/wT1YaO9G7QecCP/lHFr0E2iNq/PiJ+PZkzm7A6Y/nh7TE8eT6gmhFeAHhF+uVnqhOH7kxFrhUZhp8lZfazxUQk+w5j6Ix++gUZ5f5kYdNnGynnAWh+o1puyhSZTDf+AlRyr9cUavtvfIyX3KQ/AtKdL05SK3m9H55jylKYmmNwJ3XKfLMsvnyf59CzUC9UtONeyP+eLdrrxX51c1sIeVXkfsWbxRfZW5lAOpplqeE0hFu9SLtHJ4QUeZG5njZdCBy5raYgUxroanQnz9v1hO2PwHoK+UWlrPCl3CMa0LtadOHaS2XCmKZNevzk+F6KA6Yxeh5oMqCQuA2gQFFnZ4vzIWYrI5Zh/7NCVyZW3OLNVu8aP8//zs3j2sQmBKWoyOGDQigwfjAFweh/qMvNpXtqBWJinvBYFEAsiXMTP47l8pPp89tgvjEHAFl2G2IPh+syDRMJz3toEFNnrw4pnEUzFHyNdnSzm/KNd2l9yClPVm2RkBcXXfNasvhr6Q/EY2zby1KmwtJJXLrDOI0KeFJmwBcwuuMknTS5j3/4ZlLiE6Lmho1GtS/YlHgm2UWTJ9GRA3H1Y7sAmLwI3wAQTKZnHkUsNhoQSuRYzTc3ExdBaV4ZRajgXzYwB8Y1kOZn6ihWIX6XGWD5sKw/pRSlQbU6zk63iJBgs3PK4MWv8Hmxc3tkCIjl4oTP+/ci1v2m5TfaPvbynVt1o24ilOiiJ3mNtNC9HrwFLAfLS6hQS0qvjwsd8++BtnDrHF6nsyS82Zdp/w6dDsNMYwakmnmlZL4jyYmbwn55sK9DGT+E776aQKnSKLvSF++KJMaYVovQqSLHSXFiGmWRKo2w9iKhfnkh7c7B3lNJHHQ9PAy7Ly8Hz9vvB/ut6vo9kVfLNjsVzSg2eKxRuoC+PX3tw7afzff9O++i/kaSUAYnWpVk9qZDaSsvoMpBdt1OucwsBnTTwB57MzqBDzjxSZgVDfDKmNqXaMXX2QOCaoyKj0WKCA/ot7zCL1ledg33CYCpjc7r3VFVr4zQMcuZTl7Jxh46nq/ETdDQRMV56eYry0wWDS0Wx3GSFxa4LNvHzqlTxtxxvDSbyzVu5GRGS2j3zGDXUxrKJz28tzqxVQbNLaw3AWY/DwmCVwPv5MBDAjjxs2hUR0nfD9bg85qeioBP2biGjP9fIrGIeFFYRzaKhbANi8DoKjzOq8f5Yl8eNe/vaxS6T5Y1DWjGRRhZXJ15S8oluSXnNDYX0aVDi+ZkrOPvfnsx/joyjx7l9vCK69Qcgx/Nn+Zh6RPeAwIJR54IaedIHJ5woohCgERScUjDTFPNgdpGLXmQE8oCcnApePJ6EeNqJAtp0dyYjunsRMLf6Am8YQeukdkKNyoTJau/8MsZdJDwhV3JvAT4Vc6AdgT9Lf2kf8vVHu3b4ASyXqszra+pShN2PJssl/HUl3Fid84YfwHu0ZZe0R0wtsDPD11wBULTg5DVq1TU4UVWbe2NCFnIZin46KLO+gt1kOZE7lHVBp3WiU2jRnW60xPY10Xgg5e1ghummJolH65PYUfYqSWkKaO/Wz3PvHpvtH+ZwL8ogeM3GVKO2oEq/O8nKH2/JrlKI4ssONu7sacWcyFjEb6iFBbAX5MY78A30tasFuSm0QSazLfcHLnv3PpojHx+e5Q0JWZoMV3kLMMVpk80h6O5Xzhqq55YWLyMrkbzEdM7O2LhjBNx0YuwI671h2Hf3itMpCBA44/FCIF8V/SYP0ZfaMculntKIzdFLxFx++SHM9uxvjtGiK/8ZWrZqc90ErbSPUG+xRN4c3EYzJTV/bpov79vhvxs6U7gWZs9v2s3z8ORrYi4imTz8U4PqA2sUMLknIe2X7086doFUAXZCXbZr0aAlKEf57Kn08XhPPSAaZF0TXWctXQfBgMWnVhsiFpjOyx7jC8StBkWtUnGr5Ls5IY/RyNW+P81mcPIttzC+uqo93pMA9C3M7jeYaL8EPwa5fgAQTAiXzWo58jsuU8JGuegbDuAs0AjM51/wzAXTP6gqW7jFVz+5St2RbwWdYoo+6Cqra1PCJ6kRumeyC/v2kenongbHQzHLbtKu1a9C8ehcEzl2+kyVQ7hPNKaLtgehkQAmyBqnshlaVzqXMxzHCGLMKI+5/HqiN9nJisTa0aQjUODcl8i56vWi2fqUOTtSdckzbMq0Q9DmAE7kuvYJ/mhuIqvTqswAaShBEHIiwB4BD8JPQGATWN/M33crTbVIAyVMmIZkmH2cqMhL0xDqX7KhhhauGZyqmNf2zKZ6BPYVRfA8e5n1BbotLdMJzkTqqSaFk2bODhyBaNijZIEhpHMRuvyBEqRnqPB015WbDg7xUWrNqzSIPjcEbdQ+wdlFKMwF41hKVJ9fqcDQcTsqoU0XGnTqUcC4gXoer0mdQk7Vulfik1ddmCfzHAjcCUYyXjF0oK0X+XvHHPzbmu8Y6gLVPJPLP3dDDTQJihJBl0cgDDS2BOhZilX8V2udnXOGFkOIKY7JC3T+lqT/vcXY1fS7Zyaqc0yD8zHgEZSWdJxwN3q2Nt1SG1Ih2NuP0yETW0qMnMqD9mccfQ1OEIV2UEMCNSlgApeRv5VIshi3obWXO6q5asfPZOdXP2JiuJkMCF6kNtq+ZkQHKMcGDPWqJ6ZaVsrO6PsQEpfXoxVj1CYHCI3WTofFH9AR9Ma3uoxoKRc6Ied8w2fK6hENTVXwdOibLRqoTRxf7Psli9OwMptIaBuJPE0hvMUgmtyTVaX0OmSDpcj7r3xwL7mgo7y8lsUEhpJed08ZPnNIC8he3WF1jMPVgwDwt6nZ1J6F9NZwq81X6hGSv1IP7huD7cCf8kJ1vvSnXpAb89DWeH99c9jv8ek94e+p9RwCj05b33Oh38RO814uDvC9eoVZMCKiS3ZuTjCYib3zaWWc9s3LTvZrrtqj9FrsYqOsWpSlqejWKxIl5SszrQ/LNR6k91HSc7B2muZK8a01kGP90gHS1ZOpEWeHBNAVuRGGvkAyjI3FyhlxiisgHNMmV4DAWX/WNxPoSQKOp3TqMDwdzYZ0WpUYcMK3F6x6FOxLdeHMsasBQekPTktOqSTQ94rgqxwMOzkt1TZRQgYYBY1mA1MM8lGwkrxGRHSWH4tHI9dF7DaLAYpfiPASjFo20LwW6MkFBMa5gPesdruYjL/XkMncKVVrPAawcjfN+vN2rBYJDY0i9UIA66KdFiheBY0JcZC71BWIT0u2B7goQQhHVvQrJLp2FT19IWBFnaeKw586gTUqRICPZekvpd3udhLetztLTAfhalV10QqHi2m61iV/3UymzGiKe5D4bnt85F/AtxJxMf1Y/vKQRUGhCb05oaIN0jMxibwOVZOENOWa8ZueX9Pn/Y2NAA9iRKR55mECzhK5ncxMVjvmyQ5/V0OzlzYuEtL1bcFX7L/AP+zO9QO41rvD26hUNvz3wkfThA95Z12fBwg6mPJ2lG5PH6WS9OAOixJQFj7Jaa6zgjcIvt9Tm1dEkBrlIrYxFqurVvut8+B0xErYzfFcE6/rXLnKv/7CRDqWJH3CTQbYDNFvi4IJLsdkKB7fGNlrhktCboWZMw9BMay2ycMAjYY5XXUAlScgeI1DpqI/FS1gD1Zi97fl8Ck6rgP3w1aD9sXu8Pkn1qwSOiZJ3d5kqyO8TWqV7voCu9GVXyL2zO6ef3IfzlpvzJgtsGIL1OVJgBm6We6zp3qW+gURX+t7kRJ9gyH/HZ0BW/1Rpt41I5tv1IJuxsKeYpUf3oFaraZE8IhYgjNzUNxuIQvO8q/NoIo12IplguTqaXYjnsyXpv8zEz7UpjgXBpWJoLjvdX73TjHHYLMeQIZ7vLM1L8g7qpumWROHBuUqrO6GSeEUjfkelQ0lGGf4L0h1LckSS4xpQJhD+1zHJ0SiQUKrRsJ1fgYwGYEZS+Q1oWh4OEljSIk9T5Z3us3ng9NWVwVMse0aFhUVSQBIFjENnV+nMs7IWgx/Cct8sMkuTaJxz6Rex3wdk8rVMyLE8kuVncNL1AG/u9fMwgpw3GABQl6XEOiZCb6bAUS/wSUPsxY+MNQtQ5Ketzx1XjYbK8RgMi5XOQcJdXxKlXN02wwiEpDOAVbAcZ2G9KkhrJcbrMkyTyRYAfn9VB55PoEsIULu/t5+SDle1LlfgeaEWXtHxv+t6Aqk3Ap1KArDhaFTxZt/rUCi05x69JpXc4Mr4VhfQWYjtYI9LkxtJt5dWK63KfGW47/rhNhGsxdzDoiFQv/PNWWo/4F4gaWGYDUUpm7lKMP/zTx2qBWYc2+VaaySyy3jtGQai8yKvh5PzsEQSoHs8h15pC8PZA3N7rL3XD41I7wxsx6wee2FyU3CcD2bNRkqqItneTwgUkOZfCtqIURVpUgjS+t6qivx7neLcnxtCnO5zIvhSHLJX24nBKraaJaki7CCHj4MbtEt5QDNUxeDbaHec121lcpi6BNrZDP/Yy9X9ud7ECT1+kJGirE/fS/mLdyN5JgpV707tghTUyqx6CcHnr6Ei1MIosmkXlPotvP9vIQb10vGkp78YyR2dakPkgZaLjpqetnaSVG0pTtx5pWPIT4yvKKvVo0N/K35iOwbK6Slp3V2bI3pIL9FyFJz7QavMH7s6TvlNdi4xwgjhSyPjbJnB/PurUNr3PXioTkaWaSUjEPZfWd+CU6TT40c63yPyTuYasoLmvO+EKMX0GLzR+6RPh1ziad6g6bonlGdiz4DVLG8C4Qgqcr2x0tDve9Goo/p91ocOZlszc+T0EHW4zq8K0yjmBAsH2MAw7PwDFgCQktmAmvx7HPUBDSaCC9BrDRnfAoMksUxxEk5e7OXnn0qf6oqDKq0JM6b67H9Zx34cc8f5TIH2R1iQziwcpEpeV9BJOejP8r3HQE8p4M113rfXelzPyc5J3m1HM6yQ8lec8quq6RgHCAOulGHgDsFhXaQW+/EEXQdAvwkKJwFNnR7ZtG/uEDI8biH0Tb1e+YlNzKVw5N6Xnj/C1msaZ4u2m2YMlH+Tiobi0DK/MTvNBNdIMe0/iNfi42P41UMLNCKO8px1ab15iIodeJD0BiAG+zhaLkZcPDePZjDLoKUGTAxOTdtaYTVFrtTo4bhoZlnvnkD9S/DZZ6K96lyMECJwtoI/7Xtial+pzNh5/ctcH7STmh3KJMvAf3owTCq36eKeq3TF789A6exEQA1veB7XzaE7hWCJkglrqzlMKw1a1ug0t4Hdj99xroP2W4SwfPJGrS2YgSsdAZtr4bdHJPwFFAEP/+nzdLW1wj3ZZCmBrrivbLsjboxN9zzrQAmUQnqpkLPxmS3Uj+VPoH0ZOaBJ7TPyin4V+cNEhgf75ykovrUzb8v1iPDtExB+y+z3bDlKaxPc9jjFJLeJ58Bl8ugb3mQP8IvM5nGuH6hA+f9DTeRpNNgRP+SHslvCSkUCf7Sp4FTlSp0d3zd3HBJJF0kC79u3vlk010DBbzL/UPXy+yrsHazNnpxTFmkpOk44YJLg2rUAhnv94/ZyeoRCpCMVTqNJfbXK3XVuMLaq4heGgKvXiPETPC96jrmvD536iBYFDfPySelq7H62/SYEitZCd1dkJLDKo0gWEcoi0KdiZuhBu99nkyT/H/s6FqNvDc0uqvQ/ztSpLEuKrStxtv9k7+JdpY99E1NwZ8mDzB0ZDN9PG4NBvzfm7Tig/v7ve/uyPvPvC+Zlf4ogyxMvmrLvCokPL6FSPmsm8xUCtbRSE0YcEYpZs+3dQFql6d4D1jL13TLwtWXP/0ib28IvCRk7/rV3OUlY9pcCh8FI59I68eB26sv72O08P3F16Wec7BpNglN+G6au4uJ6aU38MYmrnM2eG6ir7Duh0/93DB10umkLC4Nas4L/PBos8EIkSdfAYg+Py7KY7dPJQmM9XFhpDQbAWxzkR/5AXRRbV4HfMdH9hu01eEPOh/d0SUqgZ5j5XzegvRo5OjnDblPK5wPmf+hxGxIVAyAe15/27KKLjCHLsbaXs+4m7VJ7tNNAnlY1hTnM6nenWW0+p+k7mIuR3DdTwlglv8Ty2sCdE7EgknIhLHKBI76O7cTViSPXwh3tx3suFrQEdzy1+3XqcV257gbPhteEUd48VhZey+HGunLFCEu/6mFohjDLDyxmSPQ8SKTaaX7qKHzP+jCkajSrU+eD/Gwd3fRqUhz8bXxTnKnXIQD4K7EdTZpiZfKpeHeMXHyWUBY7hrP/eZdHJagyIvd4rIqbmAS6NU9m59c3hGUA6Yjydpl0kgD9tHY7T423gm9wBESld7ieApA74oXTm0+vhkroshOZD7ZTCTZH56987v0S9MePO9IjOFJMahxuRUDD/OeCzTyLSBnCN3IRH8+mccyTBaEZIXTQH8PhG7pBAmjBGY4GLEuyqNGvdRzDx+mAxp+o//0u2CmyL4L0ffsatyfiaVqPWq/7qThR8jM2LJMaOhbyQzZz4w4DeKPNr2zz5hhyWYsWdLtuPyKx+jjhSTrQQc3Qv9y8Il3wb/vlFtCpU3DhRqaEM3x2HjMGm4Nsj29L+RlkHz1UpBF5npGmt1tmm5m8AdQUqil9pNBTctr60AmhyhF0aHtC//vhEXPVRYj/lmV6BlnaLeq0AMsRg40FTOk9LyFOHmkRdOaXKnjl77Y40reZXPtWA81qWumwerk1bP+gfhN2nlT4Xbox6y7elgTczWvDqiIZafry5xFf9AE7f+uoFQizcowQD7jMMB5zxDSXwbG/lx0btspxlHuxMSB4CPtjJj5qTF0NDeCusKsWO5btFcFk9xPFIBG4l6iTtFYU+F1kI9tCKIefdwzrbgLCoY/yayhvzVvCTV5kgpJ4lFzULBKB6SUNgANc3tQrvRR0H5oE2ialkumAknRJA==]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python：遍历列表时删除元素]]></title>
    <url>%2F2019%2F07%2F31%2FPython%EF%BC%9A%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8%E6%97%B6%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[Python的for循环可以遍历一个列表，但若需要同时将符合条件的元素删除时，则会出错。 示例 代码1123456s = [1, 2, 3, 4, 1, 1]s1 = sfor i in s1: if i == 1: s1.remove(i)print(s1) 输出1 1[2, 3, 4, 1] 代码2 12345s2 = sfor idx in range(len(s2)): if s2[idx] == 1: del s2[idx]print(s2) 输出2 1234Traceback (most recent call last): File "temp.py", line 11, in &lt;module&gt; if s2[idx] == 1:IndexError: list index out of range 出错原因Python中用for发起任何形式的遍历时，它的遍历顺序都是从最初就确定的，而在遍历中删除了元素会导致当前索引的变化，所以遍历中间取到的索引的那个值已经变了，会漏掉一些元素。另一种错误是删除元素后列表长度缩小了，所以会超出索引范围。 正确删除法使用filter()函数过滤掉符合指定条件的元素。12s3 = sprint(list(filter(lambda x: x != 1, s3))) 输出结果： 1[2, 3, 4] 此处lambda为Python中函数的简化定义形式。 使用列表解析式。12s4 = [i for i in s if i != 1]print(s4) 输出结果： 1[2, 3, 4] 拷贝一个新列表把原始列表拷贝给一个新列表，遍历新列表，修改原始列表（或相反）。 12345s6 = sfor i in s6[:]: if i == 1: s6.remove(i)print(s6) 输出结果： 1[2, 3, 4] 但是，下面的赋值操作给新列表是不行的，因为新变量和原变量的物理地址是相同的，可通过id()函数查看。 12345s5 = sfor i in s: if i == 1: s5.remove(i)print(s5) 输出结果： 1[2, 3, 4, 1] 通过深拷贝解决 1234567import copys5 = copy.deepcopy(s)for i in s: if i == 1: s5.remove(i)print(s5) 输出结果： 1[2, 3, 4] 用while循环来做判断条件。1234s7 = swhile 1 in s7: s7.remove(1)print(s7) 输出结果： 1[2, 3, 4]]]></content>
      <categories>
        <category>计算机</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机：语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习：Python基础（中）]]></title>
    <url>%2F2019%2F07%2F24%2FPython%E5%AD%A6%E4%B9%A0%EF%BC%9APython%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构（下）:Python容器列表：list list是由任意类型元素组成的序列。列表非常适合利用顺序和位置定位某一元素，尤其是当元素的顺序或内容经常发生改变时。与字符串不同，列表是可变的。你可以直接对原始列表进行修改：添加新元素、删除 或覆盖已有元素。在列表中，具有相同值的元素允许出现多次。 *Python中的三种序列结构：字符串，列表，元组。它们都可以包含零个或多个元素。与字符串不同的是，元组和列表并不要求所含元素的种类相同，每个元素都可以是任何Python类型的对象。而对于列表和元组来说，元组是不可变的，当你给元组赋值时，这些值便被固定在了元组里，再也无法修改。然而，列表却是可变的，这意味着可以随意地插入或删除其中的元素。 list =&gt; [&lt;exp&gt;,&lt;exp&gt;] 创建列表:使用[]或list()1234&gt;&gt;&gt; empty_list = [] &gt;&gt;&gt; weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'] &gt;&gt;&gt; big_birds = ['emu', 'ostrich', 'cassowary'] &gt;&gt;&gt; first_names = ['Graham', 'John', 'Terry', 'Terry', 'Michael'] 也可以使用list()函数来创建一个空列表： 123&gt;&gt;&gt; another_empty_list = list() &gt;&gt;&gt; another_empty_list [] 转换成列表:使用list()Python的list()函数可以将其他数据类型转换成列表类型。 123456789101112131415161718# 将字符串-》列表&gt;&gt;&gt; list('cat') ['c', 'a', 't']# 使用 split() 可以依据分隔符将字符串切割成由若干子串组成的列表：&gt;&gt;&gt; birthday = '1/6/1952' &gt;&gt;&gt; birthday.split('/') ['1', '6', '1952']# 如果待分割的字符串中包含连续的分隔符，那么在返回的列表中会出现空串元素：&gt;&gt;&gt; splitme = 'a/b//c/d///e' &gt;&gt;&gt; splitme.split('/') ['a', 'b', '', 'c', 'd', '', '', 'e']# 将元组-》列表&gt;&gt;&gt; a_tuple = ('ready', 'fire', 'aim') &gt;&gt;&gt; list(a_tuple) ['ready', 'fire', 'aim'] 获取列表元素：使用[offset]和字符串一样，通过偏移量可以从列表中提取对应位置的元素： 12345678910111213141516&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes[0] 'Groucho' &gt;&gt;&gt; marxes[1] 'Chico' &gt;&gt;&gt; marxes[2] 'Harpo'#负偏移量代表从尾部开始计数：&gt;&gt;&gt; marxes[-1] 'Harpo' &gt;&gt;&gt; marxes[-2] 'Chico' &gt;&gt;&gt; marxes[-3] 'Groucho' &gt;&gt;&gt; *指定的偏移量对于待访问列表必须有效——该位置的元素在访问前已正确赋值。当指定的偏移量小于起始位置或者大于末尾位置时，会产生异常（错误）。 包含列表的列表列表可以包含各种类型的元素，包括其他列表，如下所示： 123456789101112&gt;&gt;&gt; small_birds = ['hummingbird', 'finch'] &gt;&gt;&gt; extinct_birds = ['dodo', 'passenger pigeon', 'Norwegian Blue'] &gt;&gt;&gt; carol_birds = [3, 'French hens', 2, 'turtledoves'] &gt;&gt;&gt; all_birds = [small_birds, extinct_birds, 'macaw', carol_birds]# all_birds结构&gt;&gt;&gt; all_birds [['hummingbird', 'finch'], ['dodo', 'passenger pigeon', 'Norwegian Blue'], 'macaw', [3, 'French hens', 2, 'turtledoves']]# all_birds第一个元素&gt;&gt;&gt; all_birds[0] ['hummingbird', 'finch'] 使用[offset]修改元素就像可以通过偏移量访问某元素一样，你也可以通过赋值对它进行修改： 1234&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes[2] = 'Wanda' &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Wanda'] *与之前一样，列表的偏移量必须是合法有效的。 指定范围并使用切片提取元素列表的切片仍然是一个列表。可以使用切片提取列表的一个子序列,与字符串一样，列表的切片也可以设定除1以外的步长。 1234567891011&gt;&gt;&gt; marxes = ['Groucho', 'Chico,' 'Harpo'] &gt;&gt;&gt; marxes[0:2] ['Groucho', 'Chico']#从列表的开头开始每2个提取一个元素&gt;&gt;&gt; marxes[::2] ['Groucho', 'Harpo']# 可以巧妙地实现列表逆序：&gt;&gt;&gt; marxes[::-1] ['Harpo', 'Chico', 'Groucho'] 添加元素至尾部:使用append()利用append()函数将元素一个个添加到尾部。 123&gt;&gt;&gt; marxes.append('Zeppo') &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo'] 合并列表：使用extend()或+=使用extend()可以将一个列表合并到另一个列表中。 12345&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl'] &gt;&gt;&gt; marxes.extend(others) &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo', 'Gummo', 'Karl'] 也可以使用+=： 12345&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl'] &gt;&gt;&gt; marxes += others &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo', 'Gummo', 'Karl'] 如果使用了append()，那么others会被当成一个单独的元素进行添加,而不是将其中的内容进行合并： 12345&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl'] &gt;&gt;&gt; marxes.append(others) &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo', ['Gummo', 'Karl']] 在指定位置插入元素 :使用insert()append()函数只能将新元素插入到列表尾，而使用insert()可以将元素插入到列表的任 意位置。指定偏移量为0可以插入列表头部。如果指定的偏移量超过了尾部，则会插入到 列表最后，就如同append() 一样，这一操作不会产生 Python 异常。 12345&gt;&gt;&gt; marxes.insert(3, 'Gummo')&gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo'] &gt;&gt;&gt; marxes.insert(10, 'Karl') &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo', 'Karl'] 删除指定位置的元素:使用del当列表中一个元素被删除后,位于它后面的元素会自动往前移动填补空出的位置，且列表 长度减 1。再试试从更新后的marxes列表中删除&#39;Harpo&#39;： 1234567&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo'] &gt;&gt;&gt; marxes[2] 'Harpo' &gt;&gt;&gt; del marxes[2] &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Gummo', 'Zeppo'] &gt;&gt;&gt; marxes[2] 'Gummo' 在列表首删除/插入一个元素与在列表尾插入一个元素所用的时间是谁大？或者一样？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 计算时间函数&gt;&gt;&gt; from time import clock&gt;&gt;&gt; def timer(f):&gt;&gt;&gt; def _f(*args):&gt;&gt;&gt; t0 = clock()&gt;&gt;&gt; f(*args)&gt;&gt;&gt; return clock() - t0&gt;&gt;&gt; return _f # 删除 &gt;&gt;&gt; def delete_elem(x, index):&gt;&gt;&gt; del x[index]&gt;&gt;&gt; x = [5] * 100000000&gt;&gt;&gt; print(x[0])5&gt;&gt;&gt; print(x[999999])5&gt;&gt;&gt; print(len(x))100000000&gt;&gt;&gt; end_del = timer(delete_elem)(x, -1)&gt;&gt;&gt; print('现在list长度:',len(x))现在list长度: 99999999&gt;&gt;&gt; start_del = timer(delete_elem)(x, 0)&gt;&gt;&gt; print('现在list长度:',len(x))现在list长度: 99999998&gt;&gt;&gt; print('删首时间/删尾时间',start_del/end_del)删首时间/删尾时间 5339.656807434651# 插入&gt;&gt;&gt; def insert_elem(x, index, v):&gt;&gt;&gt; x.insert(index, v) &gt;&gt;&gt; x = [5] * 100000000&gt;&gt;&gt; print(x[0])5&gt;&gt;&gt; print(x[999999])5&gt;&gt;&gt; print(len(x))100000000&gt;&gt;&gt; start_del = timer(insert_elem)(x, 0, 9)&gt;&gt;&gt; print(len(x))100000001&gt;&gt;&gt; end_del = timer(insert_elem)(x, -1, 9)&gt;&gt;&gt; print(len(x))100000002&gt;&gt;&gt; print('删首时间/删尾时间',start_del/end_del)删首时间/删尾时间 200615.78078284615 由上面可知在列表首删除/插入一个元素远远大于在列表尾插入一个元素所用的时间。原因在于列表在存储时，是存在于一片连续的储存单元中。删除最后一个元素时候，只要根据index找到该元素，然后删除。而删除第一个元素时候，需要找到第一个元素删除的同时，需要把其后面的元素移前一个位置。插入同理。 删除具有指定值的元素:使用remove()1234&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo'] &gt;&gt;&gt; marxes.remove('Gummo') &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo', 'Zeppo'] 获取并删除指定位置的元素:使用pop()使用pop()同样可以获取列表中指定位置的元素，但在获取完成后，该元素会被自动删除。如果你为pop()指定了偏移量，它会返回偏移量对应位置的元素；如果不指定，则默认使用-1。因此，pop(0)将返回列表的头元素，而pop()或pop(-1)则会返回列表的尾元素 123456789&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; marxes.pop() 'Zeppo' &gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes.pop(1) 'Chico' &gt;&gt;&gt; marxes ['Groucho', 'Harpo'] 查询具有特定值的元素位置:使用index()如果该查询的元素在列表中不存在，使用index时会报异常。 123&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; marxes.index('Chico') 1 判断值是否存在：使用in同一个值可能出现在列表的多个位置，但只要至少出现一次，in就会返回True： 12&gt;&gt;&gt; words = ['a', 'deer', 'a' 'female', 'deer'] &gt;&gt;&gt; 'deer' in words True 记录特定值出现的次数:使用count()123456789&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes.count('Harpo') 1 &gt;&gt;&gt; marxes.count('Bob')0 &gt;&gt;&gt; snl_skit = ['cheeseburger', 'cheeseburger', 'cheeseburger']&gt;&gt;&gt; snl_skit.count('cheeseburger') 3 转换为字符串:使用join()join()实际上是一个字符串方法，而不是列表方法。不能通过marxes.join(&#39;,&#39;)进行调用，尽管这可能看起来更直观。join() 函数的参数是字符串或者其他可迭代的包含字符串的序列，它的输出是一个字符串。。试着这样来记忆 join() 的调用顺序： join()是split()的逆过程 12345678910111213&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; ', '.join(marxes) 'Groucho, Chico, Harpo'&gt;&gt;&gt; friends = ['Harry', 'Hermione', 'Ron'] &gt;&gt;&gt; separator = ' * ' &gt;&gt;&gt; joined = separator.join(friends) &gt;&gt;&gt; joined 'Harry * Hermione * Ron' &gt;&gt;&gt; separated = joined.split(separator) &gt;&gt;&gt; separated ['Harry', 'Hermione', 'Ron'] &gt;&gt;&gt; separated == friends True 获取长度:使用len()123&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; len(marxes) 3 使用sort()重新排列元素将列表中的元素按值排序,Python 为此 提供了两个函数： 列表方法sort()会对原列表进行排序，改变原列表内容； 通用函数sorted()则会返回排好序的列表副本，原列表内容不变。 如果列表中的元素都是数字，它们会默认地被排列成从小到大的升序。如果元素都是字符 串，则会按照字母表顺序排列 1234567891011# sorted_marxes是一个副本，它的创建并不会改变原始列表的内容&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; sorted_marxes = sorted(marxes) &gt;&gt;&gt; sorted_marxes ['Chico', 'Groucho', 'Harpo']&gt;&gt;&gt; marxes ['Groucho', 'Chico', 'Harpo']# 但对 marxes 列表调用列表函数 sort() 则会改变它的内容&gt;&gt;&gt; marxes.sort() &gt;&gt;&gt; marxes ['Chico', 'Groucho', 'Harpo'] 当列表中的所有元素都是同一种类型时（例如marxes中都是字符串），sort()会正常工作。有些时候甚至多种类型也可——例如整型和浮点型——只要它们之间能够自动地互相转换 123&gt;&gt;&gt; numbers = [2, 1, 4.0, 3] &gt;&gt;&gt; numbers.sort() &gt;&gt;&gt; numbers [1, 2, 3, 4.0] 默认的排序是升序的，通过添加参数reverse=True可以改变为降序排列 1234&gt;&gt;&gt; numbers = [2, 1, 4.0, 3] &gt;&gt;&gt; numbers.sort(reverse=True) &gt;&gt;&gt; numbers[4.0, 3, 2, 1] 使用=赋值，使用copy()复制如果将一个列表赋值给了多个变量，改变其中的任何一处会造成其他变量对应的值也被修改。 1234567&gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; a [1, 2, 3] &gt;&gt;&gt; b = a &gt;&gt;&gt; b [1, 2, 3] &gt;&gt;&gt; a[0] = 'surprise' &gt;&gt;&gt; a ['surprise', 2, 3]&gt;&gt;&gt; b ['surprise', 2, 3] b与a实际上指向的是同一个对象，因此，无论我们是通过a还是通过b来修改列表的内容，其结果都会作用于双方。通过下面任意一种方法，都可以将一个列表的值复制到另一个新的列表中： 列表copy()函数 list()转换函数 列表分片[:]1234567891011121314&gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; b = a.copy() &gt;&gt;&gt; c = list(a) &gt;&gt;&gt; d = a[:]&gt;&gt;&gt; a[0] = 'integer lists are boring' &gt;&gt;&gt; a ['integer lists are boring', 2, 3] &gt;&gt;&gt; b [1, 2, 3] &gt;&gt;&gt; c [1, 2, 3] &gt;&gt;&gt; d [1, 2, 3] 元组：Tuple元组也是由任意类型元素组成的序列。与列表不同的是，元组是不可变的，这意味着一旦元组被定义，将无法再进行增加、删除或修改元素等操作。因此，元组就像是一个常量列表。 创建元组：使用()可以用 () 创建一个空元组： 123&gt;&gt;&gt; empty_tuple = () &gt;&gt;&gt; empty_tuple () 创建包含一个或多个元素的元组时，每一个元素后面都需要跟着一个逗号，即使只包含一个元素也不能省略： 123&gt;&gt;&gt; one_marx = 'Groucho', &gt;&gt;&gt; one_marx ('Groucho',) 如果创建的元组所包含的元素数量超过1，最后一个元素后面的逗号可以省略： 123&gt;&gt;&gt; marx_tuple = 'Groucho', 'Chico', 'Harpo' &gt;&gt;&gt; marx_tuple ('Groucho', 'Chico', 'Harpo') Python的交互式解释器输出元组时会自动添加一对圆括号。你并不需要这么做——定义元组真正靠的是每个元素的后缀逗号——但如果你习惯添加一对括号也无可厚非。可以用括号将所有元素包裹起来，这会使得程序更加清晰： 123&gt;&gt;&gt; marx_tuple = ('Groucho', 'Chico', 'Harpo') &gt;&gt;&gt; marx_tuple ('Groucho', 'Chico', 'Harpo') 可以一口气将元组赋值给多个变量：(有时这个过程被称为元组解包。) 12345678&gt;&gt;&gt; marx_tuple = ('Groucho', 'Chico', 'Harpo') &gt;&gt;&gt; a, b, c = marx_tuple &gt;&gt;&gt; a 'Groucho' &gt;&gt;&gt; b 'Chico' &gt;&gt;&gt; c 'Harpo' 可以利用元组在一条语句中对多个变量的值进行交换，而不需要借助临时变量： 1234567&gt;&gt;&gt; password = 'swordfish' &gt;&gt;&gt; icecream = 'tuttifrutti' &gt;&gt;&gt; password, icecream = icecream, password &gt;&gt;&gt; password 'tuttifrutti' &gt;&gt;&gt; icecream 'swordfish' tuple() 函数可以用其他类型的数据来创建元组： 123&gt;&gt;&gt; marx_list = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; tuple(marx_list) ('Groucho', 'Chico', 'Harpo') 元组与列表在许多地方都可以用元组代替列表，但元组的方法函数与列表相比要少一些——元组没有append()、insert()，等等——因为一旦创建元组便无法修改。既然列表更加灵活，那为什么不在所有地方都使用列表呢？原因如下所示： 元组占用的空间较小 你不会意外修改元组的值 可以将元组用作字典的键 - 命名元组可以作为对象的替代 函数的参数是以元组形式传递的 字典: dict字典（dictionary）与列表类似，但其中元素的顺序无关紧要，因为它们不是通过像0或1的偏移量访问的。取而代之，每个元素拥有与之对应的互不相同的键（key），需要通过键来访问元素。键通常是字符串，但它还可以是Python中其他任意的不可变类型：布尔型、 整型、浮点型、元组、字符串，以及其他一些在后面的内容中会见到的类型。字典是可变的，因此你可以增加、删除或修改其中的键值对。 创建字典:使用{}用大括号（{}）将一系列以逗号隔开的键值对（key:value）包裹起来即可进行字典的创建。最简单的字典是空字典，它不包含任何键值对： 12345678910111213141516&gt;&gt;&gt; empty_dict = &#123;&#125; &gt;&gt;&gt; empty_dict &#123;&#125;&gt;&gt;&gt; pizza = &#123; "size":"medium", "type":"pepperoni", "crust":"Thick", "qty": 1, "deliver":True,&#125;&#123;'size': 'medium', 'type': 'pepperoni', 'crust': 'Thick', 'qty': 1, 'deliver': True&#125; Python 允许在列表、元组或字典的最后一个元素后面添加逗号，这不会产生任何问题。此外，在括号之间输入键值对来创建字典时并不强制缩进。 转换为字典：使用dict()可以用 dict() 将包含双值子序列的序列转换成字典。每个子序列 的第一个元素作为键，第二个元素作为值。 1234567&gt;&gt;&gt; lot = [ ('a', 'b'), ('c', 'd'), ('e', 'f') ] &gt;&gt;&gt; dict(lot) &#123;'c': 'd', 'a': 'b', 'e': 'f'&#125;&gt;&gt;&gt; los = [ 'ab', 'cd', 'ef' ] &gt;&gt;&gt; dict(los) &#123;'c': 'd', 'a': 'b', 'e': 'f'&#125; 添加或修改元素:使用[key]向字典中添加元素非常简单，只需指定该元素的键并赋予相应的值即可。如果该元素的键已经存在于字典中，那么该键对应的旧值会被新值取代。如果该元素的键并未在字典中出现，则会被加入字典。与列表不同，你不需要担心赋值过程中Python 会抛出越界异常。 123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; pythons = &#123; 'Chapman': 'Graham', 'Cleese': 'John', 'Idle': 'Eric', 'Jones': 'Terry', 'Palin': 'Michael', &#125; &gt;&gt;&gt; pythons &#123;'Cleese': 'John','Jones': 'Terry', 'Palin': 'Michael','Chapman': 'Graham', 'Idle': 'Eric'&#125;# 新增 pythons['Gilliam'] = 'Gerry'&gt;&gt;&gt; pythons['Gilliam'] = 'Gerry' &gt;&gt;&gt; pythons &#123;'Cleese': 'John', 'Gilliam': 'Gerry', 'Palin': 'Michael', 'Chapman': 'Graham', 'Idle': 'Eric', 'Jones': 'Terry'&#125;# 修改pythons['Gilliam'] = 'Terry'&gt;&gt;&gt; pythons['Gilliam'] = 'Terry' &gt;&gt;&gt; pythons &#123;'Cleese': 'John', 'Gilliam': 'Terry', 'Palin': 'Michael', 'Chapman': 'Graham', 'Idle': 'Eric', 'Jones': 'Terry'&#125; 合并字典：使用update()如果待添加的字典与待扩充的字典包含同样的键，那么新归入字典的值会取代原有的值 12345&gt;&gt;&gt; first = &#123;'a': 1, 'b': 2&#125; &gt;&gt;&gt; second = &#123;'b': 'platypus'&#125; &gt;&gt;&gt; first.update(second) &gt;&gt;&gt; first &#123;'b': 'platypus', 'a': 1&#125; 删除具有指定键的元素:使用del1234&gt;&gt;&gt; first = &#123;'a': 1, 'b': 2&#125; &gt;&gt;&gt; del first['a']&gt;&gt;&gt; first&#123;'b': 2&#125; 删除所有元素:使用clear()使用clear()，或者给字典变量重新赋值一个空字典（{}）可以将字典中所有元素删除： 123456&gt;&gt;&gt; pythons.clear() &gt;&gt;&gt; pythons &#123;&#125; &gt;&gt;&gt; pythons = &#123;&#125; &gt;&gt;&gt; pythons&#123;&#125; 使用in判断是否存在如果你希望判断某一个键是否存在于一个字典中，可以使用in。 12345&gt;&gt;&gt; pythons = &#123;'Chapman': 'Graham', 'Cleese': 'John', 'Jones': 'Terry', 'Palin': 'Michael'&#125;&gt;&gt;&gt; 'Chapman' in pythons True &gt;&gt;&gt; 'Palin' in pythons True 使用[key]获取元素这是对字典最常进行的操作，只需指定字典名和键即可获得对应的值： 12&gt;&gt;&gt; pythons['Cleese'] 'John' 如果字典中不包含指定的键，会产生一个异常。有两种方法可以避免这种情况的发生。第一种是在访问前通过in测试键是否存在，另一种方法是使用字典函数get()。你需要指定字典名，键以及一个可选值。如果键存在，会得到与之对应的值反之，若键不存在，如果你指定了可选值，那么get()函数将返回这个可选值,否则，会得到None（在交互式解释器中什么也不会显示）： 12345678&gt;&gt;&gt; pythons.get('Cleese') 'John'&gt;&gt;&gt; pythons.get('Marx', 'Not a Python') 'Not a Python'&gt;&gt;&gt; pythons.get('Marx') &gt;&gt;&gt; 获取所有键:使用keys()使用keys()可以获得字典中的所有键。在接下来的几个例子中，我们将换一个示例： 123&gt;&gt;&gt; signals = &#123;'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'&#125; &gt;&gt;&gt; signals.keys() dict_keys(['green', 'red', 'yellow']) 在Python 2里，keys()会返回一个列表，而在Python 3中则会返回dict_keys()，它是键的迭代形式。这种返回形式对于大型的字典非常有用，因为它不需要时间和空间来创建返回的列表。有时你需要的可能就是一个完整的列表，但在Python 3中，你只能自己调用list()将dict_keys转换为列表类型。 获取所有值:使用values()使用 values()可以获取字典中的所有值： 12&gt;&gt;&gt; list( signals.values() ) ['go', 'smile for the camera', 'go faster'] 获取所有键值对:使用items()使用items()函数可以获取字典中所有的键值对： 12&gt;&gt;&gt; list( signals.items() ) [('green', 'go'), ('red', 'smile for the camera'), ('yellow', 'go faster')] 每一个键值对以元组的形式返回，例如(&#39;green&#39;,&#39;go&#39;)。 使用=赋值，使用copy()复制与列表一样，对字典内容进行的修改会反映到所有与之相关联的变量名上： 12345&gt;&gt;&gt; signals = &#123;'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'&#125; &gt;&gt;&gt; save_signals = signals &gt;&gt;&gt; signals['blue'] = 'confuse everyone' &gt;&gt;&gt; save_signals&#123;'blue': 'confuse everyone', 'green': 'go', 'red': 'smile for the camera', 'yellow': 'go faster'&#125; 若想避免这种情况，可以使用copy(),将字典复制到一个新的字典中： 1234567&gt;&gt;&gt; signals = &#123;'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'&#125; &gt;&gt;&gt; original_signals = signals.copy() &gt;&gt;&gt; signals['blue'] = 'confuse everyone' &gt;&gt;&gt; signals &#123;'blue': 'confuse everyone', 'green': 'go', 'red': 'smile for the camera', 'yellow': 'go faster'&#125; &gt;&gt;&gt; original_signals &#123;'green': 'go', 'red': 'smile for the camera', 'yellow': 'go faster'&#125; 集合：set集合就像舍弃了值，仅剩下键的字典一样。键与键之间也不允许重复。如果你仅仅想知道某一个元素是否存在而不关心其他的，使用集合是个非常好的选择。 创建集合:使用set()与字典的键一样，集合是无序的。 123456789&gt;&gt;&gt; empty_set = set() &gt;&gt;&gt; empty_set set() &gt;&gt;&gt; even_numbers = &#123;0, 2, 4, 6, 8&#125; &gt;&gt;&gt; even_numbers &#123;0, 8, 2, 4, 6&#125; &gt;&gt;&gt; odd_numbers = &#123;1, 3, 5, 7, 9&#125; &gt;&gt;&gt; odd_numbers &#123;9, 3, 1, 5, 7&#125; 将其他类型转换为集合:使用set()利用已有列表、字符串、元组或字典的内容来创建集合，其中重复的值会被丢弃。 1234&gt;&gt;&gt; set( 'letters' )&#123;'l', 'e', 't', 'r', 's'&#125;&gt;&gt;&gt; set( ('Ummagumma', 'Echoes', 'Atom Heart Mother') ) &#123;'Ummagumma', 'Atom Heart Mother', 'Echoes'&#125; 测试值是否存在:使用in123&gt;&gt;&gt; martini = &#123;'vodka', 'vermouth'&#125;&gt;&gt;&gt; 'vodka' in martiniTrue 合并及运算符交集：通过使用特殊标点符号&amp;或者集合函数intersection() 获取集合的交集（两集合共有元素） 123456&gt;&gt;&gt; a = &#123;1, 2&#125; &gt;&gt;&gt; b = &#123;2, 3&#125;&gt;&gt;&gt; a &amp; b &#123;2&#125; &gt;&gt;&gt; a.intersection(b) &#123;2&#125; 并集：使用 |或者union()函数来获取集合的并集（至少出现在一个集合中的元素）： 123456&gt;&gt;&gt; a = &#123;1, 2&#125; &gt;&gt;&gt; b = &#123;2, 3&#125;&gt;&gt;&gt; a | b &#123;1, 2, 3&#125; &gt;&gt;&gt; a.union(b) &#123;1, 2, 3&#125; 差集：使用字符-或者difference()可以获得两个集合的差集（出现在第一个集合但不出现在第二个集合）： 1234&gt;&gt;&gt; a - b &#123;1&#125; &gt;&gt;&gt; a.difference(b) &#123;1&#125; 异或集:使用^或者symmetric_difference()可以获得两个集合的异或集（仅在两个集合中出现一次）： 1234&gt;&gt;&gt; a ^ b &#123;1, 3&#125; &gt;&gt;&gt; a.symmetric_difference(b) &#123;1, 3&#125; 子集：使用&lt;=或者issubset()可以判断一个集合是否是另一个集合的子集（第一个集合的所有元素都出现在第二个集合中）： 1234&gt;&gt;&gt; a &lt;= b False &gt;&gt;&gt; a.issubset(b) False 真子集:当第二个集合包含所有第一个集合的元素，且仍包含其他元素时，我们称第一个集合为第二个集合的真子集。使用&lt;可以进行判断： 1234&gt;&gt;&gt; a &lt; b False &gt;&gt;&gt; a &lt; a False 超集：超集与子集正好相反（第二个集合的所有元素都出现在第一个集合中），使用 &gt;=或者 issuperset() 可以进行判断： 1234&gt;&gt;&gt; a &gt;= b False &gt;&gt;&gt; a.issuperset(b) False 一个集合是它本身的超集： 1234&gt;&gt;&gt; a &gt;= a True &gt;&gt;&gt; a.issuperset(a) True 真超集:使用&gt;可以找到一个集合的真超集（第一个集合包含第二个集合的所有元素且还包含其他元素）： 12&gt;&gt;&gt; a &gt; b False]]></content>
      <categories>
        <category>计算机</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机：语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作：媒立方采集点数据与天目云采集点差异比较]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%B7%A5%E4%BD%9C%EF%BC%9A%E5%AA%92%E7%AB%8B%E6%96%B9%E9%87%87%E9%9B%86%E7%82%B9%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%A4%A9%E7%9B%AE%E4%BA%91%E9%87%87%E9%9B%86%E7%82%B9%E5%B7%AE%E5%BC%82%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[请输入密码以阅读这篇私密文章。 Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python：excel处理（xld与xlwt）]]></title>
    <url>%2F2019%2F07%2F16%2FPython%EF%BC%9Aexcel%E5%A4%84%E7%90%86%EF%BC%88xld%E4%B8%8Exlwt%EF%BC%89%2F</url>
    <content type="text"><![CDATA[excel处理工具:xlrd与xlwt xlrd是python语言中读取excel的扩展工具包，可以实现指定表单、指定单元格的读取。 xlwt是python语言中写excel的扩展工具包，可以实现指定表单、指定单元格的写入。 一、xlrd安装使用 pip install xlrd 来安装xlrd模块。 基本操作123456789101112131415161718192021222324252627282930313233343536# 示例：# 导入扩展包import xlrd# 打开Excel文件读取数据data = xlrd.open_workbook('excelFile.xls') [1] # 获取一个工作表table = data.sheets()[0] #通过索引顺序获取table = data.sheet_by_index(0) #通过索引顺序获取table = data.sheet_by_name(u'Sheet1') #通过名称获取# 获取整行和整列的值（数组）table.row_values(i)table.col_values(i)# 获取行数和列数nrows = table.nrowsncols = table.ncols# 循环行列表数据for i in range(nrows ):print table.row_values(i)# 单元格table.cell(rowx,colx)cell_A1 = table.cell(0,0).valuecell_C4 = table.cell(3,2).value# 使用行列索引cell_A1 = table.row(0)[0].valuecell_A2 = table.col(1)[0].value# 简单的写入row = 0col = 0# 常用单元格中的类型 empty,1 string, 2 number, 3 date, 4 boolean, 5 error, 6 blankctype = 1 value = '单元格的值'# 扩展的格式化xf = 0 table.put_cell(row, col, ctype, value, xf)table.cell(0,0) #单元格的值'table.cell(0,0).value #单元格的值' 二、xlwt安装使用 pip install xlwt 来安装xlwt模块。 基本操作12345678910# 导入模块import xlwt# 创建workbook（其实就是excel，后来保存一下就行）workbook = xlwt.Workbook(encoding = 'ascii')# 创建表worksheet = workbook.add_sheet('My Worksheet')# 往单元格内写入内容worksheet.write(0, 0, label = 'Row 0, Column 0 Value')# 保存workbook.save('Excel_Workbook.xls')]]></content>
      <categories>
        <category>计算机</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机：语言</tag>
      </tags>
  </entry>
</search>
